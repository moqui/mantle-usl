<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <!-- =========================================== -->
    <!-- ========== Invoice View Services ========== -->
    <!-- =========================================== -->

    <service verb="get" noun="InvoiceBasicInfo">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="activeOrgId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="invoice" type="Map"/>
            <parameter name="editableStatusIds" type="Set"><parameter name="statusId"/></parameter>
            <parameter name="invoiceEditable" type="Boolean"/>
            <parameter name="recordPaymentStatusIds" type="Set"><parameter name="statusId"/></parameter>
            <parameter name="canRecordPayments" type="Boolean"/>

            <parameter name="isFromPartyOrgInternal" type="Boolean"/>
            <parameter name="isToPartyOrgInternal" type="Boolean"/>
            <parameter name="organizationPartyId"><description>Org considered primary for this invoice to determine payable or
                receivable; based on activeOrgId if specified, otherwise defaults to whichever party has role OrgInternal and
                defaulting to fromPartyId</description></parameter>
            <parameter name="isPayableInvoice" type="Boolean">
                <description>If true invoice is payable for activeOrgId or default logic, otherwise is receivable</description></parameter>
            <parameter name="statusFlowId"/>

            <parameter name="invoiceTotal" type="BigDecimal"/>
            <parameter name="appliedPaymentsTotal" type="BigDecimal"/>
            <parameter name="unpaidTotal" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <if condition="invoice == null"><return error="true" message="Invoice not found with ID ${invoiceId}"/></if>

            <!-- calc invoice totals -->
            <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoiceId]" out-map="context"/>

            <set field="editableStatusIds" from="new HashSet(['InvoiceInProcess', 'InvoiceIncoming', 'InvoiceReceived'])"/>
            <set field="invoiceEditable" from="editableStatusIds.contains(invoice.statusId)"/>
            <set field="recordPaymentStatusIds" from="new HashSet(['InvoiceInProcess', 'InvoiceFinalized', 'InvoiceSent', 'InvoiceAcked', 'InvoiceWriteOff', 'InvoiceReceived', 'InvoiceApproved'])"/>
            <set field="canRecordPayments" from="recordPaymentStatusIds.contains(invoice.statusId) &amp;&amp; unpaidTotal > 0.0"/>

            <!-- see if from/to parties are internal orgs -->
            <entity-find-count entity-name="mantle.party.PartyRole" count-field="fromOrgInternalCount">
                <econdition field-name="partyId" from="invoice.fromPartyId"/>
                <econdition field-name="roleTypeId" value="OrgInternal"/></entity-find-count>
            <set field="isFromPartyOrgInternal" from="fromOrgInternalCount &gt; 0"/>
            <entity-find-count entity-name="mantle.party.PartyRole" count-field="toOrgInternalCount">
                <econdition field-name="partyId" from="invoice.toPartyId"/>
                <econdition field-name="roleTypeId" value="OrgInternal"/></entity-find-count>
            <set field="isToPartyOrgInternal" from="toOrgInternalCount &gt; 0"/>

            <!-- for context sensitive selection of the OrgInternal to use if both from and to parties are OrgInternal start with activeOrgId -->
            <!-- also consider userOrgIds if no activeOrdId; better default in some cases for particular users even if forget to set active org -->
            <service-call name="mantle.party.PartyServices.get#PartyOrganizationInfo" out-map="context" in-map="[partyId:partyId]"/>
            <if condition="activeOrgId &amp;&amp; ((isFromPartyOrgInternal &amp;&amp; activeOrgId == invoice.fromPartyId) ||
                    (isToPartyOrgInternal &amp;&amp; activeOrgId == invoice.toPartyId))"><then>
                <set field="organizationPartyId" from="activeOrgId"/>
            </then><else-if condition="isToPartyOrgInternal &amp;&amp; invoice.toPartyId in userOrgIds">
                <set field="organizationPartyId" from="invoice.toPartyId"/>
            </else-if><else-if condition="isFromPartyOrgInternal &amp;&amp; invoice.fromPartyId in userOrgIds">
                <set field="organizationPartyId" from="invoice.fromPartyId"/>
            </else-if><else>
                <set field="organizationPartyId" from="isFromPartyOrgInternal ? invoice.fromPartyId : invoice.toPartyId"/>
            </else></if>
            <set field="isPayableInvoice" from="organizationPartyId == invoice.toPartyId"/>
            <!-- statusFlowId used in StatusChangeSection, see seed data in AccountingAccountEntities.xml -->
            <set field="statusFlowId" from="isPayableInvoice ? 'InvoicePayable' : 'InvoiceReceivable'"/>
            <!-- check the statusFlowId to make sure it has transitions, for backward compatibility from before these had seed data! -->
            <entity-find-count entity-name="moqui.basic.StatusFlowTransition" count-field="statusFlowTransCount" cache="true">
                <econdition field-name="statusFlowId"/></entity-find-count>
            <if condition="statusFlowTransCount == 0"><set field="statusFlowId" from="null"/></if>
        </actions>
    </service>
    <service verb="get" noun="InvoiceDisplayInfo">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="activeOrgId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="invoice" type="Map"/>
            <parameter name="editableStatusIds" type="Set"><parameter name="statusId"/></parameter>
            <parameter name="invoiceEditable" type="Boolean"/>
            <parameter name="recordPaymentStatusIds" type="Set"><parameter name="statusId"/></parameter>
            <parameter name="canRecordPayments" type="Boolean"/>

            <parameter name="isFromPartyOrgInternal" type="Boolean"/>
            <parameter name="isToPartyOrgInternal" type="Boolean"/>
            <parameter name="organizationPartyId"><description>Org considered primary for this invoice to determine payable or
                receivable; based on activeOrgId if specified, otherwise defaults to whichever party has role OrgInternal and
                defaulting to fromPartyId</description></parameter>
            <parameter name="isPayableInvoice" type="Boolean">
                <description>If true invoice is payable for activeOrgId or default logic, otherwise is receivable</description></parameter>
            <parameter name="statusFlowId"/>
            <parameter name="dupInvoiceList" type="List"><description>List of invoices matching referenceNumber and
                other party (non org internal)</description><parameter name="dupInvoice" type="Map"/></parameter>

            <parameter name="invoiceTotal" type="BigDecimal"/>
            <parameter name="appliedPaymentsTotal" type="BigDecimal"/>
            <parameter name="unpaidTotal" type="BigDecimal"/>

            <parameter name="paymentApplicationList" type="List"><parameter name="paymentApplication" type="Map"/></parameter>
            <parameter name="unappliedPaymentInfoList" type="List"><parameter name="unappliedPaymentInfo" type="Map"/></parameter>
            <parameter name="unpaidInvoiceInfoList" type="List">
                <parameter name="unpaidInvoiceInfo" type="Map">
                    <parameter name="invoice" type="Map"/>
                    <parameter name="invoiceTotal" type="BigDecimal"/>
                    <parameter name="appliedPaymentsTotal" type="BigDecimal"/>
                    <parameter name="unpaidTotal" type="BigDecimal"/>
                    <parameter name="maxApplicableAmount" type="BigDecimal"/>
                </parameter>
            </parameter>
            <parameter name="statusHistoryList" type="List"><parameter name="auditLog" type="Map"/></parameter>

            <parameter name="orderItemBillingList" type="List"><parameter name="orderItemBilling" type="Map"/></parameter>
            <parameter name="orderIdSet" type="Set"><parameter name="orderId"/></parameter>
            <parameter name="orderPromisedPaymentList" type="List"><parameter name="orderPromisedPayment" type="Map"/></parameter>
            <parameter name="shipmentItemSourceList" type="List"><parameter name="shipmentItemSource" type="Map"/></parameter>
            <parameter name="shipmentIdSet" type="Set"><parameter name="shipmentId"/></parameter>
            <parameter name="returnItemBillingList" type="List"><parameter name="returnItemBilling" type="Map"/></parameter>
            <parameter name="returnIdSet" type="Set"><parameter name="returnId"/></parameter>

            <parameter name="acctgTransList" type="List"><parameter name="acctgTrans" type="Map"/></parameter>
            <parameter name="acctgTransIdSet" type="Set"><parameter name="acctgTransId"/></parameter>
        </out-parameters>
        <actions>
            <!-- get invoice party/etc info -->
            <service-call name="mantle.account.InvoiceServices.get#InvoiceBasicInfo" out-map="context"
                    in-map="[invoiceId:invoiceId, activeOrgId:activeOrgId]"/>

            <!-- look for duplicate invoices by referenceNumber -->
            <if condition="isFromPartyOrgInternal &amp;&amp; invoice.referenceNumber">
                <entity-find entity-name="mantle.account.invoice.Invoice" list="dupInvoiceList">
                    <econdition field-name="invoiceId" operator="not-equals"/>
                    <econdition field-name="toPartyId" from="invoice.toPartyId"/>
                    <econdition field-name="referenceNumber" from="invoice.referenceNumber"/>
                </entity-find>
            </if>
            <if condition="isToPartyOrgInternal &amp;&amp; invoice.referenceNumber">
                <entity-find entity-name="mantle.account.invoice.Invoice" list="dupInvoiceList">
                    <econdition field-name="invoiceId" operator="not-equals"/>
                    <econdition field-name="fromPartyId" from="invoice.fromPartyId"/>
                    <econdition field-name="referenceNumber" from="invoice.referenceNumber"/>
                </entity-find>
            </if>

            <!-- get payment applications -->
            <entity-find entity-name="mantle.account.payment.PaymentApplication" list="paymentApplicationList">
                <econditions combine="or">
                    <econdition field-name="invoiceId"/>
                    <econdition field-name="toInvoiceId" from="invoiceId"/>
                </econditions>
                <order-by field-name="appliedDate"/>
            </entity-find>
            <!-- get payments with reverse from/to parties that might be applied to this invoice -->
            <entity-find entity-name="mantle.account.payment.Payment" list="unappliedPaymentList" limit="50">
                <econdition field-name="fromPartyId" from="invoice.toPartyId"/>
                <econdition field-name="toPartyId" from="invoice.fromPartyId"/>
                <econdition field-name="paymentTypeEnumId" operator="in" value="PtInvoicePayment,PtPrePayment,PtPrePaymentInventory"/>
                <econdition field-name="statusId" operator="in" value="PmntPromised,PmntAuthorized,PmntDelivered,PmntConfirmed"/>
                <econdition field-name="unappliedTotal" operator="greater" from="0.0"/>
                <order-by field-name="effectiveDate,paymentId"/>
            </entity-find>
            <set field="unappliedPaymentInfoList" from="[]"/>
            <iterate list="unappliedPaymentList" entry="unappliedPayment">
                <service-call name="mantle.account.PaymentServices.get#PaymentTotals" in-map="[paymentId:unappliedPayment.paymentId]"
                        out-map="pmtTotal" out-map-add-to-existing="false"/>
                <set field="maxApplicableAmount" from="unpaidTotal"/>
                <if condition="maxApplicableAmount > pmtTotal.unappliedTotal"><set field="maxApplicableAmount" from="pmtTotal.unappliedTotal"/></if>
                <script>unappliedPaymentInfoList.add(pmtTotal + [payment:unappliedPayment, maxApplicableAmount:maxApplicableAmount,
                        allowApply:(maxApplicableAmount &amp;&amp; unappliedPayment.statusId in ['PmntDelivered','PmntConfirmed'])])</script>
            </iterate>
            <!-- get invoices with reverse from/to parties that this payment might be applied to -->
            <entity-find entity-name="mantle.account.invoice.Invoice" list="unpaidInvoiceList" limit="50">
                <econdition field-name="fromPartyId" from="invoice.toPartyId"/>
                <econdition field-name="toPartyId" from="invoice.fromPartyId"/>
                <econdition field-name="statusId" operator="in"
                        value="InvoiceInProcess,InvoiceFinalized,InvoiceSent,InvoiceAcked,InvoiceReceived,InvoiceApproved"/>
                <econdition field-name="unpaidTotal" operator="greater" from="0.0"/>
                <order-by field-name="invoiceDate,invoiceId"/>
            </entity-find>
            <set field="unpaidInvoiceInfoList" from="[]"/>
            <iterate list="unpaidInvoiceList" entry="unpaidInvoice">
                <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:unpaidInvoice.invoiceId]"
                        out-map="invTot" out-map-add-to-existing="false"/>
                <set field="maxApplicableAmount" from="unpaidTotal"/>
                <if condition="maxApplicableAmount > invTot.unpaidTotal"><set field="maxApplicableAmount" from="invTot.unpaidTotal"/></if>
                <script>unpaidInvoiceInfoList.add(invTot + [invoice:unpaidInvoice, maxApplicableAmount:maxApplicableAmount,
                    allowApply:(maxApplicableAmount &amp;&amp; unpaidInvoice.statusId in ['InvoiceFinalized','InvoiceSent','InvoiceAcked','InvoiceApproved'])])</script>
            </iterate>

            <!-- get status history -->
            <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusHistoryList">
                <econdition field-name="changedEntityName" value="mantle.account.invoice.Invoice"/>
                <econdition field-name="changedFieldName" value="statusId"/>
                <econdition field-name="pkPrimaryValue" from="invoiceId"/>
                <order-by field-name="changedDate"/>
            </entity-find>

            <!-- get associated order items -->
            <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                <econdition field-name="invoiceId"/><order-by field-name="invoiceItemSeqId"/></entity-find>
            <!-- extract related order IDs -->
            <set field="orderIdSet" from="new TreeSet(orderItemBillingList*.orderId)"/>
            <!-- get promised payments for associated orders -->
            <if condition="orderIdSet">
                <entity-find entity-name="mantle.account.payment.Payment" list="orderPromisedPaymentList">
                    <econdition field-name="orderId" operator="in" from="orderIdSet"/>
                    <econdition field-name="statusId" operator="in" value="PmntPromised,PmntAuthorized"/>
                </entity-find>
            </if>

            <!-- get associated shipment items -->
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                <econdition field-name="invoiceId"/></entity-find>
            <set field="shipmentIdSet" from="new TreeSet(shipmentItemSourceList*.shipmentId)"/>

            <!-- get associated return items -->
            <entity-find entity-name="mantle.order.return.ReturnItemBilling" list="returnItemBillingList">
                <econdition field-name="invoiceId"/></entity-find>
            <set field="returnIdSet" from="new TreeSet(returnItemBillingList*.returnId)"/>

            <!-- get associated accounting transactions -->
            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="acctgTransList">
                <econdition field-name="invoiceId"/></entity-find>
            <set field="acctgTransIdSet" from="new TreeSet(acctgTransList*.acctgTransId)"/>
        </actions>
    </service>

    <service verb="get" noun="InvoiceTotal">
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="invoiceTotal" type="BigDecimal"/>
            <parameter name="appliedPaymentsTotal" type="BigDecimal"/>
            <parameter name="unpaidTotal" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <!-- NOTE: the approach used here is less efficient than letting the DB due the multiply/sum/etc or selecting only
                fields needed but is compatible with the TransactionCache -->
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="invoiceItemList">
                <econdition field-name="invoiceId"/></entity-find>
            <set field="invoiceTotal" from="0.0"/>
            <iterate list="invoiceItemList" entry="invoiceItem">
                <!-- NOTE: also a sales/VAT tax calculation concern on item vs invoice level, but using 2 digits so consistent across order, invoice, GL TX entry
                    (tax should generally be calculated to 3 digits on the item level then summed and rounded to 2 digits to get a tax total) -->
                <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
                <set field="invoiceTotal" from="invoiceTotal + ((invoiceItem.quantity != null ? invoiceItem.quantity : 1.0) * (invoiceItem.amount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            </iterate>
            <!-- round total to 2 decimal places -->
            <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
            <set field="invoiceTotal" from="(invoiceTotal as BigDecimal).setScale(2, BigDecimal.ROUND_HALF_UP)"/>

            <!-- PaymentApplication by invoiceId (expect either paymentId to toInvoiceId to be populated) -->
            <!-- PaymentApplication by toInvoiceId (expect invoiceId to be populated) -->
            <entity-find entity-name="mantle.account.payment.PaymentApplication" list="paymentApplicationList">
                <econditions combine="or">
                    <econdition field-name="invoiceId"/>
                    <econdition field-name="toInvoiceId" from="invoiceId"/>
                </econditions>
            </entity-find>
            <set field="appliedPaymentsTotal" from="0.0"/>
            <iterate list="paymentApplicationList" entry="paymentApplication">
                <set field="appliedPaymentsTotal" from="appliedPaymentsTotal + (paymentApplication.amountApplied ?: 0.0)"/></iterate>

            <set field="unpaidTotal" from="invoiceTotal - appliedPaymentsTotal"/>
        </actions>
    </service>
    <service verb="update" noun="InvoiceTotals">
        <description>Update invoiceTotal, appliedPaymentsTotal, and unpaidTotal fields on an Invoice based on InvoiceItem and
            PaymentApplication records, called by EECA on InvoiceItem and PaymentApplication</description>
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoiceId]" out-map="totalOut"/>
            <set field="invoice.invoiceTotal" from="totalOut.invoiceTotal"/>
            <set field="invoice.appliedPaymentsTotal" from="totalOut.appliedPaymentsTotal"/>
            <set field="invoice.unpaidTotal" from="totalOut.unpaidTotal"/>
            <entity-update value-field="invoice"/>

            <!-- If Invoice Finalized or Approved and total is zero set to Payment Received or Sent -->
            <if condition="invoice.statusId == 'InvoiceFinalized' || invoice.statusId == 'InvoiceApproved'">
                <if condition="totalOut.unpaidTotal == 0.0">
                    <service-call name="update#mantle.account.invoice.Invoice"
                            in-map="[invoiceId:invoiceId, statusId:(invoice.statusId == 'InvoiceFinalized' ? 'InvoicePmtRecvd' : 'InvoicePmtSent')]"/>
                </if>
            </if>
        </actions>
    </service>
    <service verb="calculate" noun="MissingInvoiceTotals" transaction-timeout="600">
        <description>This is a simple service not meant for very large Invoice tables and mainly for migration from older versions
            of mantle-usl before the invoiceTotal, appliedPaymentsTotal, and unpaidTotal fields were added.</description>
        <in-parameters><parameter name="calculateAll" type="Boolean" default="false"/></in-parameters>
        <actions>
            <entity-find entity-name="mantle.account.invoice.Invoice" list="invoiceList">
                <econdition field-name="invoiceTotal" operator="is-null" ignore="calculateAll"/></entity-find>
            <iterate list="invoiceList" entry="invoice">
                <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoice.invoiceId]"
                        out-map="totalOut" out-map-add-to-existing="false"/>
                <set field="invoice.invoiceTotal" from="totalOut.invoiceTotal"/>
                <set field="invoice.appliedPaymentsTotal" from="totalOut.appliedPaymentsTotal"/>
                <set field="invoice.unpaidTotal" from="totalOut.unpaidTotal"/>
                <entity-update value-field="invoice"/>
            </iterate>
            <log level="warn" message="Calculated totals for ${invoiceList.size()} Invoices"/>
        </actions>
    </service>

    <service verb="get" noun="InvoicePrintInfo">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="templateSettingSuffix" default-value="TemplateInvoicePrint"/>
        </in-parameters>
        <out-parameters>
            <parameter name="invoice" type="Map"/>
            <parameter name="currentStatus" type="Map"/>
            <parameter name="invoiceTotal" type="BigDecimal"/>
            <parameter name="appliedPaymentsTotal" type="BigDecimal"/>
            <parameter name="unpaidTotal" type="BigDecimal"/>
            <parameter name="noAdjustmentTotal" type="BigDecimal"/>
            <parameter name="adjustmentTotal" type="BigDecimal"/>
            <parameter name="settlementTerm" type="Map"/>
            <parameter name="orderIdSet" type="Set"><parameter name="orderId"/></parameter>
            <parameter name="paymentApplicationList" type="List"><parameter name="paymentApplication" type="Map"/></parameter>

            <parameter name="invoiceItemList" type="List"><parameter name="invoiceItem" type="Map"/></parameter>
            <parameter name="topItemList" type="List"><parameter name="invoiceItem" type="Map"/></parameter>
            <parameter name="adjustmentItemList" type="List"><parameter name="invoiceItem" type="Map"/></parameter>
            <parameter name="itemTypeSummaryMapList" type="List"><parameter name="itemTypeSummary" type="Map"/></parameter>
            <parameter name="hasProductItems" type="Boolean"/>
            <parameter name="hasTimeEntryItems" type="Boolean"/>

            <parameter name="fromParty" type="Map"/>
            <parameter name="fromContactInfo" type="Map"><description>From the mantle.party.ContactServices.get#PartyContactInfo service.</description></parameter>
            <parameter name="logoImageLocation"/>
            <parameter name="toParty" type="Map"/>
            <parameter name="toContactInfo" type="Map"><description>From the mantle.party.ContactServices.get#PartyContactInfo service.</description></parameter>
            <parameter name="toBillingRep" type="Map"/>

            <parameter name="finalizedStatusHistoryList" type="List"><parameter name="entityAuditLog" type="Map"/></parameter>

            <parameter name="templateLocation"><description>Looked up from ProductStoreSetting and if no setting found for store or
                no stores are associated with the Invoice then from PartySetting (for fromPartyId).</description></parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <entity-find-one entity-name="moqui.basic.StatusItem" value-field="currentStatus">
                <field-map field-name="statusId" from="invoice?.statusId"/></entity-find-one>
            <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoiceId]" out-map="context"/>
            <entity-find-related-one value-field="invoice" relationship-name="mantle.account.invoice.SettlementTerm" to-value-field="settlementTerm"/>

            <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                <econdition field-name="invoiceId"/><order-by field-name="invoiceItemSeqId"/></entity-find>
            <set field="orderIdSet" from="new TreeSet(orderItemBillingList*.orderId)"/>

            <entity-find entity-name="mantle.account.payment.PaymentApplication" list="paymentApplicationList">
                <econditions combine="or">
                    <econdition field-name="invoiceId"/>
                    <econdition field-name="toInvoiceId" from="invoiceId"/>
                </econditions>
                <order-by field-name="appliedDate"/>
            </entity-find>

            <!-- Invoice Items - Adjustment items separated -->
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="invoiceItemList">
                <econdition field-name="invoiceId"/>
                <econdition field-name="isAdjustment" value="N" or-null="true"/>
                <order-by field-name="invoiceItemSeqId"/>
            </entity-find>
            <set field="topItemList" from="invoiceItemList.findAll({ it.parentItemSeqId == null })"/>

            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="adjustmentItemList">
                <econdition field-name="invoiceId"/>
                <econdition field-name="isAdjustment" value="Y"/>
                <order-by field-name="invoiceItemSeqId"/>
            </entity-find>

            <set field="noAdjustmentTotal" from="0.0"/>
            <iterate list="invoiceItemList" entry="invoiceItem">
                <set field="noAdjustmentTotal" from="noAdjustmentTotal + ((invoiceItem.quantity != null ? invoiceItem.quantity : 1.0) * (invoiceItem.amount ?: 0.0))"/></iterate>
            <set field="noAdjustmentTotal" from="(noAdjustmentTotal as BigDecimal).setScale(2, BigDecimal.ROUND_HALF_UP)"/>

            <set field="adjustmentTotal" from="0.0"/>
            <iterate list="adjustmentItemList" entry="invoiceItem">
                <set field="adjustmentTotal" from="adjustmentTotal + ((invoiceItem.quantity != null ? invoiceItem.quantity : 1.0) * (invoiceItem.amount ?: 0.0))"/></iterate>
            <set field="adjustmentTotal" from="(adjustmentTotal as BigDecimal).setScale(2, BigDecimal.ROUND_HALF_UP)"/>

            <!-- build itemTypeSummaryMapMap with itemTypeEnumId, amount (only for ItemTimeEntry), quantity, total -->
            <set field="hasProductItems" from="false"/>
            <set field="hasTimeEntryItems" from="false"/>
            <set field="itemTypeSummaryMapMap" from="[:]"/>
            <iterate list="invoiceItemList" entry="invoiceItem">
                <set field="mapKey" from="invoiceItem.itemTypeEnumId"/>
                <if condition="invoiceItem.itemTypeEnumId == 'ItemTimeEntry'">
                    <set field="mapKey" from="mapKey + '::' + invoiceItem.amount"/>
                    <set field="hasTimeEntryItems" from="true"/>
                </if>
                <if condition="invoiceItem.productId"><set field="hasProductItems" from="true"/></if>
                <set field="itemTypeSummaryMap" from="itemTypeSummaryMapMap.get(mapKey)"/>
                <if condition="!itemTypeSummaryMap">
                    <set field="itemTypeSummaryMap" from="[itemTypeEnumId:invoiceItem.itemTypeEnumId, quantity:0, total:0]"/>
                    <if condition="invoiceItem.itemTypeEnumId == 'ItemTimeEntry'">
                        <set field="itemTypeSummaryMap.amount" from="invoiceItem.amount"/></if>
                    <script>itemTypeSummaryMapMap.put(mapKey, itemTypeSummaryMap)</script>
                </if>
                <set field="itemTypeSummaryMap.quantity" from="itemTypeSummaryMap.quantity + (invoiceItem.quantity ?: 1)"/>
                <set field="itemTypeSummaryMap.total" from="itemTypeSummaryMap.total + ((invoiceItem.quantity ?: 1) * (invoiceItem.amount ?: 0))"/>
            </iterate>
            <set field="itemTypeSummaryMapList" from="itemTypeSummaryMapMap.values()"/>

            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="fromParty">
                <field-map field-name="partyId" from="invoice.fromPartyId"/></entity-find-one>
            <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="fromContactInfo"
                    in-map="[partyId:invoice.fromPartyId, postalContactMechPurposeId:'PostalPayment',
                        telecomContactMechPurposeId:'PhonePayment', faxContactMechPurposeId:'PhonePaymentFax',
                        emailContactMechPurposeId:'EmailPayment']"/>
            <service-call name="mantle.party.PartyServices.get#PartyContentLocation" out-map="logoImageOut"
                          in-map="[partyId:invoice.fromPartyId, partyContentTypeEnumIdList:['PcntLogoImage', 'PcntPrimaryImage']]"/>
            <set field="logoImageLocation" from="logoImageOut.contentLocation"/>

            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toParty">
                <field-map field-name="partyId" from="invoice.toPartyId"/></entity-find-one>
            <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="toContactInfo"
                    in-map="[partyId:invoice.toPartyId, postalContactMechPurposeId:'PostalBilling',
                        telecomContactMechPurposeId:'PhoneBilling', emailContactMechPurposeId:'EmailBilling']"/>
            <entity-find entity-name="mantle.party.PartyRelationship" list="toBillingRelList">
                <date-filter/>
                <econdition field-name="toPartyId" from="invoice.toPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtRepresentative"/>
                <econdition field-name="fromRoleTypeId" value="ClientBilling"/>
            </entity-find>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toBillingRep">
                <field-map field-name="partyId" from="toBillingRelList?.first?.fromPartyId"/></entity-find-one>

            <!-- get Finalized status history -->
            <entity-find entity-name="moqui.entity.EntityAuditLog" list="finalizedStatusHistoryList">
                <econdition field-name="changedEntityName" value="mantle.account.invoice.Invoice"/>
                <econdition field-name="changedFieldName" value="statusId"/>
                <econdition field-name="pkPrimaryValue" from="invoiceId"/>
                <econdition field-name="newValueText" value="InvoiceFinalized"/>
                <order-by field-name="-changedDate"/>
            </entity-find>

            <!-- Get templateLocation from settings -->
            <set field="templateLocation" from="null"/>
            <!-- see if a template is configured by ProductStoreSetting -->
            <service-call name="mantle.account.InvoiceServices.find#InvoiceProductStores" in-map="context" out-map="context"/>
            <if condition="productStoreIdSet">
                <entity-find entity-name="mantle.product.store.ProductStoreSetting" list="productStoreSettingList" cache="true">
                    <date-filter/>
                    <econdition field-name="productStoreId" from="productStoreIdSet.first()"/>
                    <econdition field-name="settingTypeEnumId" value="Psst${templateSettingSuffix}"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="productStoreSettingList">
                    <set field="templateLocation" from="productStoreSettingList[0].settingValue"/></if>
            </if>
            <!-- if no template setting for store look for PartySetting on Shipment.fromPartyId -->
            <if condition="!templateLocation &amp;&amp; invoice.fromPartyId">
                <service-call name="mantle.party.PartyServices.get#PartySettingValue" out-map="ptySettingOut"
                        in-map="[partyId:invoice.fromPartyId, partySettingTypeId:('Org' + templateSettingSuffix)]"/>
                <set field="templateLocation" from="ptySettingOut?.settingValue"/>
            </if>
        </actions>
    </service>
    <service verb="get" noun="ReceivableStatementInfo">
        <in-parameters>
            <parameter name="toPartyId" required="true"/>
            <parameter name="fromPartyId"/>
            <parameter name="periodDays" type="Integer" default="30"/>
            <parameter name="asOfDate" type="Date"/>
        </in-parameters>
        <out-parameters>
            <parameter name="toParty" type="Map"/>
            <parameter name="toContactInfo" type="Map"><description>From the mantle.party.ContactServices.get#PartyContactInfo service.</description></parameter>
            <parameter name="toBillingRep" type="Map"/>
            <parameter name="periodDays" type="Integer"/>
            <parameter name="asOfTimestamp" type="Timestamp"/>
            <parameter name="currencyUomId"/>
            <parameter name="receivableInfoList" type="List"><parameter name="receivableInfo" type="Map">
                <parameter name="fromPartyId"/>
                <parameter name="fromParty" type="Map"/>
                <parameter name="fromContactInfo" type="Map"><description>From the mantle.party.ContactServices.get#PartyContactInfo service.</description></parameter>
                <parameter name="logoImageLocation"/>
                <parameter name="invoiceList"><parameter name="invoice" type="Map"/></parameter>
                <parameter name="invoiceTotal" type="BigDecimal"/>
                <parameter name="unpaidTotal" type="BigDecimal"/>

                <parameter name="unappliedPaymentList" type="List"><parameter name="payment" type="Map"/></parameter>
                <parameter name="paymentTotal" type="BigDecimal"/>
                <parameter name="unappliedTotal" type="BigDecimal"/>
                <parameter name="balanceDue" type="BigDecimal"/>

                <parameter name="agingSummaryList"><parameter name="agingSummary" type="Map"/></parameter>
                <parameter name="receivableAgingList"><parameter name="unpaidAmount" type="BigDecimal"/></parameter>
                <parameter name="receivableDueAgingList"><parameter name="unpaidAmount" type="BigDecimal"/></parameter>
            </parameter></parameter>
        </out-parameters>
        <actions>
            <set field="periodDaysBd" from="new BigDecimal(periodDays)"/>
            <set field="asOfTimestamp" from="asOfDate ? ec.l10n.parseTimestamp(ec.l10n.format(asOfDate, 'yyyy-MM-dd') + ' 23:59:59.999', 'yyyy-MM-dd HH:mm:ss.SSS') : ec.user.nowTimestamp"/>

            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toParty">
                <field-map field-name="partyId" from="toPartyId"/></entity-find-one>
            <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="toContactInfo"
                    in-map="[partyId:toPartyId, postalContactMechPurposeId:'PostalBilling',
                        telecomContactMechPurposeId:'PhoneBilling', emailContactMechPurposeId:'EmailBilling']"/>
            <entity-find entity-name="mantle.party.PartyRelationship" list="toBillingRelList">
                <date-filter/>
                <econdition field-name="toPartyId" from="toPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtRepresentative"/>
                <econdition field-name="fromRoleTypeId" value="ClientBilling"/>
            </entity-find>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toBillingRep">
                <field-map field-name="partyId" from="toBillingRelList?.first?.fromPartyId"/></entity-find-one>

            <!-- all Invoices -->
            <entity-find entity-name="mantle.account.invoice.Invoice" list="allInvoiceList">
                <econdition field-name="statusId" operator="in" value="InvoiceFinalized,InvoiceSent,InvoiceAcked"/>
                <econdition field-name="unpaidTotal" operator="not-equals" from="0.0"/>
                <econdition field-name="toPartyId"/>
                <econdition field-name="fromPartyId" ignore-if-empty="true"/>
                <order-by field-name="invoiceDate"/>
            </entity-find>
            <!-- all Payments -->
            <entity-find entity-name="mantle.account.payment.Payment" list="allUnappliedPaymentList">
                <econdition field-name="fromPartyId" from="toPartyId"/>
                <econdition field-name="toPartyId" from="fromPartyId" ignore-if-empty="true"/>
                <econdition field-name="unappliedTotal" operator="not-equals" from="0.0"/>
                <econdition field-name="statusId" operator="in" value="PmntDelivered,PmntConfirmed"/>
            </entity-find>
            <set field="fromPartyIds" from="new TreeSet(allInvoiceList*.fromPartyId + allUnappliedPaymentList*.toPartyId)"/>

            <set field="receivableInfoList" from="[]"/>
            <iterate list="fromPartyIds" entry="fromPartyId">
                <set field="invoiceList" from="[]"/>
                <set field="invoiceTotal" from="0.0"/>
                <set field="unpaidTotal" from="0.0"/>
                <set field="receivableAgingList" from="new ArrayList([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])"/>
                <set field="receivableDueAgingList" from="new ArrayList([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])"/>
                <iterate list="allInvoiceList" entry="invoice">
                    <if condition="invoice.fromPartyId != fromPartyId"><continue/></if>
                    <script><![CDATA[
                        invoiceList.add(invoice)
                        invoiceTotal += invoice.invoiceTotal
                        unpaidTotal += invoice.unpaidTotal
                        if (invoice.currencyUomId) currencyUomId = invoice.currencyUomId

                        Integer invoiceDateDays = invoice.invoiceDate != null ? asOfTimestamp - invoice.invoiceDate : null
                        Integer invoiceDateIdx = invoiceDateDays != null ? (invoiceDateDays < 0 ? 0 :
                                ((invoiceDateDays as BigDecimal) / periodDaysBd).setScale(0, BigDecimal.ROUND_DOWN).intValue() + 1) : null
                        if (invoiceDateIdx != null && invoiceDateIdx > 5) invoiceDateIdx = 5
                        Integer dueDateDays = invoice.dueDate != null ? asOfTimestamp - invoice.dueDate : null
                        Integer dueDateIdx = dueDateDays != null ? (dueDateDays < 0 ? 0 :
                                ((dueDateDays as BigDecimal) / periodDaysBd).setScale(0, BigDecimal.ROUND_DOWN).intValue() + 1) : null
                        if (dueDateIdx != null && dueDateIdx > 5) dueDateIdx = 5

                        if (invoiceDateIdx != null) receivableAgingList[invoiceDateIdx] = receivableAgingList[invoiceDateIdx] + invoice.unpaidTotal
                        if (dueDateIdx != null) receivableDueAgingList[dueDateIdx] = receivableDueAgingList[dueDateIdx] + invoice.unpaidTotal
                    ]]></script>
                </iterate>
                <script>
                    agingSummaryList = []
                    agingSummaryList.add([description:'By Due Date', current:receivableDueAgingList[0], period0:receivableDueAgingList[1],
                            period1:receivableDueAgingList[2], period2:receivableDueAgingList[3], period3:receivableDueAgingList[4],
                            periodRemaining:receivableDueAgingList[5], total:receivableDueAgingList.sum()])
                    agingSummaryList.add([description:'By Invoice Date', current:receivableAgingList[0], period0:receivableAgingList[1],
                            period1:receivableAgingList[2], period2:receivableAgingList[3], period3:receivableAgingList[4],
                            periodRemaining:receivableAgingList[5], total:receivableAgingList.sum()])
                </script>

                <set field="unappliedPaymentList" from="[]"/>
                <set field="paymentTotal" from="0.0"/>
                <set field="unappliedTotal" from="0.0"/>
                <iterate list="allUnappliedPaymentList" entry="payment">
                    <if condition="payment.toPartyId != fromPartyId"><continue/></if>
                    <script>unappliedPaymentList.add(payment)</script>
                    <set field="paymentTotal" from="paymentTotal + (payment.amount ?: 0.0)"/>
                    <set field="unappliedTotal" from="unappliedTotal + payment.unappliedTotal"/>
                </iterate>

                <entity-find-one entity-name="mantle.party.PartyDetail" value-field="fromParty">
                    <field-map field-name="partyId" from="fromPartyId"/></entity-find-one>
                <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="fromContactInfo"
                        in-map="[partyId:fromPartyId, postalContactMechPurposeId:'PostalPayment',
                            telecomContactMechPurposeId:'PhonePayment', emailContactMechPurposeId:'EmailPayment']"/>
                <service-call name="mantle.party.PartyServices.get#PartyContentLocation" out-map="logoImageOut"
                        in-map="[partyId:fromPartyId, partyContentTypeEnumIdList:['PcntLogoImage', 'PcntPrimaryImage']]"/>
                <set field="logoImageLocation" from="logoImageOut.contentLocation"/>
                <script>receivableInfoList.add([fromPartyId:fromPartyId, fromParty:fromParty, fromContactInfo:fromContactInfo,
                        logoImageLocation:logoImageOut.contentLocation, invoiceList:invoiceList,
                        invoiceTotal:invoiceTotal, unpaidTotal:unpaidTotal, paymentTotal:paymentTotal, unappliedTotal:unappliedTotal,
                        balanceDue:(unpaidTotal - unappliedTotal), unappliedPaymentList:unappliedPaymentList,
                        agingSummaryList:agingSummaryList, receivableAgingList:receivableAgingList,
                        receivableDueAgingList:receivableDueAgingList])</script>
            </iterate>
        </actions>
    </service>

    <!-- ==================================================== -->
    <!-- ========== Invoice Create/Update Services ========== -->
    <!-- ==================================================== -->

    <service verb="create" noun="Invoice">
        <description>Create an invoice manually (also used for an order part, shipment, project/work, etc). Initial
            status is InvoiceIncoming unless fromPartyId is has the OrgInternal role, then it is InvoiceInProcess.</description>
        <in-parameters>
            <auto-parameters entity-name="mantle.account.invoice.Invoice" include="nonpk">
                <exclude field-name="statusId"/></auto-parameters>
            <parameter name="fromPartyId" required="true"/>
            <parameter name="toPartyId" required="true"/>
            <parameter name="invoiceTypeEnumId" default-value="InvoiceSales"/>
            <parameter name="invoiceDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="currencyUomId"><description>Defaults to PartyAcctgPreference.baseCurrencyUomId for whichever
                Party (from or to) is an internal organization with an accounting preference record.</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="invoiceId"/></out-parameters>
        <actions>
            <entity-find-count entity-name="mantle.party.PartyRole" count-field="fromOrgInternalCount">
                <econdition field-name="partyId" from="fromPartyId"/><econdition field-name="roleTypeId" value="OrgInternal"/></entity-find-count>
            <set field="isFromPartyOrgInternal" from="fromOrgInternalCount &gt; 0"/>
            <entity-find-count entity-name="mantle.party.PartyRole" count-field="toOrgInternalCount">
                <econdition field-name="partyId" from="toPartyId"/><econdition field-name="roleTypeId" value="OrgInternal"/></entity-find-count>
            <set field="isToPartyOrgInternal" from="toOrgInternalCount &gt; 0"/>
            <!-- set the initial statusId based on which party is OrgInternal -->
            <!-- if both parties are in role OrgInternal start in InvoiceInProcess status because Receivable/Outgoing statuses come before Payable/Incoming statuses -->
            <if condition="isToPartyOrgInternal &amp;&amp; !isFromPartyOrgInternal"><then>
                <!-- Payable -->
                <set field="organizationPartyId" from="toPartyId"/>
                <set field="otherPartyId" from="fromPartyId"/>
                <set field="statusId" value="InvoiceIncoming"/>
            </then><else>
                <!-- Receivable -->
                <set field="organizationPartyId" from="fromPartyId"/>
                <set field="otherPartyId" from="toPartyId"/>
                <set field="statusId" value="InvoiceInProcess"/>
            </else></if>

            <!-- get configured currency for org if none specified -->
            <if condition="!currencyUomId">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:organizationPartyId]"/>
                <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId"/>
            </if>
            <if condition="!currencyUomId"><set field="currencyUomId" value="USD"/></if>

            <service-call name="create#mantle.account.invoice.Invoice" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="Invoice">
        <description>Used to update all Invoice fields except statusId.</description>
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <auto-parameters entity-name="mantle.account.invoice.Invoice" include="nonpk">
                <exclude field-name="statusId"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice" for-update="true"/>
            <if condition="!(invoice.statusId in ['InvoiceInProcess', 'InvoiceIncoming', 'InvoiceReceived'])">
                <return error="true" message="Invoice ${invoiceId} is not in a status that allows change"/></if>

            <service-call name="update#mantle.account.invoice.Invoice" in-map="context" out-map="context"/>

            <!-- if invoiceDate changed and there any AssetIssuance records associated with this then update issuedDate on them -->
            <if condition="invoiceDate &amp;&amp; invoiceDate != invoice.invoiceDate">
                <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="assetIssuanceList" for-update="true">
                    <econdition field-name="invoiceId"/></entity-find>
                <iterate list="assetIssuanceList" entry="assetIssuance">
                    <service-call name="mantle.product.AssetServices.update#AssetIssuedDate"
                            in-map="[assetIssuanceId:assetIssuance.assetIssuanceId, issuedDate:invoiceDate]"/>
                </iterate>
            </if>
        </actions>
    </service>
    <service verb="update" noun="InvoiceClosed">
        <description>For finalized/etc invoices update certain fields</description>
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="dueDate" type="Timestamp"/>
            <parameter name="settlementTermId"/>
            <parameter name="paidDate" type="Timestamp"/>
            <parameter name="invoiceMessage"/>
            <parameter name="referenceNumber"/>
            <parameter name="otherPartyOrderId"/>
            <parameter name="description"/>
            <parameter name="lastUpdatedStamp" type="Timestamp"/>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.account.invoice.Invoice" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="checkSet" noun="InvoiceDueDate">
        <in-parameters>
            <parameter name="invoiceId"/>
            <parameter name="overrideExisting" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <if condition="invoice.dueDate != null &amp;&amp; !overrideExisting"><return/></if>

            <set field="origDueDate" from="invoice.dueDate"/>
            <set field="invoiceDate" from="invoice.invoiceDate"/>
            <if condition="!invoice.settlementTermId">
                <entity-find-count entity-name="mantle.party.PartyRole" count-field="fromOrgInternalCount">
                    <econdition field-name="partyId" from="invoice.fromPartyId"/>
                    <econdition field-name="roleTypeId" value="OrgInternal"/></entity-find-count>
                <set field="isFromPartyOrgInternal" from="fromOrgInternalCount &gt; 0"/>

                <set field="organizationPartyId" from="isFromPartyOrgInternal ? invoice.fromPartyId : invoice.toPartyId"/>
                <set field="otherPartyId" from="isFromPartyOrgInternal ? invoice.toPartyId : invoice.fromPartyId"/>

                <!-- get agreed on settlement term if none specified -->
                <!-- find an AgreementTerm with a settlementTermId -->
                <entity-find entity-name="mantle.party.agreement.AgreementAndTerm" list="agreementAndTermList">
                    <date-filter/>
                    <econdition field-name="organizationPartyId"/><econdition field-name="otherPartyId"/>
                    <!-- agreement roles a little funny, anything other than Customer is a vendor of some sort so look for Customer or other -->
                    <econdition field-name="otherRoleTypeId" operator="equals" value="Customer" ignore="!isFromPartyOrgInternal"/>
                    <econdition field-name="otherRoleTypeId" operator="not-equals" value="Customer" ignore="isFromPartyOrgInternal"/>
                    <econdition field-name="settlementTermId" operator="is-not-null"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="agreementAndTermList"><set field="invoice.settlementTermId" from="agreementAndTermList[0].settlementTermId"/></if>

                <!-- if this is a receivable (outgoing) invoice see if there is one on PartyAcctgPreference -->
                <if condition="!invoice.settlementTermId &amp;&amp; isFromPartyOrgInternal">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:invoice.fromPartyId]"/>
                    <set field="invoice.settlementTermId" from="partyAcctgPreference?.settlementTermId"/>
                </if>
            </if>
            <if condition="invoiceDate != null &amp;&amp; invoice.settlementTermId">
                <entity-find-one entity-name="mantle.account.invoice.SettlementTerm" value-field="settlementTerm">
                    <field-map field-name="settlementTermId" from="invoice.settlementTermId"/></entity-find-one>
                <script><![CDATA[
                    def dueDateDt = java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(invoiceDate.time), java.time.ZoneId.systemDefault())

                    switch (settlementTerm.termTypeEnumId) {
                        case 'TtFinPaymentDayNextMonth':
                            dueDateDt = dueDateDt.plusMonths(1)
                            // fall through intentionally
                        case 'TtFinPaymentDayCurMonth':
                            int dayOfMonth = settlementTerm.termValue as long ?: 1
                            int maxDays = dueDateDt.range(java.time.temporal.ChronoField.DAY_OF_MONTH).getMaximum()
                            if (dayOfMonth > maxDays) dayOfMonth = maxDays
                            dueDateDt = dueDateDt.withDayOfMonth(dayOfMonth)
                            break
                        default:
                            dueDateDt = dueDateDt.plusDays((settlementTerm.termValue as long) ?: 0)
                    }
                    dueDate = java.sql.Timestamp.from(dueDateDt.toInstant())
                    // could happen for TtFinPaymentDayCurMonth with a day less than today
                    if (dueDate < invoiceDate) {
                        dueDateDt = dueDateDt.plusMonths(1)
                        dueDate = java.sql.Timestamp.from(dueDateDt.toInstant())
                    }

                    if (origDueDate == null || origDueDate != dueDate) {
                        invoice.dueDate = dueDate
                        invoice.update()
                    }
                ]]></script>
            </if>
        </actions>
    </service>

    <service verb="create" noun="InvoiceItem">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <auto-parameters entity-name="mantle.account.invoice.InvoiceItem" include="nonpk">
                <exclude field-name="invoiceItemSeqId"/><exclude field-name="isAdjustment"/></auto-parameters>
        </in-parameters>
        <out-parameters><parameter name="invoiceItemSeqId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <if condition="!(invoice.statusId in ['InvoiceInProcess', 'InvoiceIncoming', 'InvoiceReceived'])">
                <return error="true" message="Invoice ${invoiceId} is not in a status that allows change (In Process for receivables, Incoming or Received for payables)"/></if>

            <service-call name="create#mantle.account.invoice.InvoiceItem" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="InvoiceItem">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
            <auto-parameters entity-name="mantle.account.invoice.InvoiceItem" include="nonpk">
                <exclude field-name="isAdjustment"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <entity-find-one entity-name="mantle.account.invoice.InvoiceItem" value-field="invoiceItem"/>
            <if condition="invoiceItem == null">
                <return error="true" message="Could not find Invoice Item with ID ${invoiceId}:${invoiceItemSeqId}"/></if>

            <!-- if is an adjustment or Invoice.statusId outside of certain values call other services with different
                constraints (rather than just returning an error) -->
            <if condition="invoiceItem.isAdjustment == 'Y'"><then>
                <service-call name="mantle.account.InvoiceServices.update#InvoiceItemAdjustment" in-map="context" out-map="context"/>
            </then><else-if condition="invoice.statusId in ['InvoiceInProcess', 'InvoiceIncoming', 'InvoiceReceived']">
                <service-call name="update#mantle.account.invoice.InvoiceItem" in-map="context" out-map="context"/>
            </else-if><else>
                <service-call name="mantle.account.InvoiceServices.update#InvoiceItemClosed" in-map="context" out-map="context"/>
            </else></if>
        </actions>
    </service>
    <service verb="update" noun="InvoiceItemClosed">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
            <parameter name="description"/>
            <parameter name="otherPartyProductId"/>
            <parameter name="itemDate" type="Timestamp"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <service-call name="update#mantle.account.invoice.InvoiceItem" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="InvoiceItemAdjustment">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
            <auto-parameters entity-name="mantle.account.invoice.InvoiceItem" include="nonpk">
                <exclude field-name="isAdjustment"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.InvoiceItem" value-field="invoiceItem"/>
            <if condition="invoiceItem == null">
                <return error="true" message="Could not find Invoice Item with ID ${invoiceId}:${invoiceItemSeqId}"/></if>
            <if condition="invoiceItem.isAdjustment != 'Y'">
                <return error="true" message="Invoice Item with ID ${invoiceId}:${invoiceItemSeqId} is not an Adjustment item"/></if>

            <!-- make sure doesn't make unpaid total negative -->
            <if condition="(amount != null &amp;&amp; amount != invoiceItem.amount) || (quantity != null &amp;&amp; quantity != invoiceItem.quantity)">
                <set field="origTotal" from="(invoiceItem.amount ?: 0.0) * (invoiceItem.quantity ?: 1.0)"/>
                <set field="newTotal" from="(amount != null ? amount : (invoiceItem.amount ?: 0.0)) * (quantity != null ? quantity : (invoiceItem.quantity ?: 1.0))"/>
                <set field="amountDiff" from="newTotal - origTotal"/>
                <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoiceId]" out-map="totalOut"/>
                <if condition="totalOut.unpaidTotal + amountDiff &lt; 0.0">
                    <return error="true" message="Adjustment item ${invoiceId}:${invoiceItemSeqId} amount difference of ${amountDiff} would make Unpaid Total less than zero"/></if>
            </if>

            <set field="isAdjustment" value="Y"/>
            <service-call name="update#mantle.account.invoice.InvoiceItem" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="InvoiceItem">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <if condition="!(invoice.statusId in ['InvoiceInProcess', 'InvoiceIncoming', 'InvoiceReceived'])">
                <return error="true" message="Invoice ${invoiceId} is not in a status that allows change"/></if>
            <service-call name="delete#mantle.account.invoice.InvoiceItem" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="adjust" noun="Invoice">
        <description>
            Adjust closed invoices (receivable: Finalized, Sent; payable: Approved) for charges or discounts
            after the invoice has been posted to the GL but before payment is finalized. SECA rule posts an accounting
            transaction for the change as the invoice is already posted.

            Relevant item types include: Write-off, Prompt Payment Discount, Late Payment Charge, Return (before paid)
        </description>
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="description"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <parameter name="quantity" type="BigDecimal" default="1"/>

            <parameter name="parentInvoiceItemSeqId">
                <description>Optional, associate adjustment item with a another invoice item.</description></parameter>
            <parameter name="productId"><description>Optional, for adjustments associated with a product.</description></parameter>
            <parameter name="itemDate" type="Timestamp"/>
            <parameter name="itemTypeEnumId" default-value="ItemInvAdjust"><description>Should be an item type that is a
                child of ItemInvAdjust (ItemWriteOff, ItemPromptDiscount, ItemLateCharge, ItemReturnAdjust)</description></parameter>
            <parameter name="overrideGlAccountId"/>
        </in-parameters>
        <out-parameters><parameter name="invoiceItemSeqId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <if condition="!(invoice.statusId in ['InvoiceFinalized', 'InvoiceSent', 'InvoiceAcked', 'InvoiceApproved'])">
                <return error="true" message="Invoices may only be adjusted in the Finalized, Sent, or Acknowledged statuses for receivables, and the Approved status for payables; invoice ${invoiceId} is in status ${invoice.status?.description}"/></if>

            <if condition="itemDate == null"><set field="itemDate" from="invoice.invoiceDate"/></if>
            <set field="adjustTotal" from="(amount ?: 0) * quantity"/>

            <!-- if adjustment is negative, have enough unpaid for it? -->
            <if condition="adjustTotal &lt; 0">
                <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoiceId]" out-map="invTotal"/>
                <if condition="(-adjustTotal) > invTotal.unpaidTotal">
                    <return error="true" message="Cannot adjust invoice ${invoiceId}, adjustment total ${adjustTotal} is greater than unpaid total ${invTotal.unpaidTotal}"/></if>
            </if>

            <!-- create the InvoiceItem -->
            <if condition="parentInvoiceItemSeqId"><set field="parentInvoiceId" from="invoiceId"/></if>
            <set field="isAdjustment" value="Y"/>
            <service-call name="create#mantle.account.invoice.InvoiceItem" in-map="context" out-map="context"/>

            <!-- NOTE: Invoice Adjustment GL posting done by SECA rule -->
        </actions>
    </service>

    <service verb="create" noun="EntireOrderPartInvoice">
        <!-- Invoice based on OrderPart (for non-shipping orders or orders invoiced before shipping) -->
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="statusId"><description>If specified after create set to this statusId (always created
                initially in InvoiceInProcess or InvoiceIncoming, so there must be a transition to specified status).</description></parameter>
            <parameter name="invoiceDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="partialOrderItemList" type="List"><description>If specified used instead of all items in
                the OrderPart. Must be a list of OrderItem EntityValue objects in the OrderPart.</description>
                <parameter name="orderItem" type="Map"><auto-parameters entity-name="mantle.order.OrderItem" include="all"/></parameter>
            </parameter>
        </in-parameters>
        <out-parameters><parameter name="invoiceId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>

            <set field="toPartyId" from="orderPart.customerPartyId"/>
            <entity-find entity-name="mantle.order.OrderPartParty" list="billToList">
                <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                <econdition field-name="roleTypeId" value="CustomerBillTo"/>
            </entity-find>
            <if condition="billToList"><set field="toPartyId" from="billToList[0].partyId"/></if>

            <set field="description" value="Invoice for Order ${orderId} part ${orderPartSeqId}"/>
            <service-call name="mantle.account.InvoiceServices.create#Invoice" out-map="context"
                    in-map="[invoiceTypeEnumId:'InvoiceSales', fromPartyId:orderPart.vendorPartyId, toPartyId:toPartyId,
                        invoiceDate:invoiceDate, currencyUomId:orderHeader.currencyUomId, otherPartyOrderId:orderPart.otherPartyOrderId,
                        description:description, productStoreId:orderHeader.productStoreId, systemMessageRemoteId:orderHeader.systemMessageRemoteId]"/>

            <if condition="partialOrderItemList"><then>
                <set field="orderItemList" from="partialOrderItemList"/>
            </then><else>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                    <order-by field-name="orderItemSeqId"/></entity-find>
            </else></if>

            <iterate list="orderItemList" entry="orderItem">
                <set field="oibBaseMap" from="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId]"/>
                <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                    <econdition-object field="oibBaseMap"/></entity-find>
                <set field="quantityNotBilled" from="(orderItem.quantity != null ? orderItem.quantity : 1.0) * (orderItem.selectedAmount ?: 1.0)"/>
                <iterate list="orderItemBillingList" entry="orderItemBilling">
                    <set field="quantityNotBilled" from="quantityNotBilled - orderItemBilling.quantity"/></iterate>
                <if condition="quantityNotBilled &gt; 0">
                    <!-- create InvoiceItem -->
                    <!-- is prorate by quantity needed? -->
                    <service-call name="create#mantle.account.invoice.InvoiceItem"
                            in-map="[invoiceId:invoiceId, invoiceItemSeqId:orderItem.orderItemSeqId,
                                parentItemSeqId:orderItem.parentItemSeqId, itemTypeEnumId:orderItem.itemTypeEnumId ?: 'ItemSales',
                                amount:orderItem.unitAmount, description:orderItem.itemDescription, quantity:quantityNotBilled,
                                quantityUomId:orderItem.quantityUomId, otherPartyProductId:orderItem.otherPartyProductId,
                                productId:orderItem.productId,
                                finAccountId:orderItem.finAccountId, finAccountTransId:orderItem.finAccountTransId]"/>

                    <!-- for ShipmentItemSource set the invoiceId/invoiceItemSeqId on it -->
                    <set field="quantityNotShipSourced" from="quantityNotBilled"/>
                    <set field="curShipmentId" from="null"/>
                    <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                        <econdition field-name="orderId"/><econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                    </entity-find>
                    <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                        <if condition="!shipmentItemSource.invoiceId &amp;&amp; quantityNotShipSourced >= shipmentItemSource.quantity">
                            <set field="shipmentItemSource.invoiceId" from="invoiceId"/>
                            <set field="shipmentItemSource.invoiceItemSeqId" from="orderItem.orderItemSeqId"/>
                            <entity-update value-field="shipmentItemSource"/>
                            <set field="quantityNotShipSourced" from="quantityNotShipSourced - shipmentItemSource.quantity"/>
                            <set field="curShipmentId" from="shipmentItemSource.shipmentId"/>
                        </if>
                    </iterate>
                    <!-- if quantityNotShipSourced > 0 do anything here? we don't have another Shipment/Item with quantity to match... -->

                    <!-- now create OrderItemBilling with shipmentId if available -->
                    <service-call name="create#mantle.order.OrderItemBilling"
                            in-map="oibBaseMap + [invoiceId:invoiceId, invoiceItemSeqId:orderItem.orderItemSeqId,
                                amount:orderItem.unitAmount, quantity:quantityNotBilled, shipmentId:curShipmentId]"/>
                </if>
            </iterate>

            <!-- set Payment.forInvoiceId on order part payments, if not already set -->
            <set field="partPayments" from="orderPart.payments"/>
            <iterate list="partPayments" entry="partPayment">
                <if condition="!partPayment.forInvoiceId">
                    <set field="partPayment.forInvoiceId" from="invoiceId"/>
                    <entity-update value-field="partPayment"/>
                </if>
            </iterate>

            <!-- update Invoice status to statusId passed in -->
            <if condition="statusId"><service-call name="update#mantle.account.invoice.Invoice"
                    in-map="[invoiceId:invoiceId, statusId:statusId]"/></if>

            <!-- try to apply order payments to new invoices -->
            <service-call name="mantle.account.PaymentServices.apply#OrderPaymentsToInvoice"
                    in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, invoiceId:invoiceId]"/>
        </actions>
    </service>

    <!-- Invoices based on Shipment -->
    <service verb="create" noun="SalesShipmentInvoices">
        <!-- transaction=cache note: called by SECA and combined with other service that don't support tx cache so can't -->
        <in-parameters>
            <parameter name="shipmentId" required="true"/>
            <parameter name="statusId"><description>If specified after create set to this statusId (always created
                initially in InvoiceInProcess, so there must be a transition to specified status).</description></parameter>
            <parameter name="invoiceDate" type="Timestamp"><description>Defaults to Shipment packedDate or now.</description></parameter>

            <!-- for reuse for purchase orders, represent the differences between sales and purchase order shipments -->
            <parameter name="handleIssuances" type="Boolean" default="true"/>
            <parameter name="applyPayments" type="Boolean" default="true"/>
            <parameter name="handleReceipts" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="invoiceIdByOrderPartIdMap" type="Map"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
            <if condition="shipment == null"><return error="true" message="Shipment not found with ID ${shipmentId}"/></if>

            <set field="invoiceIdByOrderPartIdMap" from="[:]"/>
            <set field="invoiceDate" from="invoiceDate ?: shipment.packedDate ?: ec.user.nowTimestamp"/>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>

            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList" for-update="true">
                <econdition field-name="shipmentId"/>
                <econdition field-name="orderId" operator="not-equals" from="null"/><!-- only include item sources from orders -->
                <!-- NOTE: Derby blows up with for-update and order-by: <order-by field-name="orderId"/><order-by field-name="orderItemSeqId"/> -->
            </entity-find>
            <order-map-list list="shipmentItemSourceList"><order-by field-name="orderId"/><order-by field-name="orderItemSeqId"/></order-map-list>

            <set field="orderHeaderMap" from="[:]"/>
            <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                <set field="orderItem" from="shipmentItemSource.'mantle.order.OrderItem'"/>
                <if condition="orderItem == null"><continue/></if>
                <set field="orderItemQty" from="(orderItem.quantity != null ? orderItem.quantity : 1.0) * (orderItem.selectedAmount ?: 1.0)"/>
                <!-- invoice even if unitAmount is zero, otherwise no record of sales for inventory/etc purposes (sales invoice analysis)
                <set field="itemAmount" from="(orderItem.unitAmount ?: 0) * (orderItemQty)"/>
                <if condition="itemAmount == 0"><continue/></if>
                -->

                <!-- look for existing OrderItemBilling quantity: quantity already billed minus quantity on order shipments -->
                <!-- bill only quantity not already billed -->
                <set field="billingList" from="orderItem.billings"/>
                <set field="billedQuantity" from="billingList*.quantity.sum()"/>
                <set field="allItemSources" from="orderItem.shipmentSources"/>
                <set field="allShippedQuantity" from="allItemSources*.quantity.sum()"/>
                <!-- get shippedNotBilled from this OrderItem's quantity on all shipments, including this one, minus billedQuantity -->
                <!-- only bill up to the quantity on this shipment -->
                <set field="shippedNotBilled" from="(allShippedQuantity ?: 0.0) - (billedQuantity ?: 0.0)"/>
                <set field="quantityToBill" from="shipmentItemSource.quantity &gt; shippedNotBilled ? shippedNotBilled : shipmentItemSource.quantity"/>
                <if condition="quantityToBill == 0.0"><continue/></if>

                <set field="orderHeader" from="orderHeaderMap.get(shipmentItemSource.orderId)"/>
                <if condition="orderHeader == null">
                    <set field="orderHeader" from="shipmentItemSource.'mantle.order.OrderHeader'"/>
                    <script>orderHeaderMap.put(shipmentItemSource.orderId, orderHeader)</script>
                </if>
                <set field="invoiceId" from="invoiceIdByOrderPartIdMap.get(orderItem.orderId + ':' + orderItem.orderPartSeqId)"/>

                <if condition="!invoiceId">
                    <!-- find the OrderPart for the from/toPartyId, etc -->
                    <set field="orderPart" from="orderItem.'mantle.order.OrderPart'"/>
                    <if condition="orderPart">
                        <set field="toPartyId" from="orderPart.customerPartyId"/>
                        <entity-find entity-name="mantle.order.OrderPartParty" list="billToList">
                            <econdition field-name="orderId" from="orderPart.orderId"/>
                            <econdition field-name="orderPartSeqId" from="orderPart.orderPartSeqId"/>
                            <econdition field-name="roleTypeId" value="CustomerBillTo"/>
                        </entity-find>
                        <if condition="billToList"><set field="toPartyId" from="billToList[0].partyId"/></if>

                        <set field="description" value="For Order ${orderItem.orderId} part ${orderItem.orderPartSeqId} and Shipment ${shipmentId}"/>
                        <service-call name="mantle.account.InvoiceServices.create#Invoice" out-map="invOut"
                                in-map="[invoiceTypeEnumId:'InvoiceSales', fromPartyId:orderPart.vendorPartyId, toPartyId:toPartyId,
                                    invoiceDate:invoiceDate, currencyUomId:orderHeader.currencyUomId, otherPartyOrderId:orderPart.otherPartyOrderId,
                                    description:description, productStoreId:orderHeader.productStoreId, systemMessageRemoteId:orderHeader.systemMessageRemoteId]"/>
                        <set field="invoiceId" from="invOut.invoiceId"/>
                        <script>invoiceIdByOrderPartIdMap.put(orderItem.orderId + ':' + orderItem.orderPartSeqId, invoiceId)</script>

                        <!-- set Payment.forInvoiceId on order part payments, if not already set -->
                        <set field="partPayments" from="orderPart.payments"/>
                        <iterate list="partPayments" entry="partPayment">
                            <!-- only set forInvoiceId if not set, payment not Cancelled/etc, and parties match -->
                            <if condition="partPayment.forInvoiceId || partPayment.statusId in ['PmntCancelled', 'PmntVoid', 'PmntDeclined'] ||
                                    partPayment.fromPartyId != toPartyId || partPayment.toPartyId != orderPart.vendorPartyId"><continue/></if>
                            <set field="partPayment.forInvoiceId" from="invoiceId"/>
                            <entity-update value-field="partPayment"/>
                        </iterate>
                    </if>
                </if>

                <if condition="invoiceId">
                    <!-- create InvoiceItem, OrderItemBilling, set invoiceId,invoiceItemSeqId -->
                    <set field="parentInvoiceItemSeqId" from="null"/>
                    <set field="quantityNotBilled" from="quantityToBill"/>

                    <!-- first do AssetIssuance -->
                    <if condition="handleIssuances">
                        <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="assetIssuanceList" for-update="true">
                            <econdition field-name="orderId" from="orderItem.orderId"/>
                            <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                            <econdition field-name="shipmentId"/>
                            <order-by field-name="orderItemSeqId"/>
                        </entity-find>
                        <iterate list="assetIssuanceList" entry="assetIssuance">
                            <set field="issuanceQuantityToBill" from="quantityNotBilled &gt; assetIssuance.quantity ?
                                    assetIssuance.quantity : quantityNotBilled"/>
                            <if condition="issuanceQuantityToBill &lt;= 0.0"><continue/></if>
                            <!-- should we make sure the total quantity on all AssetIssuance records matches the
                                quantity on the ShipmentItemSource record? that should be handled when they are created... -->
                            <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="iiOut"
                                    in-map="[invoiceId:invoiceId, itemTypeEnumId:orderItem.itemTypeEnumId ?: 'ItemProduct',
                                        amount:orderItem.unitAmount, description:orderItem.itemDescription,
                                        quantity:issuanceQuantityToBill, assetId:assetIssuance.assetId,
                                        quantityUomId:orderItem.quantityUomId, productId:orderItem.productId,
                                        otherPartyProductId:orderItem.otherPartyProductId,
                                        finAccountId:orderItem.finAccountId, finAccountTransId:orderItem.finAccountTransId]"/>
                            <if condition="!parentInvoiceItemSeqId"><set field="parentInvoiceItemSeqId" from="iiOut.invoiceItemSeqId"/></if>
                            <service-call name="create#mantle.order.OrderItemBilling"
                                    in-map="[orderId:orderItem.orderId, orderItemSeqId:orderItem.orderItemSeqId,
                                        invoiceId:invoiceId, invoiceItemSeqId:iiOut.invoiceItemSeqId,
                                        assetIssuanceId:assetIssuance.assetIssuanceId, shipmentId:shipmentId,
                                        amount:orderItem.unitAmount, quantity:issuanceQuantityToBill]"/>

                            <!-- set invoiceId and invoiceItemSeqId on AssetIssuance -->
                            <set field="assetIssuance.invoiceId" from="invoiceId"/>
                            <set field="assetIssuance.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                            <entity-update value-field="assetIssuance"/>
                            <!-- if invoiceDate not on same day (in Java default time zone) as issuedDate items were packed/issued
                                and then shipment packed much later so set issuedDate to invoiceDate so that COGS/etc are on same
                                day as receivable invoice -->
                            <if condition="invoiceDate.toString().substring(0, 10) != assetIssuance.issuedDate.toString().substring(0, 10)">
                                <log message="AssetIssuance ${assetIssuance.assetIssuanceId} issuedDate ${assetIssuance.issuedDate.toString().substring(0, 10)} on different day from invoiceDate ${invoiceDate.toString().substring(0, 10)}, updating to invoiceDate"/>
                                <service-call name="mantle.product.AssetServices.update#AssetIssuedDate"
                                        in-map="[assetIssuanceId:assetIssuance.assetIssuanceId, issuedDate:invoiceDate]"/>
                            </if>

                            <!-- update ShipmentItemSource -->
                            <if condition="shipmentItemSource.invoiceItemSeqId"><then>
                                <!-- TODO: SIS split causes issues with AssetIssuance.shipmentItemSourceId reference, quantities no longer line up; also split corresponding AssetIssuance records? -->
                                <!-- will have to split the ShipmentItemSource -->
                                <set field="newShipmentItemSource" from="shipmentItemSource.cloneValue()"/>
                                <set field="newShipmentItemSource.shipmentItemSourceId" from="null"/>
                                <entity-sequenced-id-primary value-field="newShipmentItemSource"/>
                                <set field="newShipmentItemSource.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                                <set field="newShipmentItemSource.quantity" from="issuanceQuantityToBill"/>
                                <entity-create value-field="newShipmentItemSource"/>

                                <set field="shipmentItemSource.quantity" from="shipmentItemSource.quantity - issuanceQuantityToBill"/>
                                <entity-update value-field="shipmentItemSource"/>
                            </then><else>
                                <set field="shipmentItemSource.invoiceId" from="invoiceId"/>
                                <set field="shipmentItemSource.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                                <entity-update value-field="shipmentItemSource"/>
                            </else></if>

                            <set field="quantityNotBilled" from="quantityNotBilled - issuanceQuantityToBill"/>
                        </iterate>
                    </if>

                    <!-- now do AssetReceipt; this service is reused for purchase orders by a wrapping service, in
                        spite of the name handle these too -->
                    <if condition="handleReceipts">
                        <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="assetReceiptList" for-update="true">
                            <econdition-object field="[orderId:orderItem.orderId, orderItemSeqId:orderItem.orderItemSeqId, shipmentId:shipmentId]"/>
                            <order-by field-name="orderItemSeqId"/>
                        </entity-find>
                        <iterate list="assetReceiptList" entry="assetReceipt">
                            <set field="receiptQuantityToBill" from="quantityNotBilled &gt; assetReceipt.quantityAccepted ?
                                    assetReceipt.quantityAccepted : quantityNotBilled"/>
                            <if condition="receiptQuantityToBill &lt;= 0.0"><continue/></if>
                            <!-- should we make sure the total quantity on all AssetReceipt records matches the
                                quantity on the ShipmentItemSource record? that should be handled when they are created... -->
                            <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="iiOut"
                                    in-map="[invoiceId:invoiceId, itemTypeEnumId:orderItem.itemTypeEnumId ?: 'ItemInventory',
                                        amount:orderItem.unitAmount, description:orderItem.itemDescription,
                                        quantity:receiptQuantityToBill, assetId:assetReceipt.assetId,
                                        quantityUomId:orderItem.quantityUomId, productId:orderItem.productId,
                                        otherPartyProductId:orderItem.otherPartyProductId,
                                        finAccountId:orderItem.finAccountId, finAccountTransId:orderItem.finAccountTransId]"/>
                            <if condition="!parentInvoiceItemSeqId"><set field="parentInvoiceItemSeqId" from="iiOut.invoiceItemSeqId"/></if>
                            <service-call name="create#mantle.order.OrderItemBilling"
                                    in-map="[orderId:orderItem.orderId, orderItemSeqId:orderItem.orderItemSeqId,
                                        invoiceId:invoiceId, invoiceItemSeqId:iiOut.invoiceItemSeqId,
                                        assetReceiptId:assetReceipt.assetReceiptId, shipmentId:shipmentId,
                                        amount:orderItem.unitAmount, quantity:receiptQuantityToBill]"/>
                            <!-- set invoiceId and invoiceItemSeqId on AssetReceipt -->
                            <set field="assetReceipt.invoiceId" from="invoiceId"/>
                            <set field="assetReceipt.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                            <entity-update value-field="assetReceipt"/>
                            <!-- update ShipmentItemSource -->
                            <if condition="shipmentItemSource.invoiceItemSeqId"><then>
                                <!-- will have to split the ShipmentItemSource -->
                                <set field="newShipmentItemSource" from="shipmentItemSource.cloneValue()"/>
                                <set field="newShipmentItemSource.shipmentItemSourceId" from="null"/>
                                <entity-sequenced-id-primary value-field="newShipmentItemSource"/>
                                <set field="newShipmentItemSource.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                                <set field="newShipmentItemSource.quantity" from="receiptQuantityToBill"/>
                                <entity-create value-field="newShipmentItemSource"/>

                                <set field="shipmentItemSource.quantity" from="shipmentItemSource.quantity - receiptQuantityToBill"/>
                                <entity-update value-field="shipmentItemSource"/>
                            </then><else>
                                <set field="shipmentItemSource.invoiceId" from="invoiceId"/>
                                <set field="shipmentItemSource.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                                <entity-update value-field="shipmentItemSource"/>
                            </else></if>

                            <set field="quantityNotBilled" from="quantityNotBilled - receiptQuantityToBill"/>
                        </iterate>
                    </if>

                    <!-- there should not be any quantity left over after issuance/receipt records, but just make sure -->
                    <if condition="quantityNotBilled &gt; 0">
                        <!-- NOTE: in this case we don't have an assetId -->
                        <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="mainIiOut" out-map-add-to-existing="false"
                                in-map="[invoiceId:invoiceId, itemTypeEnumId:orderItem.itemTypeEnumId ?: 'ItemProduct',
                                    amount:orderItem.unitAmount, description:orderItem.itemDescription,
                                    quantity:quantityNotBilled, quantityUomId:orderItem.quantityUomId,
                                    productId:orderItem.productId, otherPartyProductId:orderItem.otherPartyProductId,
                                    finAccountId:orderItem.finAccountId, finAccountTransId:orderItem.finAccountTransId]"/>
                        <if condition="!parentInvoiceItemSeqId"><set field="parentInvoiceItemSeqId" from="mainIiOut.invoiceItemSeqId"/></if>
                        <!-- update ShipmentItemSource -->
                        <if condition="shipmentItemSource.invoiceItemSeqId"><then>
                            <!-- will have to split the ShipmentItemSource -->
                            <set field="newShipmentItemSource" from="shipmentItemSource.cloneValue()"/>
                            <set field="newShipmentItemSource.shipmentItemSourceId" from="null"/>
                            <entity-sequenced-id-primary value-field="newShipmentItemSource"/>
                            <set field="newShipmentItemSource.invoiceItemSeqId" from="mainIiOut.invoiceItemSeqId"/>
                            <set field="newShipmentItemSource.quantity" from="quantityNotBilled"/>
                            <entity-create value-field="newShipmentItemSource"/>

                            <set field="shipmentItemSource.quantity" from="shipmentItemSource.quantity - quantityNotBilled"/>
                            <entity-update value-field="shipmentItemSource"/>
                        </then><else>
                            <set field="shipmentItemSource.invoiceId" from="invoiceId"/>
                            <set field="shipmentItemSource.invoiceItemSeqId" from="mainIiOut.invoiceItemSeqId"/>
                            <entity-update value-field="shipmentItemSource"/>
                        </else></if>
                    </if>

                    <!-- also invoice child OrderItems (adjustments, etc) -->
                    <set field="childOrderItemList" from="orderItem.'Child#mantle.order.OrderItem'"/>
                    <order-map-list list="childOrderItemList"><order-by field-name="orderItemSeqId"/></order-map-list>
                    <iterate list="childOrderItemList" entry="childOrderItem">
                        <!-- only ship if not a product item, that should be shipped before invoiced -->
                        <if condition="childOrderItem.itemTypeEnumId in productItemTypes">
                            <log message="Not invoicing child item ${childOrderItemList.orderId}:${childOrderItemList.orderItemSeqId}, has product item type ${childOrderItem.itemTypeEnumId}"/>
                            <continue/>
                        </if>

                        <entity-find entity-name="mantle.order.OrderItemBillingTotal" list="childItemBillingList">
                            <econdition field-name="orderId" from="childOrderItem.orderId"/>
                            <econdition field-name="orderItemSeqId" from="childOrderItem.orderItemSeqId"/>
                            <select-field field-name="quantity,amount"/>
                        </entity-find>
                        <set field="childBilledQuantity" from="0.0"/>
                        <set field="childBilledTotal" from="0.0"/>
                        <iterate list="childItemBillingList" entry="childItemBilling">
                            <set field="childInvQuantity" from="childItemBilling.quantity != null ? childItemBilling.quantity : 1.0"/>
                            <set field="childBilledQuantity" from="childBilledQuantity + childInvQuantity"/>
                            <set field="childBilledTotal" from="childBilledTotal + (childInvQuantity * (childItemBilling.amount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                        </iterate>

                        <set field="childQty" from="(childOrderItem.quantity != null ? childOrderItem.quantity : 1.0) * (childOrderItem.selectedAmount ?: 1.0)"/>
                        <set field="childQuantityNotBilled" from="childQty - childBilledQuantity"/>
                        <set field="childTotal" from="(childQty * (childOrderItem.unitAmount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                        <set field="childTotalNotBilled" from="childTotal - childBilledTotal"/>

                        <!-- only need to if total not billed != 0.0 (total can be positive or negative because unitAmount can be negative) -->
                        <if condition="childTotalNotBilled != 0.0">
                            <!-- if child qty == parent qty then handle by quantity, otherwise prorate by total -->
                            <set field="childQtyToBill" from="0.0"/>
                            <set field="childAmountToBill" from="0.0"/>
                            <if condition="childQty == orderItemQty"><then>
                                <set field="childQtyToBill" from="quantityToBill"/>
                                <set field="childAmountToBill" from="childOrderItem.unitAmount"/>
                            </then><else>
                                <set field="childQtyToBill" from="1.0"/>
                                <!-- if full order item qty now shipped (last shipment) use childTotalNotBilled, otherwise prorate based on childTotal -->
                                <if condition="allShippedQuantity &gt;= orderItemQty"><then>
                                    <set field="childAmountToBill" from="childTotalNotBilled"/>
                                </then><else>
                                    <set field="parentRatio" from="(quantityToBill as BigDecimal).divide(orderItemQty as BigDecimal, 6, BigDecimal.ROUND_HALF_EVEN)"/>
                                    <set field="childAmountToBill" from="(childTotal * parentRatio).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                                </else></if>
                            </else></if>

                            <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="childIiOut"
                                    in-map="[invoiceId:invoiceId, itemTypeEnumId:(childOrderItem.itemTypeEnumId ?: 'ItemSales'),
                                        parentItemSeqId:parentInvoiceItemSeqId, amount:childAmountToBill,
                                        productId:(childOrderItem.productId ?: orderItem.productId),
                                        description:childOrderItem.itemDescription, quantity:childQtyToBill,
                                        quantityUomId:childOrderItem.quantityUomId]"/>
                            <service-call name="create#mantle.order.OrderItemBilling"
                                    in-map="[orderId:childOrderItem.orderId, orderItemSeqId:childOrderItem.orderItemSeqId,
                                        invoiceId:invoiceId, invoiceItemSeqId:childIiOut.invoiceItemSeqId,
                                        shipmentId:shipmentId, amount:childAmountToBill, quantity:childQtyToBill]"/>
                        </if>
                    </iterate>
                </if>
            </iterate>

            <!-- for each order invoice uninvoiced, non-Product OrderItems such as shipping charges, etc... -->
            <!-- do all on first invoice (all unbilled on each shipment for each order)... in the future consider prorating by total on this shipment versus order total -->
            <iterate list="invoiceIdByOrderPartIdMap.entrySet()" entry="invoiceIdByOrderIdEntry">
                <set field="orderAndPartId" from="invoiceIdByOrderIdEntry.key"/>
                <set field="orderId" from="orderAndPartId.substring(0, orderAndPartId.indexOf(':'))"/>
                <set field="orderPartSeqId" from="orderAndPartId.substring(orderAndPartId.indexOf(':') + 1)"/>
                <set field="invoiceId" from="invoiceIdByOrderIdEntry.value"/>
                <set field="orderHeader" from="orderHeaderMap.get(orderId)"/>
                <if condition="orderHeader == null">
                    <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
                    <script>orderHeaderMap.put(orderId, orderHeader)</script>
                </if>
                <entity-find entity-name="mantle.order.OrderItem" list="otherOrderItemList">
                    <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                    <econdition field-name="itemTypeEnumId" operator="not-in" from="productItemTypes"/>
                    <!-- don't include items with a parent, should be handled along with the parent item -->
                    <econdition field-name="parentItemSeqId" from="null"/>
                </entity-find>
                <iterate list="otherOrderItemList" entry="otherOrderItem">
                    <set field="parentInvoiceItemSeqId" from="null"/>
                    <set field="otherItemQty" from="(otherOrderItem.quantity != null ? otherOrderItem.quantity : 1.0) * (otherOrderItem.selectedAmount ?: 1.0)"/>
                    <set field="otherItemTotal" from="(otherItemQty * (otherOrderItem.unitAmount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>

                    <!-- TODO: handle partial quantity billed, bill remaining qty or rather otherTotalToBill needs to be calculated -->
                    <set field="otherTotalToBill" from="otherItemTotal"/>
                    <entity-find entity-name="mantle.order.OrderItemBilling" list="otherItemBillingList">
                        <econdition field-name="orderId" from="otherOrderItem.orderId"/>
                        <econdition field-name="orderItemSeqId" from="otherOrderItem.orderItemSeqId"/>
                        <econdition field-name="quantity" operator="not-equals" from="0.0"/>
                    </entity-find>
                    <if condition="!otherItemBillingList">
                        <set field="otherItemQty" from="(otherOrderItem.quantity != null ? otherOrderItem.quantity : 1.0) * (otherOrderItem.selectedAmount ?: 1.0)"/>
                        <!-- TODO is prorate by quantity needed? for example pro-rate order level shipping for partial shipment -->
                        <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="iiOut"
                                in-map="[invoiceId:invoiceId, itemTypeEnumId:otherOrderItem.itemTypeEnumId ?: 'ItemSales',
                                    productId:otherOrderItem.productId,
                                    amount:otherOrderItem.unitAmount, description:otherOrderItem.itemDescription,
                                    quantity:otherItemQty, quantityUomId:otherOrderItem.quantityUomId]"/>
                        <set field="parentInvoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                        <service-call name="create#mantle.order.OrderItemBilling"
                                in-map="[orderId:otherOrderItem.orderId, orderItemSeqId:otherOrderItem.orderItemSeqId,
                                    invoiceId:invoiceId, invoiceItemSeqId:iiOut.invoiceItemSeqId,
                                    shipmentId:shipmentId, amount:otherOrderItem.unitAmount, quantity:otherItemQty]"/>
                    </if>

                    <!-- also invoice child OrderItems (adjustments, taxes, etc) -->
                    <set field="childOrderItemList" from="otherOrderItem.'Child#mantle.order.OrderItem'"/>
                    <order-map-list list="childOrderItemList"><order-by field-name="orderItemSeqId"/></order-map-list>
                    <iterate list="childOrderItemList" entry="childOrderItem">
                        <!-- only ship if not a product item, that should be shipped before invoiced -->
                        <if condition="childOrderItem.itemTypeEnumId in productItemTypes">
                            <log message="Not invoicing child item ${childOrderItemList.orderId}:${childOrderItemList.orderItemSeqId}, has product item type ${childOrderItem.itemTypeEnumId}"/>
                            <continue/>
                        </if>

                        <entity-find entity-name="mantle.order.OrderItemBillingTotal" list="childItemBillingList">
                            <econdition field-name="orderId" from="childOrderItem.orderId"/>
                            <econdition field-name="orderItemSeqId" from="childOrderItem.orderItemSeqId"/>
                            <select-field field-name="quantity,amount"/>
                        </entity-find>
                        <set field="childBilledQuantity" from="0.0"/>
                        <set field="childBilledTotal" from="0.0"/>
                        <iterate list="childItemBillingList" entry="childItemBilling">
                            <set field="childInvQuantity" from="childItemBilling.quantity != null ? childItemBilling.quantity : 1.0"/>
                            <set field="childBilledQuantity" from="childBilledQuantity + childInvQuantity"/>
                            <set field="childBilledTotal" from="childBilledTotal + (childInvQuantity * (childItemBilling.amount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                        </iterate>

                        <set field="childQty" from="(childOrderItem.quantity != null ? childOrderItem.quantity : 1.0) * (childOrderItem.selectedAmount ?: 1.0)"/>
                        <set field="childQuantityNotBilled" from="childQty - childBilledQuantity"/>
                        <set field="childTotal" from="(childQty * (childOrderItem.unitAmount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                        <set field="childTotalNotBilled" from="childTotal - childBilledTotal"/>

                        <!-- only need to if total not billed != 0.0 (total can be positive or negative because unitAmount can be negative) -->
                        <if condition="childTotalNotBilled != 0.0">
                            <!-- if child qty == parent qty then handle by quantity, otherwise prorate by total -->
                            <set field="childQtyToBill" from="0.0"/>
                            <set field="childAmountToBill" from="0.0"/>
                            <if condition="childQty == orderItemQty"><then>
                                <set field="childQtyToBill" from="quantityToBill"/>
                                <set field="childAmountToBill" from="childOrderItem.unitAmount"/>
                            </then><else>
                                <set field="childQtyToBill" from="1.0"/>
                                <!-- if full order item qty now shipped (last shipment) use childTotalNotBilled, otherwise prorate based on childTotal -->
                                <if condition="allShippedQuantity &gt;= orderItemQty"><then>
                                    <set field="childAmountToBill" from="childTotalNotBilled"/>
                                </then><else>
                                    <!-- NOTE: all of this is the same as the code section above for product type parent order items, except the parentRatio right here -->
                                    <set field="parentRatio" from="(otherTotalToBill as BigDecimal).divide(otherItemTotal as BigDecimal, 6, BigDecimal.ROUND_HALF_EVEN)"/>
                                    <set field="childAmountToBill" from="(childTotal * parentRatio).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                                </else></if>
                            </else></if>

                            <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="childIiOut"
                                    in-map="[invoiceId:invoiceId, itemTypeEnumId:(childOrderItem.itemTypeEnumId ?: 'ItemSales'),
                                        parentItemSeqId:parentInvoiceItemSeqId, amount:childAmountToBill,
                                        productId:(childOrderItem.productId ?: otherOrderItem.productId),
                                        description:childOrderItem.itemDescription, quantity:childQtyToBill,
                                        quantityUomId:childOrderItem.quantityUomId]"/>
                            <service-call name="create#mantle.order.OrderItemBilling"
                                    in-map="[orderId:childOrderItem.orderId, orderItemSeqId:childOrderItem.orderItemSeqId,
                                        invoiceId:invoiceId, invoiceItemSeqId:childIiOut.invoiceItemSeqId,
                                        shipmentId:shipmentId, amount:childAmountToBill, quantity:childQtyToBill]"/>
                        </if>
                    </iterate>
                </iterate>
            </iterate>

            <!-- set invoice status -->
            <if condition="statusId &amp;&amp; statusId != 'InvoiceInProcess'"><iterate list="invoiceIdByOrderPartIdMap.values()" entry="invoiceId">
                <service-call name="update#mantle.account.invoice.Invoice" in-map="[invoiceId:invoiceId, statusId:statusId]"/>
            </iterate></if>
            
            <!-- apply order payments to new invoices -->
            <if condition="applyPayments">
                <iterate list="invoiceIdByOrderPartIdMap.entrySet()" entry="invoiceIdByOrderIdEntry">
                    <set field="orderAndPartId" from="invoiceIdByOrderIdEntry.key"/>
                    <set field="orderId" from="orderAndPartId.substring(0, orderAndPartId.indexOf(':'))"/>
                    <set field="orderPartSeqId" from="orderAndPartId.substring(orderAndPartId.indexOf(':') + 1)"/>
                    <set field="invoiceId" from="invoiceIdByOrderIdEntry.value"/>
                    <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice">
                        <field-map field-name="invoiceId"/></entity-find-one>
                    <if condition="invoice.statusId == 'InvoiceInProcess'">
                        <service-call name="update#mantle.account.invoice.Invoice" in-map="[invoiceId:invoiceId, statusId:'InvoiceFinalized']"/>
                    </if>
                    <service-call name="mantle.account.PaymentServices.apply#OrderPaymentsToInvoice"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, invoiceId:invoiceId]"/>
                </iterate>
            </if>
        </actions>
    </service>
    <service verb="create" noun="PurchaseShipmentInvoices">
        <in-parameters>
            <parameter name="shipmentId" required="true"/>
            <parameter name="statusId"><description>If specified after create set to
                this statusId (always created initially in InvoiceInProcess, so there must be a transition to specified
                status).</description></parameter>
            <parameter name="invoiceDate" type="Timestamp"><description>Defaults to Shipment packedDate or now.</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="invoiceIdList" type="List"><parameter name="invoiceId"/></parameter></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
            <if condition="shipment == null"><return error="true" message="Shipment not found with ID ${shipmentId}"/></if>
            <set field="shipmentTypeEnum" from="shipment.'ShipmentType#moqui.basic.Enumeration'"/>
            <if condition="shipmentTypeEnum?.enumId == 'ShpTpIncoming' || shipmentTypeEnum?.parentEnumId == 'ShpTpIncoming'">
                <set field="handleIssuances" from="false"/>
                <set field="applyPayments" from="false"/>
                <set field="handleReceipts" from="true"/>
                <service-call name="mantle.account.InvoiceServices.create#SalesShipmentInvoices" in-map="context" out-map="context"/>
            </if>
        </actions>
    </service>

    <service verb="create" noun="ProjectExpenseInvoice">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.invoice.Invoice" include="nonpk"/>
            <parameter name="workEffortId"/>
            <parameter name="fromPartyId" required="true"/>
            <parameter name="toPartyId"/>
            <parameter name="invoiceTypeEnumId" default-value="InvoiceSales"/>
            <parameter name="invoiceDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="currencyUomId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="invoiceId"/>
        </out-parameters>
        <actions>
            <if condition="!workEffortId &amp;&amp; !toPartyId">
                <return error="true" message="Must specify either Project (workEffortId) or To Party (toPartyId)"/></if>

            <if condition="!toPartyId">
                <entity-find entity-name="mantle.work.effort.WorkEffortParty" list="vendorWepList">
                    <date-filter/><econdition field-name="workEffortId"/>
                    <econdition field-name="roleTypeId" operator="in" value="Vendor,VendorBillFrom"/></entity-find>
                <set field="vendorWep" from="vendorWepList?.first"/>
                <set field="toPartyId" from="vendorWep.partyId"/>
            </if>

            <service-call name="mantle.account.InvoiceServices.create#Invoice" in-map="context" out-map="context"/>

            <if condition="workEffortId">
                <service-call name="create#mantle.work.effort.WorkEffortInvoice" in-map="context" out-map="context"/></if>
        </actions>
    </service>

    <service verb="create" noun="ProjectInvoiceItems">
        <in-parameters>
            <parameter name="invoiceId"><description>If specified add item(s) to this Invoice. If empty an Invoice will be created.</description></parameter>
            <parameter name="workEffortId" required="true"/>
            <parameter name="thruDate" type="Timestamp" default="ec.user.nowTimestamp">
                <description>Only TimeEntry records before this date will be included. Defaults to now.</description></parameter>
            <parameter name="invoiceDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="currencyUomId"/>
            <parameter name="ratePurposeEnumId" default-value="RaprClient">
                <description>Invoice Project Client/Customer (RaprClient) or Vendor/Worker (RaprVendor)</description></parameter>
            <parameter name="workerPartyId"><description>If specified only include time entries and expenses from this Party.</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="invoiceId"/>
            <parameter name="invoiceItemCreatedCount" type="Long"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.work.effort.WorkEffort" value-field="workEffort"/>
            <entity-find entity-name="mantle.work.effort.WorkEffortParty" list="billToList">
                <date-filter/><econdition field-name="workEffortId"/>
                <econdition field-name="roleTypeId" operator="in" value="Customer,CustomerBillTo"/>
            </entity-find>
            <set field="billToWep" from="billToList ? billToList[0] : null"/>
            <entity-find entity-name="mantle.work.effort.WorkEffortParty" list="billFromList">
                <date-filter/><econdition field-name="workEffortId"/>
                <econdition field-name="roleTypeId" operator="in" value="Vendor,VendorBillFrom"/>
            </entity-find>
            <set field="billFromWep" from="billFromList ? billFromList[0] : null"/>
            <set field="vendorPartyId" from="billFromWep?.partyId"/>

            <if condition="workerPartyId">
                <entity-find-one entity-name="mantle.party.PartyDetail" value-field="workerParty">
                    <field-map field-name="partyId" from="workerPartyId"/></entity-find-one>
                <!-- is worker an employee? -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="employeeRelationshipList">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="workerPartyId"/>
                    <econdition field-name="toPartyId" from="vendorPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtEmployee"/>
                    <econdition field-name="fromRoleTypeId" value="Employee"/>
                </entity-find>
                <set field="isEmployee" from="employeeRelationshipList.size() &gt; 0"/>
            </if>

            <if condition="ratePurposeEnumId == 'RaprClient'"><then>
                <set field="invoiceTypeEnumId" value="InvoiceSales"/>
                <set field="itemTypeEnumId" value="ItemTimeEntry"/>
            </then><else>
                <set field="invoiceTypeEnumId" from="workerParty?.partyTypeEnumId == 'PtyPerson' ?
                            (isEmployee ? 'InvoicePayroll' : 'InvoicePayrollOther') : 'InvoiceSales'"/>
                <!-- NEW: use ItemHourlyEarnings for Employee Person vendor/worker invoices, ItemTimeEntry for client/customer invoices and all other vendor/worker invoices -->
                <set field="itemTypeEnumId" from="workerParty?.partyTypeEnumId == 'PtyPerson' &amp;&amp; isEmployee ? 'ItemHourlyEarnings' : 'ItemTimeEntry'"/>
            </else></if>

            <!-- create Invoice associated with WorkEffort, use WorkEffortParty to find from/to parties -->
            <if condition="!invoiceId">
                <if condition="!currencyUomId">
                    <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference">
                        <field-map field-name="organizationPartyId" from="ratePurposeEnumId == 'RaprClient' ? billToWep?.partyId : billFromWep?.partyId"/>
                    </entity-find-one>
                    <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId ?: 'USD'"/>
                </if>
                <set field="description" value="Invoice for${workEffort ? ' project ' + ec.resource.expand('WorkEffortNameTemplate','') : ''}${workerParty ? ' worker ' + ec.resource.expand('PartyNameTemplate','',workerParty) : ''}"/>
                <if condition="ratePurposeEnumId == 'RaprClient'"><then>
                    <service-call name="mantle.account.InvoiceServices.create#Invoice" out-map="context"
                            in-map="[invoiceTypeEnumId:invoiceTypeEnumId, fromPartyId:billFromWep?.partyId, toPartyId:billToWep?.partyId,
                                invoiceDate:invoiceDate, currencyUomId:currencyUomId, description:description]"/>
                </then><else>
                    <service-call name="mantle.account.InvoiceServices.create#Invoice" out-map="context"
                            in-map="[invoiceTypeEnumId:invoiceTypeEnumId, fromPartyId:workerPartyId, toPartyId:vendorPartyId,
                                invoiceDate:invoiceDate, currencyUomId:currencyUomId, description:description]"/>
                </else></if>
            </if>

            <service-call name="mantle.account.InvoiceServices.create#TimeEntryInvoiceItems" out-map="createResult"
                    in-map="[invoiceId:invoiceId, workEffortId:workEffortId, thruDate:thruDate,
                        currencyUomId:currencyUomId, ratePurposeEnumId:ratePurposeEnumId, itemTypeEnumId:itemTypeEnumId,
                        workerPartyId:workerPartyId, vendorPartyId:vendorPartyId]"/>
            <set field="invoiceItemCreatedCount" from="createResult.invoiceItemCreatedCount"/>

            <!-- add items for all expense invoice items for project that are not yet billed through -->
            <if condition="ratePurposeEnumId == 'RaprClient'">
                <entity-find entity-name="mantle.work.effort.WorkEffortInvoiceDetail" list="weidList">
                    <econdition field-name="workEffortId" ignore-if-empty="true"/>
                    <econdition field-name="statusId" value="InvoicePmtSent"/>
                    <econdition field-name="invoiceDate" operator="less-equals" from="thruDate"/>
                    <!-- don't include invoices to project CustomerBillTo partyId -->
                    <econdition field-name="toPartyId" operator="not-equals" from="billToWep.partyId"/>
                    <!-- don't include invoices from project VendorBillFrom partyId -->
                    <econdition field-name="fromPartyId" operator="not-equals" from="billFromWep.partyId"/>
                    <!-- filter by workerPartyId if specified, will be the fromPartyId on an expense invoice -->
                    <econdition field-name="fromPartyId" from="workerPartyId" ignore-if-empty="true"/>
                    <order-by field-name="-invoiceDate"/>
                </entity-find>
                <iterate list="weidList" entry="weid">
                    <!-- create invoice items and InvoiceItemAssocs, set invoice statusId -->
                    <service-call name="mantle.account.InvoiceServices.create#InvoiceBillThroughItems"
                            in-map="[originalInvoiceId:weid.invoiceId, newInvoiceId:invoiceId]" out-map="createResult"/>
                    <set field="invoiceItemCreatedCount" from="invoiceItemCreatedCount + createResult.invoiceItemCreatedCount"/>
                    <service-call name="update#mantle.account.invoice.Invoice"
                            in-map="[invoiceId:weid.invoiceId, statusId:'InvoiceBilledThrough']"/>
                </iterate>
            </if>

            <if condition="invoiceItemCreatedCount == 0"><then>
                <message error="true">No time entries or expenses found for Project ${ec.resource.expand('WorkEffortNameTemplate','',workEffort)}, not creating invoice or adding items to existing invoice.</message>
            </then><else>
                <message>Added ${invoiceItemCreatedCount} items to Invoice ${invoiceId}</message>
            </else></if>
        </actions>
    </service>

    <service verb="create" noun="WorkerInvoiceItems">
        <in-parameters>
            <parameter name="workerPartyId" required="true"/>
            <parameter name="vendorPartyId" required="true"><description>Matches TimeEntry.vendorPartyId, a Project Vendor or Employer</description></parameter>
            <parameter name="invoiceId"><description>If specified add item(s) to this Invoice. If empty an Invoice will be created.</description></parameter>
            <parameter name="thruDate" type="Timestamp" default="ec.user.nowTimestamp">
                <description>Only TimeEntry records before this date will be included. Defaults to now.</description></parameter>
            <parameter name="invoiceDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="currencyUomId"/>
            <parameter name="workEffortId"><description>If specified filter TimeEntry query by the specified WorkEffort and all WorkEfforts matching on rootWorkEffortId (for projects, etc) or parentWorkEffortId</description></parameter>
            <parameter name="timesheetId"><description>If specified get TimeEntry records constrained on it.</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="workerParty">
                <field-map field-name="partyId" from="workerPartyId"/></entity-find-one>
            <!-- is worker an employee? -->
            <entity-find entity-name="mantle.party.PartyRelationship" list="employeeRelationshipList">
                <date-filter/>
                <econdition field-name="fromPartyId" from="workerPartyId"/>
                <econdition field-name="toPartyId" from="vendorPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtEmployee"/>
                <econdition field-name="fromRoleTypeId" value="Employee"/>
            </entity-find>
            <set field="isEmployee" from="employeeRelationshipList.size() &gt; 0"/>

            <set field="invoiceTypeEnumId" from="workerParty?.partyTypeEnumId == 'PtyPerson' ?
                    (isEmployee ? 'InvoicePayroll' : 'InvoicePayrollOther') : 'InvoiceSales'"/>
            <!-- NEW: use ItemHourlyEarnings for Employee Person vendor/worker invoices, ItemTimeEntry for client/customer invoices and all other vendor/worker invoices -->
            <set field="itemTypeEnumId" from="workerParty?.partyTypeEnumId == 'PtyPerson' &amp;&amp; isEmployee ? 'ItemHourlyEarnings' : 'ItemTimeEntry'"/>

            <!-- create Invoice associated with WorkEffort, use WorkEffortParty to find from/to parties -->
            <if condition="!invoiceId">
                <if condition="!currencyUomId">
                    <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference">
                        <field-map field-name="organizationPartyId" from="vendorPartyId"/></entity-find-one>
                    <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId ?: 'USD'"/>
                </if>
                <set field="description" value="Invoice for worker ${ec.resource.expand('PartyNameTemplate','',workerParty)}"/>
                <service-call name="mantle.account.InvoiceServices.create#Invoice" out-map="context"
                        in-map="[invoiceTypeEnumId:invoiceTypeEnumId, fromPartyId:workerPartyId, toPartyId:vendorPartyId,
                            invoiceDate:invoiceDate, currencyUomId:currencyUomId, description:description]"/>
            </if>

            <service-call name="mantle.account.InvoiceServices.create#TimeEntryInvoiceItems" out-map="createResult"
                    in-map="[invoiceId:invoiceId, workEffortId:workEffortId, timesheetId:timesheetId, thruDate:thruDate,
                        currencyUomId:currencyUomId, ratePurposeEnumId:'RaprVendor', itemTypeEnumId:itemTypeEnumId,
                        workerPartyId:workerPartyId, vendorPartyId:vendorPartyId]"/>

            <if condition="!createResult.invoiceItemCreatedCount"><then>
                <message error="true">No time entries found for worker ${ec.resource.expand('PartyNameTemplate','',workerParty)}, not creating invoice or adding items to existing invoice.</message>
            </then><else>
                <message>Added ${createResult.invoiceItemCreatedCount} items to Invoice ${invoiceId}</message>
            </else></if>
        </actions>
    </service>

    <!-- InvoiceItems based on TimeEntry -->
    <service verb="create" noun="TimeEntryInvoiceItems">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="workEffortId"><description>If specified filter TimeEntry query by the specified WorkEffort and all WorkEfforts matching on rootWorkEffortId (for projects, etc) or parentWorkEffortId</description></parameter>
            <parameter name="timesheetId"><description>If specified get TimeEntry records constrained on it.</description></parameter>
            <parameter name="thruDate" type="Timestamp" default="ec.user.nowTimestamp">
                <description>Only TimeEntry records before this date will be included. Defaults to now.</description></parameter>
            <parameter name="createSingleItem" type="Boolean" default="false"/>
            <parameter name="itemTypeEnumId" default-value="ItemTimeEntry"><description>If not specified uses ItemTimeEntry for RaprClient,
                for RaprVendor use ItemHourlyEarnings for Person Worker and ItemTimeEntry for Organization Worker</description></parameter>
            <parameter name="currencyUomId" default-value="${ec.user.getPreference('CurrencyDefault') ?: 'USD'}"/>
            <parameter name="ratePurposeEnumId" default-value="RaprClient"><description>If RaprVendor TimeEntry.vendorInvoiceId is
                populated and time entries with it populated are excluded, otherwise with default of RaprClient TimeEntry.invoiceId is used.</description></parameter>
            <parameter name="workerPartyId"><description>If specified only include time entries from this Party (matches TimeEntry.partyId)</description></parameter>
            <parameter name="vendorPartyId"><description>Matches TimeEntry.vendorPartyId, a Project Vendor or Employer</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="invoiceItemCreatedCount" type="Long"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.work.effort.WorkEffort" value-field="workEffort"/>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="workerParty">
                <field-map field-name="partyId" from="workerPartyId"/></entity-find-one>

            <if condition="workEffortId">
                <set field="workEffortIdSet" from="new HashSet()"/>
                <script>workEffortIdSet.add(workEffortId)</script>
                <entity-find entity-name="mantle.work.effort.WorkEffort" list="descendantWorkEffortList">
                    <econditions combine="or">
                        <econdition field-name="rootWorkEffortId" from="workEffortId"/>
                        <econdition field-name="parentWorkEffortId" from="workEffortId"/>
                    </econditions>
                    <select-field field-name="workEffortId"/>
                    <order-by field-name="workEffortId"/>
                </entity-find>
                <script>if (descendantWorkEffortList) workEffortIdSet.addAll(descendantWorkEffortList*.workEffortId)</script>
            </if>

            <if condition="ratePurposeEnumId == 'RaprVendor'"><then><set field="timeEntryInvoiceCondition" from="[vendorInvoiceId:null]"/></then>
                <else><set field="timeEntryInvoiceCondition" from="[invoiceId:null]"/></else></if>
            <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList">
                <econdition-object field="timeEntryInvoiceCondition"/>
                <econdition field-name="workEffortId" operator="in" from="workEffortIdSet" ignore-if-empty="true"/>
                <econdition field-name="timesheetId" ignore-if-empty="true"/>
                <econditions combine="or">
                    <econdition field-name="thruDate" operator="less-equals" from="thruDate"/>
                    <econdition field-name="thruDate" from="null"/>
                </econditions>
                <!-- filter by workerPartyId if specified -->
                <econdition field-name="partyId" from="workerPartyId" ignore-if-empty="true"/>
                <econdition field-name="vendorPartyId" ignore-if-empty="true" or-null="true"/>
            </entity-find>

            <set field="invoiceItemCreatedCount" from="0" type="Long"/>
            <if condition="createSingleItem"><then>
                <set field="amountTotal" from="0"/>
                <iterate list="timeEntryList" entry="timeEntry">
                    <service-call name="mantle.work.TimeServices.get#TimeEntryAmount" out-map="getTeaOut"
                            in-map="[timeEntryId:timeEntry.timeEntryId, timeEntry:timeEntry, ratePurposeEnumId:ratePurposeEnumId]"/>
                    <set field="amountTotal" from="amountTotal + getTeaOut.amountTotal"/>
                </iterate>
                <if condition="amountTotal">
                    <set field="description" value="Time entries for task ${ec.resource.expand('WorkEffortNameTemplate','',workEffort)}"/>
                    <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="iiOut"
                            in-map="[invoiceId:invoiceId, itemTypeEnumId:itemTypeEnumId,
                                amount:amountTotal, quantity:1, description:description]"/>
                    <set field="invoiceItemCreatedCount" from="invoiceItemCreatedCount + 1"/>

                    <iterate list="timeEntryList" entry="timeEntry">
                        <set field="rateAmountId" from="ratePurposeEnumId == 'RaprVendor' ? timeEntry.vendorRateAmountId : timeEntry.rateAmountId"/>
                        <if condition="rateAmountId">
                            <if condition="ratePurposeEnumId == 'RaprVendor'"><then>
                                <set field="timeEntry.vendorInvoiceId" from="invoiceId"/>
                                <set field="timeEntry.vendorInvoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                            </then><else>
                                <set field="timeEntry.invoiceId" from="invoiceId"/>
                                <set field="timeEntry.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                            </else></if>
                            <entity-update value-field="timeEntry"/>
                        </if>
                    </iterate>
                </if>
            </then><else>
                <iterate list="timeEntryList" entry="timeEntry">
                    <service-call name="mantle.work.TimeServices.get#TimeEntryAmount" out-map="getTeaOut"
                            in-map="[timeEntryId:timeEntry.timeEntryId, timeEntry:timeEntry, ratePurposeEnumId:ratePurposeEnumId]"/>

                    <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="iiOut"
                            in-map="[invoiceId:invoiceId, itemTypeEnumId:itemTypeEnumId,
                                amount:getTeaOut.amount, quantity:getTeaOut.quantity, description:timeEntry.comments?.take(250),
                                itemDate:timeEntry.thruDate]"/>
                    <set field="invoiceItemCreatedCount" from="invoiceItemCreatedCount + 1"/>

                    <if condition="ratePurposeEnumId == 'RaprVendor'"><then>
                        <set field="timeEntry.vendorInvoiceId" from="invoiceId"/>
                        <set field="timeEntry.vendorInvoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                    </then><else>
                        <set field="timeEntry.invoiceId" from="invoiceId"/>
                        <set field="timeEntry.invoiceItemSeqId" from="iiOut.invoiceItemSeqId"/>
                    </else></if>
                    <entity-update value-field="timeEntry"/>
                </iterate>
            </else></if>
        </actions>
    </service>

    <service verb="create" noun="InvoiceBillThroughItems">
        <in-parameters>
            <parameter name="originalInvoiceId" required="true"/>
            <parameter name="newInvoiceId" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="invoiceItemCreatedCount" type="Long"/></out-parameters>
        <actions>
            <set field="invoiceItemCreatedCount" from="0" type="Long"/>

            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="originalInvoice">
                <field-map field-name="invoiceId" from="originalInvoiceId"/></entity-find-one>
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="originalInvoiceItemList">
                <econdition field-name="invoiceId" from="originalInvoiceId"/></entity-find>
            <iterate list="originalInvoiceItemList" entry="originalInvoiceItem">
                <!-- if there is a TimeEntry with this as a vendor InvoiceItem skip it so it isn't double billed (and at the incorrect rate) -->
                <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList">
                    <econdition field-name="vendorInvoiceId" from="originalInvoiceItem.invoiceId"/>
                    <econdition field-name="vendorInvoiceItemSeqId" from="originalInvoiceItem.invoiceItemSeqId"/>
                </entity-find>
                <if condition="!timeEntryList">
                    <!-- create new InvoiceItem -->
                    <service-call name="create#mantle.account.invoice.InvoiceItem" out-map="iiOut"
                            in-map="[invoiceId:newInvoiceId, itemTypeEnumId:originalInvoiceItem.itemTypeEnumId,
                                amount:originalInvoiceItem.amount, quantity:originalInvoiceItem.quantity,
                                description:originalInvoiceItem.description, itemDate:originalInvoiceItem.itemDate]"/>
                    <set field="invoiceItemCreatedCount" from="invoiceItemCreatedCount + 1"/>
                    <!-- create InvoiceItemAssoc between original and new -->
                    <service-call name="create#mantle.account.invoice.InvoiceItemAssoc"
                            in-map="[invoiceId:originalInvoiceItem.invoiceId, invoiceItemSeqId:originalInvoiceItem.invoiceItemSeqId,
                                toInvoiceId:newInvoiceId, toInvoiceItemSeqId:iiOut.invoiceItemSeqId,
                                invoiceItemAssocTypeEnumId:'IiatBillThrough', amount:originalInvoiceItem.amount,
                                quantity:originalInvoiceItem.quantity]"/>
                </if>
            </iterate>
        </actions>
    </service>

    <service verb="create" noun="InvoiceCreditMemo">
        <description>Create a Credit Memo type Invoice for the specified Invoice with reverse parties, item for amount specified, etc.</description>
        <in-parameters>
            <parameter name="originalInvoiceId" required="true"/>
            <parameter name="invoiceDate" type="Timestamp"/>
            <parameter name="invoiceTypeEnumId" default-value="InvoiceCreditMemo"/>

            <parameter name="quantity" type="BigDecimal" default="1.0"/>
            <parameter name="amount" type="BigDecimal"/>
            <parameter name="description"/>
            <parameter name="itemTypeEnumId"/>
            <parameter name="overrideGlAccountId"/>
            <parameter name="activeOrgId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="invoiceId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="originalInvoice">
                <field-map field-name="invoiceId" from="originalInvoiceId"/></entity-find-one>

            <!-- create invoice and item with create#Invoice, create#InvoiceItem -->
            <service-call name="mantle.account.InvoiceServices.create#Invoice" out-map="context"
                    in-map="[invoiceTypeEnumId:invoiceTypeEnumId, fromPartyId:originalInvoice.toPartyId, toPartyId:originalInvoice.fromPartyId,
                        invoiceDate:invoiceDate, currencyUomId:originalInvoice.currencyUomId, otherPartyOrderId:originalInvoice.otherPartyOrderId,
                        productStoreId:originalInvoice.productStoreId, systemMessageRemoteId:originalInvoice.systemMessageRemoteId]"/>

            <service-call name="create#mantle.account.invoice.InvoiceItem"
                    in-map="[invoiceId:invoiceId, itemTypeEnumId:itemTypeEnumId, amount:amount, quantity:quantity,
                        description:description, overrideGlAccountId:overrideGlAccountId]"/>
        </actions>
    </service>

    <service verb="reverse" noun="Invoice">
        <description>
            Reverse an invoice making a payable invoice receivable or a receivable invoice payable.
            Reverses from and to parties and negates all InvoiceItem amounts.
            May only be run on invoices not applied to anything, and in the InvoiceInProcess, InvoiceIncoming, or InvoiceReceived statuses.
            Should only be run on invoices with a negative total but that is not enforced.
        </description>
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice" for-update="true"/>

            <!-- check status -->
            <if condition="!(invoice.statusId in ['InvoiceInProcess', 'InvoiceIncoming', 'InvoiceReceived'])">
                <return type="danger" message="Cannot reverse invoice ${invoiceId} in status ${invoice.status?.description}, must be In Process, Incoming, or Received"/></if>

            <!-- check applications - should never happen given status but just in case -->
            <entity-find-count entity-name="mantle.account.payment.PaymentApplication" count-field="applCount">
                <econditions combine="or">
                    <econdition field-name="invoiceId"/>
                    <econdition field-name="toInvoiceId" from="invoiceId"/>
                </econditions>
                <econdition field-name="amountApplied" operator="not-equals" from="0.0"/>
            </entity-find-count>
            <if condition="applCount">
                <return type="danger" message="Cannot reverse invoice ${invoiceId} because it is already applied"/></if>

            <!-- swap from/to parties, switch status -->
            <set field="targetStatusId" from="invoice.statusId == 'InvoiceInProcess' ? 'InvoiceIncoming' : 'InvoiceInProcess'"/>
            <service-call name="update#mantle.account.invoice.Invoice"
                    in-map="[invoiceId:invoiceId, fromPartyId:invoice.toPartyId, toPartyId:invoice.fromPartyId, statusId:targetStatusId]"/>

            <!-- negate all item amounts -->
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="invoiceItemList" for-update="true">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="invoiceItemList" entry="invoiceItem">
                <service-call name="update#mantle.account.invoice.InvoiceItem"
                        in-map="[invoiceId:invoiceId, invoiceItemSeqId:invoiceItem.invoiceItemSeqId, amount:-invoiceItem.amount]"/>
            </iterate>
        </actions>
    </service>

    <service verb="cancel" noun="Invoice">
        <description>Set to Cancelled status if not already in Cancelled. Un-apply payment invoice if any applied. May
            be called directly or through SECA rule on Cancelled status.</description>
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <actions>
            <service-call name="mantle.account.InvoiceServices.unpay#Invoice"
                    in-map="[invoiceId:invoiceId, statusId:'InvoiceCancelled']"/>

            <!-- zero quantity on OrderItemBilling, ReturnItemBilling, WorkEffortBilling -->
            <entity-find entity-name="mantle.order.OrderItemBilling" list="oibList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="oibList" entry="oib">
                <set field="oib.quantity" from="0.0"/>
                <entity-update value-field="oib"/>
            </iterate>
            <entity-find entity-name="mantle.order.return.ReturnItemBilling" list="ribList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="ribList" entry="rib">
                <set field="rib.quantity" from="0.0"/>
                <entity-update value-field="rib"/>
            </iterate>
            <entity-find entity-name="mantle.work.effort.WorkEffortBilling" list="webList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="webList" entry="web">
                <set field="web.percentage" from="0.0"/>
                <entity-update value-field="web"/>
            </iterate>

            <!-- clear ShipmentItemSource, AssetIssuance, AssetReceipt -->
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="sisList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="sisList" entry="sis">
                <set field="sis.invoiceId" from="null"/><set field="sis.invoiceItemSeqId" from="null"/>
                <entity-update value-field="sis"/>
            </iterate>
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="aisList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="aisList" entry="ais">
                <set field="ais.invoiceId" from="null"/><set field="ais.invoiceItemSeqId" from="null"/>
                <entity-update value-field="ais"/>
            </iterate>
            <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="arcList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="arcList" entry="arc">
                <set field="arc.invoiceId" from="null"/><set field="arc.invoiceItemSeqId" from="null"/>
                <entity-update value-field="arc"/>
            </iterate>

            <!-- clear TimeEntry (by invoiceId, vendorInvoiceId) -->
            <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="timeEntryList" entry="timeEntry">
                <set field="timeEntry.invoiceId" from="null"/><set field="timeEntry.invoiceItemSeqId" from="null"/>
                <entity-update value-field="timeEntry"/>
            </iterate>
            <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList">
                <econdition field-name="vendorInvoiceId" from="invoiceId"/></entity-find>
            <iterate list="timeEntryList" entry="timeEntry">
                <set field="timeEntry.vendorInvoiceId" from="null"/><set field="timeEntry.vendorInvoiceItemSeqId" from="null"/>
                <entity-update value-field="timeEntry"/>
            </iterate>
        </actions>
    </service>
    <service verb="cancel" noun="InvoiceAndPayments">
        <description>Cancel the Invoice and any Payment(s) applied to the Invoice and any Payments with matching forInvoiceId even if not applied.</description>
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <actions>
            <!-- get related invoices -->
            <set field="paymentIdSet" from="new TreeSet()"/>
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="forInvoiceId" from="invoiceId"/></entity-find>
            <if condition="paymentList"><script>paymentIdSet.addAll(paymentList*.paymentId)</script></if>

            <entity-find entity-name="mantle.account.payment.PaymentApplication" list="paymentApplicationList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="paymentApplicationList" entry="paymentApplication">
                <if condition="paymentApplication.paymentId"><script>paymentIdSet.add(paymentApplication.paymentId)</script></if></iterate>

            <!-- most of the work is done through SECA rules, so here we just have to set statuses -->
            <service-call name="update#mantle.account.invoice.Invoice" in-map="[invoiceId:invoiceId, statusId:'InvoiceCancelled']"/>
            <iterate list="paymentIdSet" entry="paymentId">
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
                <set field="targetStatusId" from="payment.statusId in ['PmntProposed', 'PmntPromised'] ? 'PmntCancelled' : 'PmntVoid'"/>
                <service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:paymentId, statusId:targetStatusId]"/>
            </iterate>
        </actions>
    </service>
    <service verb="unpay" noun="Invoice">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="statusId"/>
        </in-parameters>
        <actions>
            <!-- check/update the status -->
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice" for-update="true"/>
            <if condition="!statusId">
                <if condition="invoice.statusId == 'InvoicePmtRecvd'"><set field="statusId" value="InvoiceFinalized"/></if>
                <if condition="invoice.statusId == 'InvoicePmtSent'"><set field="statusId" value="InvoiceApproved"/></if>
            </if>
            <if condition="statusId &amp;&amp; invoice.statusId != statusId">
                <service-call name="update#mantle.account.invoice.Invoice" in-map="[invoiceId:invoiceId, statusId:statusId]"/></if>

            <!-- unapply payment applications -->
            <entity-find entity-name="mantle.account.payment.PaymentApplication" list="paymentApplicationList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="paymentApplicationList" entry="paymentApplication"><if condition="paymentApplication.amountApplied != 0">
                <service-call name="mantle.account.PaymentServices.unapply#PaymentApplication"
                        in-map="[paymentApplicationId:paymentApplication.paymentApplicationId]"/>
            </if></iterate>
        </actions>
    </service>

    <service verb="autoApplyTo" noun="Invoice">
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <out-parameters><parameter name="paymentIdList" type="List"/></out-parameters>
        <actions>
            <!-- TODO: implement this... -->
        </actions>
    </service>

    <!-- ========== Invoice Item Detail Services ========== -->

    <service verb="create" noun="InvoiceItemDetail">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.invoice.InvoiceItemDetail" include="nonpk"/>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
            <parameter name="createNoQuantity" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters><parameter name="invoiceItemDetailId"/></out-parameters>
        <actions>
            <if condition="!createNoQuantity &amp;&amp; !quantity"><return/></if>
            <if condition="!assetId &amp;&amp; !facilityId &amp;&amp; !partyId">
                <return error="true" message="Must specify one of facility, asset, or party"/></if>
            <if condition="assetId &amp;&amp; facilityId"><return error="true" message="Both asset and facility specified, choose only one"/></if>
            <if condition="assetId &amp;&amp; partyId"><return error="true" message="Both asset and party specified, choose only one"/></if>
            <if condition="facilityId &amp;&amp; partyId"><return error="true" message="Both facility and party specified, choose only one"/></if>

            <if condition="assetId"><then>
                <entity-find entity-name="mantle.account.invoice.InvoiceItemDetail" list="iidList">
                    <econdition field-name="invoiceId"/><econdition field-name="invoiceItemSeqId"/><econdition field-name="assetId"/></entity-find>
                <if condition="iidList"><return message="Detail already exists for item ${invoiceItemSeqId} and asset ${assetId}"/></if>
            </then><else-if condition="facilityId">
                <entity-find entity-name="mantle.account.invoice.InvoiceItemDetail" list="iidList">
                    <econdition field-name="invoiceId"/><econdition field-name="invoiceItemSeqId"/><econdition field-name="facilityId"/></entity-find>
                <if condition="iidList"><return message="Detail already exists for item ${invoiceItemSeqId} and facility ${facilityId}"/></if>
            </else-if><else-if condition="partyId">
                <entity-find entity-name="mantle.account.invoice.InvoiceItemDetail" list="iidList">
                    <econdition field-name="invoiceId"/><econdition field-name="invoiceItemSeqId"/><econdition field-name="partyId"/></entity-find>
                <if condition="iidList"><return message="Detail already exists for item ${invoiceItemSeqId} and party ${partyId}"/></if>
            </else-if></if>
            <service-call name="create#mantle.account.invoice.InvoiceItemDetail" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="distribute" noun="InvoiceItemDetail">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.InvoiceItem" value-field="invoiceItem"/>
            <entity-find entity-name="mantle.account.invoice.InvoiceItemDetail" list="detailList">
                <econdition field-name="invoiceId"/><econdition field-name="invoiceItemSeqId"/></entity-find>
            <set field="quantityRemaining" from="invoiceItem.quantity"/>
            <set field="totalFacilitySize" from="0"/>
            <set field="detailsToUpdate" from="[]"/>
            <set field="facilityMap" from="[:]"/>
            <set field="facilitySizeMap" from="[:]"/>
            <iterate list="detailList" entry="detail">
                <if condition="detail.facilityId == null"><continue/></if>
                <if condition="detail.quantity"><then>
                    <set field="quantityRemaining" from="quantityRemaining - detail.quantity"/>
                </then><else>
                    <set field="detailFacility" from="facilityMap.get(detail.facilityId)"/>
                    <if condition="detailFacility == null">
                        <entity-find-one entity-name="mantle.facility.Facility" value-field="detailFacility">
                            <field-map field-name="facilityId" from="detail.facilityId"/></entity-find-one>
                        <script>facilityMap.put(detail.facilityId, detailFacility)</script>
                    </if>
                    <if condition="detailFacility.facilitySize">
                        <if condition="detailFacility.facilitySizeUomId">
                            <!-- convert to standard unit, like acres... if unit not an area return error -->
                            <set field="currentSize" from="detailFacility.facilitySize"/>
                            <set field="sizeUom" from="detailFacility.sizeUom"/>
                            <if condition="sizeUom.uomTypeEnumId != 'UT_AREA_MEASURE'">
                                <return error="true" message="Facility ${detailFacility.pseudoId}: ${detailFacility.facilityName} has a size UOM that is not an area"/></if>
                            <if condition="activeSizeUom == null"><then>
                                <set field="activeSizeUom" from="sizeUom"/>
                            </then><else-if condition="activeSizeUom.uomId != sizeUom.uomId">
                                <service-call name="org.moqui.impl.BasicServices.convert#Uom"
                                              in-map="[uomId:sizeUom.uomId, toUomId:activeSizeUom.uomId, amount:currentSize]"
                                              out-map="sizeConvertOut" out-map-add-to-existing="false"/>
                                <check-errors/>
                                <set field="currentSize" from="sizeConvertOut.convertedAmount"/>
                            </else-if></if>
                        </if>
                        <set field="totalFacilitySize" from="totalFacilitySize + currentSize"/>
                        <script>facilitySizeMap.put(detail.facilityId, currentSize)</script>
                        <script>detailsToUpdate.add(detail)</script>
                    </if>
                </else></if>
            </iterate>
            <iterate list="detailsToUpdate" entry="detail">
                <set field="currentSize" from="facilitySizeMap.get(detail.facilityId)"/>
                <set field="detail.quantity" from="quantityRemaining * (currentSize / totalFacilitySize)"/>
                <entity-update value-field="detail"/>
            </iterate>
            <message>Set quantity on ${detailsToUpdate.size()} details for item ${invoiceItemSeqId}, total facility size: ${ec.l10n.format(totalFacilitySize, '')}${activeSizeUom != null ? ' (' + activeSizeUom.description + ')' : ''}, quantity distributed: ${ec.l10n.format(quantityRemaining, '')}</message>
        </actions>
    </service>

    <!-- ========== OrderItemBilling Services ========== -->

    <service verb="apply" noun="InvoiceToOrder">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="invoiceItemList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="invoiceItemList" entry="invoiceItem">
                <service-call name="mantle.account.InvoiceServices.apply#InvoiceItemToOrder" in-map="[invoiceId:invoiceId,
                        invoiceItemSeqId:invoiceItem.invoiceItemSeqId, orderId:orderId, orderPartSeqId:orderPartSeqId]"/>
            </iterate>
        </actions>
    </service>
    <service verb="apply" noun="InvoiceItemToOrder">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <entity-find-one entity-name="mantle.account.invoice.InvoiceItem" value-field="invoiceItem"/>

            <!-- make sure parties match on Invoice and OrderPart -->
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId" ignore-if-empty="true"/>
            </entity-find>
            <set field="orderPart" from="orderPartList.first()"/>
            <if condition="orderPart.customerPartyId != invoice.toPartyId">
                <return error="true" message="Order customer ${orderPart.customerPartyId} does not match invoice to party ${invoice.toPartyId}"/></if>
            <if condition="orderPart.vendorPartyId != invoice.fromPartyId">
                <return error="true" message="Order vendor ${orderPart.vendorPartyId} does not match invoice from party ${invoice.fromPartyId}"/></if>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId" ignore-if-empty="true"/>
                <econdition field-name="itemTypeEnumId" from="invoiceItem.itemTypeEnumId"/>
                <econdition field-name="productId" from="invoiceItem.productId" ignore-if-empty="true"/>
                <!-- TODO: other matching constraints? just warn about price diff (done below in loop) -->
            </entity-find>

            <set field="invoiceQtyOrig" from="invoiceItem.quantity != null ? invoiceItem.quantity : 1.0"/>
            <set field="invoiceQtyRemaining" from="invoiceQtyOrig"/>
            <entity-find entity-name="mantle.order.OrderItemBillingQuantity" list="oibqList">
                <econdition field-name="invoiceId"/><econdition field-name="invoiceItemSeqId"/><select-field field-name="quantity"/></entity-find>
            <set field="invoiceBilledQuantity" from="oibqList?.getAt(0)?.quantity ?: 0.0"/>
            <set field="invoiceQtyRemaining" from="invoiceQtyRemaining - invoiceBilledQuantity"/>
            <if condition="invoiceQtyRemaining &lt;= 0.0"><return message="Invoice ${invoiceId} item ${invoiceItemSeqId} already fully applied to orders"/></if>

            <iterate list="orderItemList" entry="orderItem">
                <entity-find entity-name="mantle.order.OrderItemBillingQuantity" list="oibqList">
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                    <select-field field-name="quantity"/>
                </entity-find>
                <set field="orderBilledQuantity" from="oibqList?.getAt(0)?.quantity ?: 0.0"/>

                <set field="quantityNotBilled" from="(orderItem.quantity != null ? orderItem.quantity : 1.0) * (orderItem.selectedAmount ?: 1.0)"/>
                <set field="quantityNotBilled" from="quantityNotBilled - orderBilledQuantity"/>
                <if condition="quantityNotBilled &lt;= 0.0"><continue/></if>

                <set field="quantityToBill" from="quantityNotBilled &gt; invoiceQtyRemaining ? invoiceQtyRemaining : quantityNotBilled"/>

                <!-- check and warn about price diff -->
                <if condition="invoiceItem.amount != orderItem.unitAmount">
                    <if condition="invoiceItem.itemTypeEnumId in productItemTypes"><then>
                        <script>ec.message.addMessage("Invoice ${invoiceId} item ${invoiceItemSeqId} amount ${invoiceItem.amount} different from order ${orderId} item ${orderItem.orderItemSeqId} amount ${orderItem.unitAmount} but is product so applying anyway", 'warning')</script>
                    </then><else>
                        <continue/>
                    </else></if>
                </if>

                <set field="curShipmentId" from="null"/>
                <set field="curAssetIssuanceId" from="null"/>
                <set field="curAssetReceiptId" from="null"/>
                <if condition="invoiceItem.itemTypeEnumId in productItemTypes">
                    <!-- for ShipmentItemSource set the invoiceId/invoiceItemSeqId on it -->
                    <set field="quantityNotShipSourced" from="quantityToBill"/>
                    <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                        <econdition field-name="orderId"/>
                        <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                        <order-by field-name="-quantity"/>
                    </entity-find>
                    <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                        <if condition="!shipmentItemSource.invoiceId &amp;&amp; quantityNotShipSourced &gt;= shipmentItemSource.quantity">
                            <set field="shipmentItemSource.invoiceId" from="invoiceId"/>
                            <set field="shipmentItemSource.invoiceItemSeqId" from="invoiceItemSeqId"/>
                            <entity-update value-field="shipmentItemSource"/>
                            <set field="quantityNotShipSourced" from="quantityNotShipSourced - shipmentItemSource.quantity"/>
                            <set field="curShipmentId" from="shipmentItemSource.shipmentId"/>
                        </if>
                    </iterate>
                    <if condition="!curShipmentId">
                        <!-- see if ShipmentItemSource already exists for InvoiceItem -->
                        <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="invoiceSisList">
                            <econdition field-name="invoiceId"/>
                            <econdition field-name="invoiceItemSeqId"/>
                            <select-field field-name="shipmentId"/>
                        </entity-find>
                        <set field="curShipmentId" from="invoiceSisList[0]?.shipmentId"/>
                    </if>

                    <!-- lookup and fill in assetIssuanceId -->
                    <set field="quantityNotIssuance" from="quantityToBill"/>
                    <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="assetIssuanceList">
                        <econdition field-name="orderId"/>
                        <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                    </entity-find>
                    <iterate list="assetIssuanceList" entry="assetIssuance">
                        <if condition="!assetIssuance.invoiceId &amp;&amp; quantityNotIssuance &gt;= assetIssuance.quantity">
                            <set field="assetIssuance.invoiceId" from="invoiceId"/>
                            <set field="assetIssuance.invoiceItemSeqId" from="invoiceItemSeqId"/>
                            <entity-update value-field="assetIssuance"/>
                            <set field="quantityNotIssuance" from="quantityNotIssuance - assetIssuance.quantity"/>
                            <set field="curAssetIssuanceId" from="assetIssuance.assetIssuanceId"/>
                        </if>
                    </iterate>
                    <if condition="!curAssetIssuanceId">
                        <!-- see if ShipmentItemSource already exists for InvoiceItem -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="invoiceAsiList">
                            <econdition field-name="invoiceId"/>
                            <econdition field-name="invoiceItemSeqId"/>
                            <select-field field-name="assetIssuanceId"/>
                        </entity-find>
                        <set field="curAssetIssuanceId" from="invoiceAsiList[0]?.assetIssuanceId"/>
                    </if>

                    <!-- lookup and fill in assetReceiptId -->
                    <set field="quantityNotReceipt" from="quantityToBill"/>
                    <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="assetReceiptList">
                        <econdition field-name="orderId"/>
                        <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                    </entity-find>
                    <iterate list="assetReceiptList" entry="assetReceipt">
                        <if condition="!assetReceipt.invoiceId &amp;&amp; quantityNotReceipt &gt;= assetReceipt.quantityAccepted">
                            <set field="assetReceipt.invoiceId" from="invoiceId"/>
                            <set field="assetReceipt.invoiceItemSeqId" from="invoiceItemSeqId"/>
                            <entity-update value-field="assetReceipt"/>
                            <set field="quantityNotReceipt" from="quantityNotReceipt - assetReceipt.quantityAccepted"/>
                            <set field="curAssetReceiptId" from="assetReceipt.assetReceiptId"/>
                        </if>
                    </iterate>
                    <if condition="!curAssetReceiptId">
                        <!-- see if ShipmentItemSource already exists for InvoiceItem -->
                        <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="invoiceAsrList">
                            <econdition field-name="invoiceId"/>
                            <econdition field-name="invoiceItemSeqId"/>
                            <select-field field-name="assetReceiptId"/>
                        </entity-find>
                        <set field="curAssetReceiptId" from="invoiceAsrList[0]?.assetReceiptId"/>
                    </if>
                </if>

                <!-- finally create OrderItemBilling -->
                <service-call name="create#mantle.order.OrderItemBilling" in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId,
                        invoiceId:invoiceId, invoiceItemSeqId:invoiceItemSeqId, quantity:quantityToBill, amount:invoiceItem.amount,
                        shipmentId:curShipmentId, assetReceiptId:curAssetReceiptId, assetIssuanceId:curAssetIssuanceId]"/>
                <set field="invoiceQtyRemaining" from="invoiceQtyRemaining - quantityToBill"/>
            </iterate>

            <if condition="invoiceQtyRemaining == 0.0"><then>
                <script>ec.message.addMessage("Invoice ${invoiceId} item ${invoiceItemSeqId} now fully applied", 'success')</script>
            </then><else-if condition="invoiceQtyRemaining &lt; invoiceQtyOrig">
                <script>ec.message.addMessage("Invoice ${invoiceId} item ${invoiceItemSeqId} partially applied", 'warning')</script>
            </else-if><else>
                <script>ec.message.addMessage("No order item matches found for invoice ${invoiceId} item ${invoiceItemSeqId}", 'warning')</script>
            </else></if>
        </actions>
    </service>
    <service verb="unapply" noun="InvoiceItemFromOrder">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="orderItemBillingId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItemBilling" value-field="orderItemBilling" for-update="true"/>
            <if condition="orderItemBilling?.invoiceId != invoiceId"><return error="true" message="Invoice ID did not match, not unapplying"/></if>

            <set field="orderItemBilling.quantity" from="0.0"/>
            <entity-update value-field="orderItemBilling"/>
        </actions>
    </service>

    <!-- ========== ShipmentItemSource Services ========== -->

    <service verb="apply" noun="InvoiceToShipment">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="shipmentId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>

            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="invoiceItemList">
                <econdition field-name="invoiceId"/></entity-find>
            <iterate list="invoiceItemList" entry="invoiceItem">
                <if condition="!(invoiceItem.itemTypeEnumId in productItemTypes)"><continue/></if>
                <service-call name="mantle.account.InvoiceServices.apply#InvoiceItemToShipment"
                        in-map="[invoiceId:invoiceId, invoiceItemSeqId:invoiceItem.invoiceItemSeqId, shipmentId:shipmentId]"/>
            </iterate>
        </actions>
    </service>
    <service verb="apply" noun="InvoiceItemToShipment">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
            <parameter name="shipmentId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <entity-find-one entity-name="mantle.account.invoice.InvoiceItem" value-field="invoiceItem"/>
            <if condition="!invoiceItem.productId"><return message="Invoice ${invoiceId} item ${invoiceItemSeqId} has no product"/></if>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <if condition="!(invoiceItem.itemTypeEnumId in productItemTypes)">
                <return message="Invoice ${invoiceId} item ${invoiceItemSeqId} is not a product item, cannot apply to shipment"/></if>

            <!-- make sure parties match on Invoice and Shipment -->
            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
            <if condition="shipment.toPartyId != invoice.toPartyId">
                <return error="true" message="Shipment to party ${shipment.toPartyId} does not match invoice to party ${invoice.toPartyId}"/></if>
            <if condition="shipment.fromPartyId != invoice.fromPartyId">
                <return error="true" message="Shipment from party ${shipment.fromPartyId} does not match invoice from party ${invoice.fromPartyId}"/></if>

            <!-- ShipmentItemSource -->
            <set field="invoiceQtyOrig" from="invoiceItem.quantity != null ? invoiceItem.quantity : 1.0"/>
            <set field="invoiceQtyRemaining" from="invoiceQtyOrig"/>
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="invoiceSisList">
                <econdition field-name="invoiceId"/>
                <econdition field-name="invoiceItemSeqId"/>
                <select-field field-name="quantity"/>
            </entity-find>
            <set field="invoiceShippedQuantity" from="invoiceSisList*.quantity.sum() ?: 0.0"/>
            <set field="invoiceQtyRemaining" from="invoiceQtyRemaining - invoiceShippedQuantity"/>
            <if condition="invoiceQtyRemaining &gt; 0.0"><then>
                <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                    <econdition field-name="shipmentId"/>
                    <econdition field-name="productId" from="invoiceItem.productId"/>
                    <order-by field-name="-quantity"/>
                </entity-find>
                <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                    <if condition="!shipmentItemSource.invoiceId &amp;&amp; invoiceQtyRemaining &gt;= shipmentItemSource.quantity">
                        <set field="shipmentItemSource.invoiceId" from="invoiceId"/>
                        <set field="shipmentItemSource.invoiceItemSeqId" from="invoiceItemSeqId"/>
                        <entity-update value-field="shipmentItemSource"/>
                        <set field="quantityNotShipSourced" from="invoiceQtyRemaining - shipmentItemSource.quantity"/>
                    </if>
                </iterate>
            </then><else>
                <message>Invoice ${invoiceId} item ${invoiceItemSeqId} already fully applied to shipments</message>
            </else></if>

            <!-- AssetIssuance for SIS, do in separate pass to fill in any missing data -->
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="invoiceSisFullList">
                <econdition field-name="invoiceId"/>
                <econdition field-name="invoiceItemSeqId"/>
            </entity-find>
            <iterate list="invoiceSisFullList" entry="invoiceSis">
                <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="sisIssuanceList">
                    <econdition field-name="shipmentItemSourceId" from="invoiceSis.shipmentItemSourceId"/>
                    <econdition field-name="invoiceId" operator="is-null"/>
                </entity-find>
                <iterate list="sisIssuanceList" entry="sisIssuance">
                    <set field="sisIssuance.invoiceId" from="invoiceSis.invoiceId"/>
                    <set field="sisIssuance.invoiceItemSeqId" from="invoiceSis.invoiceItemSeqId"/>
                    <entity-update value-field="sisIssuance"/>
                </iterate>
            </iterate>
        </actions>
    </service>
    <service verb="unapply" noun="InvoiceItemFromShipment">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="shipmentItemSourceId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.shipment.ShipmentItemSource" value-field="shipmentItemSource" for-update="true"/>
            <if condition="shipmentItemSource?.invoiceId != invoiceId"><return error="true" message="Invoice ID did not match, not unapplying"/></if>

            <set field="shipmentItemSource.invoiceId" from="null"/>
            <set field="shipmentItemSource.invoiceItemSeqId" from="null"/>
            <entity-update value-field="shipmentItemSource"/>
        </actions>
    </service>

    <!-- ========== Invoice Maintenance Services ========== -->

    <service verb="check" noun="InvoicesPaid" transaction-timeout="600">
        <description>Very simple service to find all invoices (receivable) in Finalized and Sent statuses and if unpaid amount is 0 change to Payment Received</description>
        <actions>
            <entity-find entity-name="mantle.account.invoice.Invoice" list="invoiceList">
                <econdition field-name="statusId" operator="in" value="InvoiceFinalized,InvoiceSent,InvoiceAcked"/>
            </entity-find>
            <set field="updatedCount" from="0"/>
            <iterate list="invoiceList" entry="invoice">
                <if condition="invoice.unpaidTotal == null">
                    <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal" in-map="[invoiceId:invoice.invoiceId]" out-map="totalOut"/>
                    <set field="invoice.invoiceTotal" from="totalOut.invoiceTotal"/>
                    <set field="invoice.appliedPaymentsTotal" from="totalOut.appliedPaymentsTotal"/>
                    <set field="invoice.unpaidTotal" from="totalOut.unpaidTotal"/>
                    <entity-update value-field="invoice"/>
                </if>
                <if condition="invoice.unpaidTotal == 0.0">
                    <set field="invoice.statusId" value="InvoicePmtRecvd"/>
                    <entity-update value-field="invoice"/>
                    <set field="updatedCount" from="updatedCount + 1"/>
                </if>
            </iterate>
            <log level="warn" message="Found ${invoiceList.size()} invoices in Finalized and Sent statuses, ${updatedCount} had zero unpaid and updated to Payment Received"/>
        </actions>
    </service>

    <!-- ========== Invoice Notification Services ========== -->

    <service verb="find" noun="InvoiceProductStores">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoice" type="EntityValue"/>
        </in-parameters>
        <out-parameters><parameter name="productStoreIdSet" type="Set"/></out-parameters>
        <actions>
            <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList" distinct="true">
                <econdition field-name="invoiceId"/>
                <select-field field-name="orderId"/>
            </entity-find>
            <set field="orderIdSet" from="new HashSet(orderItemBillingList*.orderId)"/>

            <if condition="orderIdSet">
                <entity-find entity-name="mantle.order.OrderHeader" list="orderHeaderList" distinct="true">
                    <econdition field-name="orderId" operator="in" from="orderIdSet"/>
                    <econdition field-name="productStoreId" operator="is-not-null"/>
                    <select-field field-name="productStoreId"/>
                </entity-find>
                <set field="productStoreIdSet" from="new HashSet(orderHeaderList*.productStoreId)"/>
            </if>

            <!-- use PartySetting to look up default store if none associated with invoice through orders -->
            <if condition="!productStoreIdSet">
                <if condition="invoice == null"><entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/></if>
                <if condition="invoice?.fromPartyId">
                    <service-call name="mantle.party.PartyServices.get#PartySettingValue" out-map="ptySettingOut"
                            in-map="[partyId:invoice.fromPartyId, partySettingTypeId:'OrgInvoiceProductStoreId']"/>
                    <if condition="ptySettingOut.settingValue">
                        <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="checkProdStore">
                            <field-map field-name="productStoreId" from="ptySettingOut.settingValue"/></entity-find-one>
                        <if condition="checkProdStore != null"><then>
                            <set field="productStoreIdSet" from="new HashSet()"/>
                            <script>productStoreIdSet.add(ptySettingOut.settingValue)</script>
                        </then><else>
                            <log level="error" message="In find#InvoiceProductStores found OrgInvoiceProductStoreId setting for party ${invoice.fromPartyId} with invalid productStoreId ${ptySettingOut.settingValue}"/>
                        </else></if>
                    </if>
                    <!-- still nothing?!? after all that? if there is one ProductStore for org use that -->
                    <if condition="!productStoreIdSet">
                        <entity-find entity-name="mantle.product.store.ProductStore" list="prodStoreList" limit="2">
                            <econdition field-name="organizationPartyId" from="invoice.fromPartyId"/></entity-find>
                        <if condition="prodStoreList.size() == 1">
                            <set field="productStoreIdSet" from="new HashSet()"/>
                            <script>productStoreIdSet.add(prodStoreList[0].productStoreId)</script>
                        </if>
                    </if>
                </if>
            </if>
        </actions>
    </service>

    <service verb="send" noun="InvoiceStoreEmail" authenticate="anonymous-view">
        <description>
            Send an email for Finalized receivable invoices. By default sends to all EmailBilling email addresses, if
            alsoPrimaryEmails true also include EmailPrimary addresses.

            Called by SECA rule in AccountingInvoice.secas.xml on tx-commit so runs async from triggering thread.
            May also be called directly with toAddresses specified to send to other email address.
        </description>
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="emailTypeEnumId" required="true"/>
            <parameter name="toAddresses"><text-email/></parameter>
            <parameter name="alsoPrimaryEmails" type="Boolean" default="false"/>
            <parameter name="setFinalizedInvoiceSent" type="Boolean" default="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <service-call name="mantle.account.InvoiceServices.find#InvoiceProductStores" in-map="context" out-map="context"/>
            <if condition="!productStoreIdSet"><return/></if>

            <entity-find entity-name="mantle.product.store.ProductStoreEmail" list="storeEmailList">
                <date-filter/><econdition field-name="productStoreId" operator="in" from="productStoreIdSet"/>
                <econdition field-name="emailTypeEnumId"/>
            </entity-find>
            <if condition="storeEmailList">
                <set field="toPartyId" from="invoice.toPartyId"/>

                <if condition="toAddresses"><set field="toAddressesList" from="[toAddresses]"/></if>
                <!-- get to party email address -->
                <if condition="!toAddressesList">
                    <service-call name="mantle.party.ContactServices.get#PartyContactInfoList" out-map="emailInfo"
                            in-map="[partyId:toPartyId, emailContactMechPurposeId:'EmailBilling', alsoIncludePrimaryPurpose:alsoPrimaryEmails]"/>
                    <set field="toAddressesList" from="emailInfo.emailAddressList*.emailAddress"/>
                    <!-- get to party userId for toUserId -->
                    <entity-find entity-name="moqui.security.UserAccount" list="userAccountList" limit="1">
                        <econdition field-name="partyId" from="toPartyId"/></entity-find>
                    <if condition="userAccountList"><set field="toUserId" from="userAccountList[0].userId"/></if>
                </if>
                <if condition="!toAddressesList"><return/></if>

                <!-- send email for each configured -->
                <iterate list="storeEmailList" entry="storeEmail">
                    <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                        <field-map field-name="productStoreId" from="storeEmail.productStoreId"/></entity-find-one>
                    <!-- simple bodyParameters, let the screen do data prep -->
                    <set field="bodyParameters" from="[invoiceId:invoiceId, orderIdSet:orderIdSet,
                            storeDomain:productStore.storeDomain, profileUrlPath:productStore.profileUrlPath,
                            headerImagePath:storeEmail.headerImagePath, detailLinkPath:storeEmail.detailLinkPath]"/>
                    <if condition="!storeEmail.emailTemplateId"><continue/></if>

                    <iterate list="toAddressesList" entry="toAddressesCur">
                        <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" out-map="sendOut" out-map-add-to-existing="false"
                                in-map="[emailTemplateId:storeEmail.emailTemplateId, emailTypeEnumId:emailTypeEnumId,
                                    toAddresses:toAddressesCur, bodyParameters:bodyParameters, toUserId:toUserId]"/>
                        <if condition="sendOut.emailMessageId"><script><![CDATA[
                            ec.service.sync().name("create#mantle.account.invoice.InvoiceEmailMessage")
                                .parameter("invoiceId", invoiceId).parameter("emailMessageId", sendOut.emailMessageId).disableAuthz().call()
                            if (setFinalizedInvoiceSent && invoice.statusId == 'InvoiceFinalized') {
                                ec.service.sync().name("update#mantle.account.invoice.Invoice")
                                    .parameter("invoiceId", invoiceId).parameter("statusId", "InvoiceSent").disableAuthz().call()
                                // only try to change status once
                                setFinalizedInvoiceSent = false
                            }
                        ]]></script></if>
                        <message>Email sent to ${toAddressesCur}${sendOut.emailMessageId ? ', message ID ' + sendOut.emailMessageId : ''}</message>
                    </iterate>
                </iterate>
            </if>
        </actions>
    </service>

    <service verb="send" noun="SalesInvoicePastDueEmails" authenticate="anonymous-all" transaction-timeout="3600">
        <description>Send reminder emails for past due invoices. Meant to be called through a scheduled job running once a week (such as on Monday) or daily.</description>
        <in-parameters>
            <parameter name="daysPastDue" type="Long" default="7"/>
            <parameter name="daysPastInvoice" type="Long" default="40"/>
            <parameter name="daysLastEmail" type="Long" default="2"/>
            <parameter name="organizationPartyIdList" type="List"><parameter name="organizationPartyId"/></parameter>
            <parameter name="alsoPrimaryEmails" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <set field="nowZdt" from="java.time.ZonedDateTime.ofInstant(java.time.Instant.now(), java.time.ZoneId.systemDefault())"/>
            <set field="dueLookBack" from="java.sql.Timestamp.from(nowZdt.minusDays(daysPastDue).toInstant())"/>
            <set field="invoiceLookBack" from="java.sql.Timestamp.from(nowZdt.minusDays(daysPastInvoice).toInstant())"/>

            <if condition="!organizationPartyIdList">
                <entity-find entity-name="mantle.party.PartyRole" list="orgPartyRoleList">
                    <econdition field-name="roleTypeId" value="OrgInternal"/></entity-find>
                <set field="organizationPartyIdList" from="orgPartyRoleList*.partyId"/>
            </if>
            <if condition="!organizationPartyIdList"><return message="No internal organizations specified or found, not sending Sales Invoice past due emails"/></if>

            <!-- do a query for each organizationPartyId to simplify and handle larger data a bit better -->
            <iterate list="organizationPartyIdList" entry="organizationPartyId">
                <entity-find entity-name="mantle.account.invoice.Invoice" list="invoiceToPtyList" distinct="true">
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="toPartyId" operator="is-not-null"/>
                    <econdition field-name="unpaidTotal" operator="greater" from="0.0"/>
                    <econdition field-name="statusId" operator="not-in" value="InvoiceInProcess,InvoiceWriteOff,InvoiceCancelled"/>
                    <econditions combine="or">
                        <econdition field-name="dueDate" operator="less" from="dueLookBack"/>
                        <econdition field-name="invoiceDate" operator="less" from="invoiceLookBack"/>
                    </econditions>
                    <select-field field-name="toPartyId"/>
                    <order-by field-name="toPartyId"/>
                </entity-find>

                <log message="In send#SalesInvoicePastDueEmails for org ${organizationPartyId} found ${invoiceToPtyList.size()} customers with past due invoices"/>
                <iterate list="invoiceToPtyList" entry="invoiceToPty">
                    <service-call name="mantle.account.InvoiceServices.send#CustomerPastDueEmail"
                            in-map="[fromPartyId:organizationPartyId, toPartyId:invoiceToPty.toPartyId, alsoPrimaryEmails:alsoPrimaryEmails,
                                daysPastDue:daysPastDue, daysPastInvoice:daysPastInvoice, daysLastEmail:daysLastEmail]"/>
                </iterate>
            </iterate>
        </actions>
    </service>
    <service verb="send" noun="CustomerPastDueEmail">
        <in-parameters>
            <parameter name="fromPartyId" required="true"/>
            <parameter name="toPartyId" required="true"/>
            <parameter name="daysPastDue" type="Long" default="7"/>
            <parameter name="daysPastInvoice" type="Long" default="40"/>
            <parameter name="daysLastEmail" type="Long" default="2"/>
            <parameter name="alsoPrimaryEmails" type="Boolean" default="false"/>
            <parameter name="toAddresses"><text-email/></parameter>
            <parameter name="emailTypeEnumId" default-value="PsetInvoicesPastDue"/>
        </in-parameters>
        <actions>
            <set field="nowZdt" from="java.time.ZonedDateTime.ofInstant(java.time.Instant.now(), java.time.ZoneId.systemDefault())"/>
            <set field="dueLookBack" from="java.sql.Timestamp.from(nowZdt.minusDays(daysPastDue).toInstant())"/>
            <set field="invoiceLookBack" from="java.sql.Timestamp.from(nowZdt.minusDays(daysPastInvoice).toInstant())"/>

            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toParty">
                <field-map field-name="partyId" from="toPartyId"/></entity-find-one>

            <if condition="toAddresses"><set field="toAddressesList" from="[toAddresses]"/></if>
            <if condition="!toAddressesList">
                <!-- see if customer has a EmailBilling address, or if also primary then look for EmailPrimary too -->
                <service-call name="mantle.party.ContactServices.get#PartyContactInfoList" out-map="emailInfo"
                        in-map="[partyId:toPartyId, emailContactMechPurposeId:'EmailBilling', alsoIncludePrimaryPurpose:alsoPrimaryEmails]"/>
                <set field="toAddressesList" from="emailInfo.emailAddressList*.emailAddress"/>
                <!-- get to party userId for toUserId -->
                <entity-find entity-name="moqui.security.UserAccount" list="userAccountList" limit="1">
                    <econdition field-name="partyId" from="toPartyId"/></entity-find>
                <if condition="userAccountList"><set field="toUserId" from="userAccountList[0].userId"/></if>
            </if>

            <if condition="!toAddressesList">
                <return type="warning" message="No billing email address found for customer party ${toPartyId}, not sending invoices past due email"/>
            </if>

            <!-- unpaid invoices past due -->
            <entity-find entity-name="mantle.account.invoice.Invoice" list="invoiceList">
                <econdition field-name="fromPartyId" from="fromPartyId"/>
                <econdition field-name="toPartyId" from="toPartyId"/>
                <econdition field-name="unpaidTotal" operator="greater" from="0.0"/>
                <econdition field-name="statusId" operator="not-in" value="InvoiceInProcess,InvoiceWriteOff,InvoiceCancelled"/>
                <econditions combine="or">
                    <econdition field-name="dueDate" operator="less" from="dueLookBack"/>
                    <econdition field-name="invoiceDate" operator="less" from="invoiceLookBack"/>
                </econditions>
                <order-by field-name="invoiceDate"/>
            </entity-find>
            <if condition="!invoiceList">
                <return type="warning" message="No past due invoices found for customer ${toPartyId} and org ${fromPartyId} with due before ${dueLookBack} or invoice before ${invoiceLookBack}, not sending past due invoices email"/>
            </if>
            <set field="unpaidInvoiceTotal" from="invoiceList.collect({ it.unpaidTotal }).sum()"/>

            <!-- unapplied payments, will they cover unpaid invoices past due? -->
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <!-- payments with reverse parties from invoice -->
                <econdition field-name="fromPartyId" from="toPartyId"/>
                <econdition field-name="toPartyId" from="fromPartyId"/>
                <econdition field-name="unappliedTotal" operator="greater" from="0.0"/>
                <econdition field-name="statusId" operator="in" value="PmntDelivered,PmntConfirmed"/>
                <order-by field-name="effectiveDate"/>
            </entity-find>
            <set field="unappliedPaymentTotal" from="paymentList ? paymentList.collect({ it.unappliedTotal }).sum() : 0.0"/>

            <!-- unapplied reverse (credit memo, etc) invoices, will they cover unpaid invoices past due? -->
            <entity-find entity-name="mantle.account.invoice.Invoice" list="creditInvoiceList">
                <!-- credit invoices with reverse parties from invoice -->
                <econdition field-name="fromPartyId" from="toPartyId"/>
                <econdition field-name="toPartyId" from="fromPartyId"/>
                <econdition field-name="unpaidTotal" operator="greater" from="0.0"/>
                <econdition field-name="statusId" operator="not-in" value="InvoiceIncoming,InvoiceReceived,InvoiceCancelled"/>
                <order-by field-name="invoiceDate"/>
            </entity-find>
            <set field="creditInvoiceTotal" from="creditInvoiceList ? creditInvoiceList.collect({ it.unpaidTotal }).sum() : 0.0"/>

            <if condition="(unappliedPaymentTotal + creditInvoiceTotal) &gt;= unpaidInvoiceTotal">
                <return type="warning" message="Unapplied payments total ${unappliedPaymentTotal} plus credit invoice total ${creditInvoiceTotal} covers past due invoices total ${unpaidInvoiceTotal} for customer ${toPartyId} and org ${fromPartyId}, not sending past due invoices email"/>
            </if>

            <!-- sanity check: look to see if any invoice has past due email that was sent in last 2 days -->
            <if condition="daysLastEmail">
                <set field="sanityLookBack" from="java.sql.Timestamp.from(nowZdt.minusDays(daysLastEmail).toInstant())"/>
                <entity-find-count entity-name="mantle.account.invoice.InvoiceEmailMessageDetail" count-field="recentEmailCount">
                    <econdition field-name="invoiceId" operator="in" from="invoiceList*.invoiceId"/>
                    <econdition field-name="sentDate" operator="greater" from="sanityLookBack"/>
                    <econdition field-name="statusId" operator="in" value="ES_SENT,ES_RECEIVED,ES_VIEWED"/>
                </entity-find-count>
                <if condition="recentEmailCount">
                    <return type="warning" message="Found ${recentEmailCount} past due emails sent in last ${daysLastEmail} days for one or more of current past due invoices, not sending past due email for customer ${toPartyId} and org ${fromPartyId}"/>
                </if>
            </if>

            <!-- get ProductStore for settings for each invoice, if multiple split invoices by productStoreId and send email for each -->
            <set field="invoicesByStoreId" from="[:]"/>
            <iterate list="invoiceList" entry="invoice">
                <service-call name="mantle.account.InvoiceServices.find#InvoiceProductStores" out-map="findStoreOut" out-map-add-to-existing="false"
                        in-map="[invoiceId:invoice.invoiceId, invoice:invoice]"/>
                <if condition="findStoreOut.productStoreIdSet"><then>
                    <set field="curProductStoreId" from="findStoreOut.productStoreIdSet.first()"/>
                    <script>addToListInMap(curProductStoreId, invoice, invoicesByStoreId)</script>
                </then><else>
                    <message type="warning">Not sending past due email for invoice ${invoice.invoiceId}, no Product Store found for email configuration</message>
                </else></if>
            </iterate>
            
            <!-- send email for each list of invoices for each store -->
            <iterate list="invoicesByStoreId" key="productStoreId" entry="storeInvoiceList">
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                    <field-map field-name="productStoreId"/></entity-find-one>
                <entity-find entity-name="mantle.product.store.ProductStoreEmail" list="storeEmailList">
                    <date-filter/><econdition field-name="productStoreId"/>
                    <econdition field-name="emailTypeEnumId"/>
                </entity-find>
                <!-- send email for each configured -->
                <iterate list="storeEmailList" entry="storeEmail">
                    <if condition="!storeEmail.emailTemplateId"><continue/></if>

                    <!-- bodyParameters from what we have already, screen may do additional data prep -->
                    <set field="bodyParameters" from="[fromPartyId:fromPartyId, toParty:toParty,
                            invoiceList:storeInvoiceList, unpaidInvoiceTotal:unpaidInvoiceTotal,
                            paymentList:paymentList, unappliedPaymentTotal:unappliedPaymentTotal,
                            creditInvoiceList:creditInvoiceList, creditInvoiceTotal:creditInvoiceTotal,
                            storeDomain:productStore.storeDomain, profileUrlPath:productStore.profileUrlPath,
                            headerImagePath:storeEmail.headerImagePath, detailLinkPath:storeEmail.detailLinkPath]"/>

                    <iterate list="toAddressesList" entry="toAddressesCur">
                        <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" out-map="sendOut" out-map-add-to-existing="false"
                                in-map="[emailTemplateId:storeEmail.emailTemplateId, emailTypeEnumId:emailTypeEnumId,
                                toAddresses:toAddressesCur, bodyParameters:bodyParameters, toUserId:toUserId]"/>

                        <!-- add InvoiceEmailMessage record for each invoice -->
                        <if condition="sendOut.emailMessageId"><script><![CDATA[
                            for (curInvoice in storeInvoiceList) {
                                ec.service.sync().name("create#mantle.account.invoice.InvoiceEmailMessage")
                                        .parameter("invoiceId", curInvoice.invoiceId)
                                        .parameter("emailMessageId", sendOut.emailMessageId).disableAuthz().call()
                            }
                        ]]></script></if>
                        <message>Email sent to ${toAddressesCur}${sendOut.emailMessageId ? ', message ID ' + sendOut.emailMessageId : ''}</message>
                    </iterate>
                </iterate>
            </iterate>
        </actions>
    </service>


    <!-- ============================================== -->
    <!-- ========== Invoice Content Services ========== -->
    <!-- ============================================== -->

    <service verb="get" noun="InvoiceContentLocation">
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="contentTypeEnumIdList" type="List" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="contentLocation"/>
            <parameter name="invoiceContent"/>
        </out-parameters>
        <actions>
            <iterate list="contentTypeEnumIdList" entry="contentTypeEnumId">
                <entity-find entity-name="mantle.account.invoice.InvoiceContent" list="invoiceContentList">
                    <econdition field-name="invoiceId"/><econdition field-name="contentTypeEnumId"/>
                    <order-by field-name="-contentDate"/></entity-find>
                <if condition="invoiceContentList">
                    <set field="invoiceContent" from="invoiceContentList[0]"/>
                    <break/>
                </if>
            </iterate>
            <set field="contentLocation" from="invoiceContent ? invoiceContent.contentLocation : null"/>
        </actions>
    </service>

    <service verb="create" noun="InvoiceContent">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.invoice.InvoiceContent" include="nonpk">
                <exclude field-name="contentLocation"/></auto-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
        </in-parameters>
        <out-parameters><parameter name="invoiceContentId"/></out-parameters>
        <actions>
            <service-call name="create#mantle.account.invoice.InvoiceContent" in-map="context" out-map="context"/>
            <if condition="contentFile != null &amp;&amp; contentFile.size &gt; 0">
                <service-call name="mantle.account.InvoiceServices.save#InvoiceContentFile" in-map="context"/></if>
        </actions>
    </service>
    <service verb="update" noun="InvoiceContent">
        <in-parameters>
            <parameter name="invoiceContentId" required="true"/>
            <auto-parameters entity-name="mantle.account.invoice.InvoiceContent" include="nonpk">
                <exclude field-name="contentLocation"/></auto-parameters>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
        </in-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; contentFile.size &gt; 0">
                <entity-find-one entity-name="mantle.account.invoice.InvoiceContent" value-field="invoiceContent"/>
                <service-call name="mantle.account.InvoiceServices.save#InvoiceContentFile" out-map="context"
                        in-map="context + [invoiceId:invoiceContent.invoiceId, saveContentLocation:false]"/>
            </if>
            <service-call name="update#mantle.account.invoice.InvoiceContent" in-map="context"/>
        </actions>
    </service>
    <service verb="save" noun="InvoiceContentFile">
        <in-parameters>
            <parameter name="invoiceContentId" required="true"/>
            <parameter name="invoiceId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem" required="true"/>
            <parameter name="saveContentLocation" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters><parameter name="contentLocation"/></out-parameters>
        <actions>
            <set field="filename" from="contentFile.getName()"/>
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(filename)"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>
            <set field="contentLocation" value="${contentRoot}/invoice/${invoiceId}/content_${invoiceContentId}/${filename}"/>

            <set field="docRr" from="ec.resource.getLocationReference(contentLocation)"/>
            <script>
                fileStream = contentFile.getInputStream()
                try { docRr.putStream(fileStream) } finally { fileStream.close() }
            </script>

            <if condition="saveContentLocation"><service-call name="update#mantle.account.invoice.InvoiceContent"
                    in-map="[invoiceContentId:invoiceContentId, contentLocation:contentLocation]"/></if>
        </actions>
    </service>
</services>
