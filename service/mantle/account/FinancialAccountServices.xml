<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="get" noun="StatementPrintInfo">
        <in-parameters>
            <parameter name="finAccountId" required="true"/>
            <parameter name="year"/>
            <parameter name="month"/>
            <parameter name="fromDate" type="Timestamp"/>
            <parameter name="thruDate" type="Timestamp"/>
        </in-parameters>
        <out-parameters>
            <parameter name="financialAccount" type="Map"/>
            <parameter name="ownerDetail" type="Map"/>
            <parameter name="organizationDetail" type="Map"/>
            <parameter name="financialAccountTransList" type="List"><parameter name="fat" type="Map"/></parameter>

            <parameter name="fromDate" type="Timestamp"/>
            <parameter name="thruDate" type="Timestamp"/>
            <parameter name="beginningBalance" type="BigDecimal"/>
            <parameter name="endingBalance" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount"/>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="ownerDetail">
                <field-map field-name="partyId" from="financialAccount.ownerPartyId"/></entity-find-one>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="organizationDetail">
                <field-map field-name="partyId" from="financialAccount.organizationPartyId"/></entity-find-one>

            <script><![CDATA[
                if (fromDate == null && thruDate == null && year && month) {
                    fromCal = ec.l10n.parseDateTime("${year}-${month}-01 00:00:00", "yyyy-MM-dd HH:mm:ss")
                    thruCal = fromCal.clone()
                    thruCal.add(Calendar.MONTH, 1)
                    thruCal.add(Calendar.SECOND, -1)

                    fromDate = new Timestamp(fromCal.getTimeInMillis())
                    thruDate = new Timestamp(thruCal.getTimeInMillis())
                }
            ]]></script>

            <entity-find entity-name="mantle.account.financial.FinancialAccountTrans" list="financialAccountTransList">
                <econdition field-name="finAccountId"/>
                <econdition field-name="transactionDate" operator="greater-equals" from="fromDate" ignore-if-empty="true"/>
                <econdition field-name="transactionDate" operator="less-equals" from="thruDate" ignore-if-empty="true"/>
                <order-by field-name="transactionDate"/>
            </entity-find>

            <set field="firstTrans" from="financialAccountTransList ? financialAccountTransList.first() : null"/>
            <set field="beginningBalance" from="(firstTrans?.get('postBalance') ?: 0) - (firstTrans?.get('amount') ?: 0)"/>
            <set field="lastTrans" from="financialAccountTransList ? financialAccountTransList.last() : null"/>
            <set field="endingBalance" from="lastTrans?.get('postBalance') ?: 0"/>
        </actions>
    </service>

    <!-- =============================== -->
    <!-- Financial Account CrUD Services -->
    <!-- =============================== -->

    <service verb="create" noun="FinancialAccount">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.financial.FinancialAccount" include="nonpk">
                <exclude field-name="actualBalance"/><exclude field-name="availableBalance"/>
            </auto-parameters>
            <parameter name="finAccountTypeId" required="true"/>
            <parameter name="finAccountName" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="ownerPartyId" required="true"/>
            <parameter name="statusId" default-value="FaActive"/>
            <parameter name="negativeBalanceLimit" type="BigDecimal" default="0"/>
            <parameter name="isRefundable"><description>Defaults to FinancialAccountType.isRefundable</description></parameter>
            <parameter name="currencyUomId"><description>Defaults to PartyAcctgPreference.baseCurrencyUomId for organizationPartyId.</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="finAccountId"/></out-parameters>
        <actions>
            <if condition="!isRefundable">
                <entity-find-one entity-name="mantle.account.financial.FinancialAccountType" value-field="financialAccountType"/>
                <set field="isRefundable" from="financialAccountType?.isRefundable"/>
            </if>
            <if condition="!currencyUomId">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:organizationPartyId]"/>
                <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId"/>
            </if>
            <if condition="!currencyUomId"><set field="currencyUomId" value="USD"/></if>

            <set field="actualBalance" from="0"/>
            <set field="availableBalance" from="negativeBalanceLimit"/>
            <service-call name="create#mantle.account.financial.FinancialAccount" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="FinancialAccount">
        <in-parameters>
            <parameter name="finAccountId" required="true"/>
            <auto-parameters entity-name="mantle.account.financial.FinancialAccount" include="nonpk">
                <exclude field-name="actualBalance"/><exclude field-name="availableBalance"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount"/>
            <!-- if needed adjust availableBalance -->
            <if condition="negativeBalanceLimit != financialAccount.negativeBalanceLimit">
                <set field="availableBalance" from="(financialAccount.availableBalance ?: 0.0) + (negativeBalanceLimit - financialAccount.negativeBalanceLimit)"/></if>
            <service-call name="update#mantle.account.financial.FinancialAccount" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="getOrCreate" noun="FinancialAccount">
        <in-parameters>
            <parameter name="finAccountTypeId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="ownerPartyId" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="finAccountId"/></out-parameters>
        <actions>
            <entity-find entity-name="mantle.account.financial.FinancialAccount" list="finAccountList">
                <econdition field-name="ownerPartyId"/><econdition field-name="finAccountTypeId"/></entity-find>
            <if condition="finAccountList"><then>
                <set field="finAccountId" from="finAccountList[0].finAccountId"/>
            </then><else>
                <entity-find-one entity-name="mantle.account.financial.FinancialAccountType" value-field="financialAccountType"/>
                <entity-find-one entity-name="mantle.party.PartyDetail" value-field="owner">
                    <field-map field-name="partyId" from="ownerPartyId"/></entity-find-one>
                <set field="finAccountName" value="${owner.organizationName?:''}${owner.firstName?:''}${owner.lastName ? ' ' + owner.lastName : ''} ${financialAccountType.description}"/>
                <service-call name="mantle.account.FinancialAccountServices.create#FinancialAccount"
                        in-map="context" out-map="context"/>
            </else></if>
        </actions>
    </service>

    <!-- ====================================== -->
    <!-- Authorization and Transaction Services -->
    <!-- ====================================== -->

    <service verb="calculate" noun="FinancialAccountTotals">
        <description>
            Called automatically for authorizations and transactions. Calculates totals from FinancialAccountTrans and
            FinancialAccountAuth records, records them on the FinancialAccount record and returns them.
        </description>
        <in-parameters>
            <parameter name="finAccountId"/>
            <parameter name="finAccountTransId"/>
            <parameter name="finAccountAuthId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="currencyUomId"/>
            <parameter name="actualBalance" type="BigDecimal"/>
            <parameter name="authBalance" type="BigDecimal"/>
            <parameter name="availableBalance" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <if condition="!finAccountId &amp;&amp; finAccountTransId">
                <entity-find-one entity-name="mantle.account.financial.FinancialAccountTrans" value-field="fat"/>
                <set field="finAccountId" from="fat?.finAccountId"/>
            </if>
            <if condition="!finAccountId &amp;&amp; finAccountAuthId">
                <entity-find-one entity-name="mantle.account.financial.FinancialAccountAuth" value-field="faa"/>
                <set field="finAccountId" from="faa?.finAccountId"/>
            </if>
            <if condition="!finAccountId"><return error="true" message="Cannot calculate Financial Account totals, no finAccountId passed"/></if>

            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount" for-update="true"/>
            <set field="currencyUomId" from="financialAccount.currencyUomId"/>

            <!-- View queries won't work with transaction cache (for data updated within the tx), so if active use different approach -->
            <!-- TODO: for some reason the view-entity approach to let the DB do the sum isn't working in ReturnToResponseBasicFlow tests, using full query and iterate though that won't work for lots of transactions -->
            <if condition="true || ec.transaction.isTransactionCacheActive()"><then>
                <set field="actualBalance" from="0.0"/>
                <entity-find entity-name="mantle.account.financial.FinancialAccountTrans" list="fatList">
                    <econdition field-name="finAccountId"/><select-field field-name="amount"/></entity-find>
                <iterate list="fatList" entry="fat"><set field="actualBalance" from="actualBalance + fat.amount"/></iterate>
                <!--<log level="warn" message="fatList ${fatList}"/>-->

                <set field="authBalance" from="0.0"/>
                <entity-find entity-name="mantle.account.financial.FinancialAccountAuth" list="faaList">
                    <econdition field-name="finAccountId"/>
                    <econdition field-name="expireDate" operator="greater" from="ec.user.nowTimestamp" or-null="true"/>
                    <select-field field-name="amount"/>
                </entity-find>
                <iterate list="faaList" entry="faa"><set field="authBalance" from="authBalance + faa.amount"/></iterate>
                <!--<log level="warn" message="faaList ${faaList}"/>-->
            </then><else>
                <entity-find entity-name="mantle.account.financial.FinancialAccountActualView" list="faaList">
                    <econdition field-name="finAccountId"/></entity-find>
                <set field="actualBalance" from="faaList?.first?.actualBalance ?: 0.0"/>
                <!--<log level="warn" message="faaList 1 ${faaList}"/>-->

                <entity-find entity-name="mantle.account.financial.FinancialAccountAuthView" list="faaList">
                    <econdition field-name="finAccountId"/>
                    <econdition field-name="expireDate" operator="greater" from="ec.user.nowTimestamp" or-null="true"/>
                    <select-field field-name="finAccountId"/><select-field field-name="authBalance"/>
                </entity-find>
                <set field="authBalance" from="faaList?.first?.authBalance ?: 0.0"/>
                <!--<log level="warn" message="faaList 2 ${faaList}"/>-->
            </else></if>

            <set field="availableBalance" from="actualBalance - authBalance + (financialAccount.negativeBalanceLimit ?: 0.0)"/>

            <set field="financialAccount.actualBalance" from="actualBalance"/>
            <set field="financialAccount.availableBalance" from="availableBalance"/>
            <entity-update value-field="financialAccount"/>
            <!--<log level="warn" message="actualBalance ${actualBalance} authBalance ${authBalance} availableBalance ${availableBalance}"/>-->
        </actions>
    </service>

    <service verb="adjust" noun="FinancialAccount">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.financial.FinancialAccountTrans" include="nonpk">
                <exclude field-name="finAccountTransTypeEnumId"/>
                <exclude field-name="finAccountAuthId"/>
            </auto-parameters>
            <parameter name="finAccountId" required="true"/>
            <parameter name="reasonEnumId" default-value="FatrErrorAdjust"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <!-- maybe support in the future with currency conversion: <parameter name="amountUomId"/> -->
            <!-- <parameter name="isRefund" type="Boolean" default="false"/> -->
        </in-parameters>
        <out-parameters>
            <parameter name="amount" type="BigDecimal"/>
            <parameter name="preBalance" type="BigDecimal"/>
            <parameter name="postBalance" type="BigDecimal"/>
            <parameter name="finAccountTransId"/>
        </out-parameters>
        <actions>
            <set field="amount" from="amount.setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            <set field="performedByUserId" from="ec.user.userId"/>

            <!-- do a for-update query to lock the FinancialAccount record -->
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount"
                    for-update="true"/>
            <set field="preBalance" from="financialAccount.actualBalance ?: 0"/>

            <set field="postBalance" from="preBalance + amount"/>
            <set field="finAccountTransTypeEnumId" value="FattAdjustment"/>
            <service-call name="create#mantle.account.financial.FinancialAccountTrans" in-map="context" out-map="context"/>

            <service-call name="mantle.account.FinancialAccountServices.calculate#FinancialAccountTotals"
                    in-map="[finAccountId:finAccountId]" out-map="totalsOut"/>
            <set field="postBalance" from="totalsOut.actualBalance"/>
            <set field="differAmount" from="postBalance - preBalance"/>
            <if condition="differAmount != amount">
                <return error="true" message="Error adjusting financial account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}, pre balance ${preBalance} and post balance ${postBalance} differ by ${differAmount} and not by transaction amount ${amount}"/></if>
        </actions>
    </service>

    <service verb="deposit" noun="FinancialAccount">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.financial.FinancialAccountTrans" include="nonpk">
                <exclude field-name="finAccountTransTypeEnumId"/><exclude field-name="finAccountAuthId"/></auto-parameters>
            <parameter name="finAccountId" required="true"/>
            <parameter name="reasonEnumId" default-value="FatrReplenish"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <!-- maybe support in the future with currency conversion: <parameter name="amountUomId"/> -->
            <!-- <parameter name="isRefund" type="Boolean" default="false"/> -->
        </in-parameters>
        <out-parameters>
            <parameter name="amount" type="BigDecimal"/>
            <parameter name="preBalance" type="BigDecimal"/>
            <parameter name="postBalance" type="BigDecimal"/>
            <parameter name="finAccountTransId"/>
        </out-parameters>
        <actions>
            <if condition="amount &lt; 0.0"><return error="true" message="Cannot deposit negative amount ${amount}, do a withdraw instead"/></if>

            <set field="amount" from="amount.setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            <set field="performedByUserId" from="ec.user.userId"/>

            <!-- do a for-update query to lock the FinancialAccount record -->
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount" for-update="true"/>
            <set field="preBalance" from="financialAccount.actualBalance ?: 0"/>

            <if condition="!fromPartyId"><set field="fromPartyId" from="financialAccount.organizationPartyId"/></if>
            <if condition="!toPartyId"><set field="toPartyId" from="financialAccount.ownerPartyId"/></if>

            <set field="postBalance" from="preBalance + amount"/>
            <set field="finAccountTransTypeEnumId" value="FattDeposit"/>
            <service-call name="create#mantle.account.financial.FinancialAccountTrans" in-map="context" out-map="context"/>

            <service-call name="mantle.account.FinancialAccountServices.calculate#FinancialAccountTotals"
                    in-map="[finAccountId:finAccountId]" out-map="totalsOut"/>
            <set field="postBalance" from="totalsOut.actualBalance"/>
            <set field="differAmount" from="postBalance - preBalance"/>
            <if condition="differAmount != amount">
                <return error="true" message="Error adjusting financial account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}, pre balance ${preBalance} and post balance ${postBalance} differ by ${differAmount} and not by transaction amount ${amount}"/></if>
        </actions>
    </service>
    <service verb="withdraw" noun="FinancialAccount">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.financial.FinancialAccountTrans" include="nonpk">
                <exclude field-name="finAccountTransTypeEnumId"/></auto-parameters>
            <parameter name="finAccountId" required="true"/>
            <parameter name="reasonEnumId" default-value="FatrDisbursement"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <!-- maybe support in the future with currency conversion: <parameter name="amountUomId"/> -->
            <!-- <parameter name="isRefund" type="Boolean" default="false"/> -->
        </in-parameters>
        <out-parameters>
            <parameter name="amount" type="BigDecimal"/>
            <parameter name="preBalance" type="BigDecimal"/>
            <parameter name="postBalance" type="BigDecimal"/>
            <parameter name="finAccountTransId"/>
            <parameter name="responseCode"><description>May be 'success' or 'nsf'</description></parameter>
            <parameter name="responseMessage"/>
        </out-parameters>
        <actions>
            <if condition="amount &lt; 0.0"><return error="true" message="Cannot withdraw negative amount ${amount}, do a deposit instead"/></if>

            <set field="amount" from="amount.setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            <set field="performedByUserId" from="ec.user.userId"/>

            <!-- do a for-update query to lock the FinancialAccount record -->
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount" for-update="true"/>
            <set field="preBalance" from="financialAccount.actualBalance ?: 0.0"/>

            <!-- check actual balance for sufficient amount -->
            <set field="balancePlusCredit" from="preBalance + (financialAccount.negativeBalanceLimit ?: 0)"/>
            <if condition="balancePlusCredit &lt; amount">
                <set field="responseCode" value="nsf"/>
                <set field="responseMessage" value="Insufficient funds: ${ec.l10n.format(balancePlusCredit, '0.00')} can be withdrawn, withdraw amount ${ec.l10n.format(amount, '0.00')}"/>
                <return/>
            </if>

            <if condition="!fromPartyId"><set field="fromPartyId" from="financialAccount.ownerPartyId"/></if>
            <if condition="!toPartyId"><set field="toPartyId" from="financialAccount.organizationPartyId"/></if>

            <!-- this is a withdrawal, so subtract the amount -->
            <set field="amount" from="-amount"/>

            <set field="postBalance" from="preBalance + amount"/>
            <set field="finAccountTransTypeEnumId" value="FattWithdraw"/>
            <service-call name="create#mantle.account.financial.FinancialAccountTrans" in-map="context" out-map="context"/>

            <service-call name="update#mantle.account.financial.FinancialAccount"
                    in-map="[finAccountId:finAccountId, actualBalance:postBalance]"/>

            <if condition="finAccountAuthId">
                <!-- if there is an auth, expire it -->
                <service-call name="update#mantle.account.financial.FinancialAccountAuth"
                        in-map="[finAccountAuthId:finAccountAuthId, expireDate:ec.user.nowTimestamp]"/>
            </if>

            <service-call name="mantle.account.FinancialAccountServices.calculate#FinancialAccountTotals"
                    in-map="[finAccountId:finAccountId]" out-map="totalsOut"/>
            <set field="postBalance" from="totalsOut.actualBalance"/>
            <set field="differAmount" from="postBalance - preBalance"/>
            <if condition="differAmount != amount">
                <return error="true" message="Error withdrawing from financial account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}, pre balance ${preBalance} and post balance ${postBalance} differ by ${differAmount} and not by transaction amount ${amount}"/></if>

            <set field="responseCode" value="success"/>
            <set field="responseMessage" value="Withdrew ${ec.l10n.format(amount, '0.00')} from account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}"/>
        </actions>
    </service>
    <service verb="transfer" noun="FinancialAccount">
        <in-parameters>
            <parameter name="fromFinAccountId" required="true"/>
            <parameter name="toFinAccountId" required="true"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="toComments" default="comments"/>
        </in-parameters>
        <out-parameters>
            <parameter name="withdrawFinAccountTransId"/>
            <parameter name="depositFinAccountTransId"/>
        </out-parameters>
        <actions>
            <if condition="amount == 0.0"><return message="Not doing transfer, amount is zero"/></if>

            <!-- find and lock the two accounts -->
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="fromFinAccount" for-update="true">
                <field-map field-name="finAccountId" from="fromFinAccountId"/></entity-find-one>
            <if condition="fromFinAccount == null"><return error="true" message="Could not find transfer from account ${fromFinAccountId}"/></if>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="toFinAccount" for-update="true">
                <field-map field-name="finAccountId" from="toFinAccountId"/></entity-find-one>
            <if condition="toFinAccount == null"><return error="true" message="Could not find transfer to account ${toFinAccountId}"/></if>

            <!-- make sure org matches on the two FinancialAccounts -->
            <if condition="fromFinAccount.organizationPartyId != toFinAccount.organizationPartyId">
                <return error="true" message="Organization parties must match between the two accounts to do a transfer"/></if>

            <!-- withdraw from FinancialAccount -->
            <service-call name="mantle.account.FinancialAccountServices.withdraw#FinancialAccount" out-map="withdrawOut"
                    in-map="[finAccountId:fromFinAccountId, reasonEnumId:'FatrTransfer', amount:amount,
                        transactionDate:transactionDate, entryDate:entryDate, comments:comments]"/>
            <if condition="withdrawOut.responseCode != 'success'"><return error="true" message="${withdrawOut.responseMessage}"/></if>
            <set field="withdrawFinAccountTransId" from="withdrawOut.finAccountTransId"/>

            <!-- deposit to FinancialAccount -->
            <service-call name="mantle.account.FinancialAccountServices.deposit#FinancialAccount" out-map="depositOut"
                    in-map="[finAccountId:toFinAccountId, reasonEnumId:'FatrTransfer', amount:amount, transactionDate:transactionDate,
                        entryDate:entryDate, comments:toComments, otherFinAccountTransId:withdrawFinAccountTransId]"/>
            <set field="depositFinAccountTransId" from="depositOut.finAccountTransId"/>

            <!-- set otherFinAccountTransId on withdraw TX -->
            <service-call name="update#mantle.account.financial.FinancialAccountTrans"
                    in-map="[finAccountTransId:withdrawFinAccountTransId, otherFinAccountTransId:depositFinAccountTransId]"/>
        </actions>
    </service>

    <service verb="reverse" noun="FinancialAccountTrans">
        <in-parameters><parameter name="finAccountTransId"/></in-parameters>
        <out-parameters><parameter name="finAccountTransId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccountTrans" value-field="faTrans" for-update="true"/>
            <if condition="faTrans.reversedByTransId">
                <return error="true" message="Not reversing transaction ${finAccountTransId}, already reversed by transaction ${faTrans.reversedByTransId}"/></if>

            <!-- do a for-update query to lock the FinancialAccount record -->
            <set field="finAccountId" from="faTrans.finAccountId"/>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount" for-update="true"/>
            <set field="preBalance" from="financialAccount.actualBalance ?: 0.0"/>

            <!-- set reverse fields -->
            <set field="reverseMap" from="[finAccountId:faTrans.finAccountId, reasonEnumId:faTrans.reasonEnumId,
                    toPartyId:faTrans.fromPartyId, fromPartyId:faTrans.toPartyId, transactionDate:faTrans.transactionDate,
                    entryDate:ec.user.nowTimestamp, amount:(-faTrans.amount),
                    paymentId:faTrans.paymentId, invoiceId:faTrans.invoiceId, orderId:faTrans.orderId, orderItemSeqId:faTrans.orderItemSeqId,
                    performedByUserId:ec.user.userId]"/>
            <set field="reverseMap.reverseOfTransId" from="finAccountTransId"/>
            <set field="reverseMap.finAccountTransTypeEnumId" from="faTrans.finAccountTransTypeEnumId == 'FattDeposit' ? 'FattWithdraw' :
                    (faTrans.finAccountTransTypeEnumId == 'FattWithdraw' ? 'FattDeposit' : faTrans.finAccountTransTypeEnumId)"/>

            <!-- create the new transaction -->
            <service-call name="create#mantle.account.financial.FinancialAccountTrans" in-map="reverseMap" out-map="revOut"/>

            <set field="reverseTransId" from="revOut.finAccountTransId"/>
            <set field="faTrans.reversedByTransId" from="reverseTransId"/>
            <entity-update value-field="faTrans"/>

            <service-call name="mantle.account.FinancialAccountServices.calculate#FinancialAccountTotals"
                    in-map="[finAccountId:finAccountId]" out-map="totalsOut"/>
            <set field="postBalance" from="totalsOut.actualBalance"/>
            <set field="differAmount" from="postBalance - preBalance"/>
            <if condition="differAmount != reverseMap.amount">
                <return error="true" message="Error withdrawing from financial account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}, pre balance ${preBalance} and post balance ${postBalance} differ by ${differAmount} and not by transaction amount ${reverseMap.amount}"/></if>

            <!-- set the out value -->
            <set field="finAccountTransId" from="reverseTransId"/>
        </actions>
    </service>

    <service verb="authorize" noun="FinancialAccount">
        <in-parameters>
            <parameter name="finAccountId" required="true"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <parameter name="authorizationDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="paymentId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="preAvailableBalance" type="BigDecimal"/>
            <parameter name="postAvailableBalance" type="BigDecimal"/>
            <parameter name="finAccountAuthId"/>
            <parameter name="responseCode"><description>May be 'success' or 'nsf'</description></parameter>
            <parameter name="responseMessage"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount"
                    for-update="true"/>
            <set field="preAvailableBalance" from="financialAccount.availableBalance"/>

            <!-- check available balance for sufficient amount -->
            <if condition="preAvailableBalance &lt; amount">
                <set field="responseCode" value="nsf"/>
                <set field="responseMessage" value="Insufficient funds: ${ec.l10n.format(preAvailableBalance, '0.00')} available, authorize amount ${ec.l10n.format(amount, '0.00')}"/>
                <return/>
            </if>

            <set field="financialAccountType" from="financialAccount.type"/>
            <set field="authValidDays" from="(financialAccountType?.authValidDays) ?: 7"/>
            <script>
                Calendar expireCal = ec.user.nowCalendar
                expireCal.setTimeInMillis(authorizationDate.time)
                expireCal.add(Calendar.DAY_OF_MONTH, authValidDays)
                expireDate = new Timestamp(expireCal.getTimeInMillis())
            </script>
            <!-- <log message="authorizationDate=${authorizationDate}, expireDate=${expireDate}"/> -->
            <service-call name="create#mantle.account.financial.FinancialAccountAuth" in-map="context" out-map="context"/>

            <service-call name="mantle.account.FinancialAccountServices.calculate#FinancialAccountTotals"
                    in-map="[finAccountId:finAccountId]" out-map="totalsOut"/>
            <set field="postAvailableBalance" from="totalsOut.availableBalance"/>

            <set field="differAmount" from="preAvailableBalance - postAvailableBalance"/>
            <if condition="differAmount != amount">
                <return error="true" message="Error in authorization for financial account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}, pre balance ${preAvailableBalance} and post balance ${postAvailableBalance} differ by [${differAmount}] and not by auth amount ${amount}"/></if>

            <set field="responseCode" value="success"/>
            <set field="responseMessage" value="Authorized ${ec.l10n.format(amount, '0.00')} for account ${ec.resource.expand('FinancialAccountNameTemplate','',financialAccount)}"/>
        </actions>
    </service>
    <service verb="expire" noun="FinancialAccountAuth">
        <in-parameters>
            <parameter name="finAccountAuthId" required="true"/>
            <parameter name="expireDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.account.financial.FinancialAccountAuth" in-map="context"/>
        </actions>
    </service>

    <!-- ======================================== -->
    <!-- Payment and Invoice Transaction Services -->
    <!-- ======================================== -->

    <service verb="disburse" noun="FinancialAccount">
        <description>
            Disburse (withdraw) funds from a FinancialAccount through a Payment which will be in the Promised status (will need to be Delivered to post).

            By default calls the withdraw service now, set withdrawNow to false to use the checkCreate#PaymentTrans service to
            call the withdraw service when the Payment is Delivered. Note that with this approach there is no way to specify a
            reasonEnumId for the FA transaction as it is not stored on the Payment to be used later (the default of FatrDisbursement will be used).
        </description>
        <implements service="mantle.account.FinancialAccountServices.withdraw#FinancialAccount"/>
        <in-parameters>
            <parameter name="paymentInstrumentEnumId" default-value="PiCompanyCheck"/>
            <parameter name="reasonEnumId" default-value="FatrDisbursement"/>
            <parameter name="paymentMethodId"/>
            <parameter name="effectiveDate" type="Timestamp"/>
            <parameter name="withdrawNow" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="finAccountTransId"/>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount" for-update="true"/>

            <!-- create Payment first (then update after with finAccountTransId, because FinancialAccountTrans is create-only/immutable) -->
            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                    in-map="[paymentTypeEnumId:'PtFinancialAccount', statusId:'PmntPromised', comments:comments,
                        fromPartyId:financialAccount.organizationPartyId, toPartyId:financialAccount.ownerPartyId,
                        amount:amount, amountUomId:financialAccount.currencyUomId, finAccountId:finAccountId,
                        paymentInstrumentEnumId:paymentInstrumentEnumId, paymentMethodId:paymentMethodId, effectiveDate:effectiveDate]"/>

            <if condition="withdrawNow">
                <!-- withdraw from FinancialAccount -->
                <service-call name="mantle.account.FinancialAccountServices.withdraw#FinancialAccount" in-map="context" out-map="context"/>
                <if condition="responseCode != 'success'"><return error="true" message="${responseMessage}"/></if>
                <!-- update Payment record, set finAccountTransId -->
                <service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:paymentId, finAccountTransId:finAccountTransId]"/>
            </if>
        </actions>
    </service>
    <service verb="replenish" noun="FinancialAccount">
        <description>
            Replenish a FinancialAccount (deposit funds) through a Payment which will be in the Promised status (will need to be Delivered to post).

            By default calls the deposit service now, set depositNow to false to use the checkCreate#PaymentTrans service to
            call the deposit service when the Payment is Delivered. Note that with this approach there is no way to specify a
            reasonEnumId for the FA transaction as it is not stored on the Payment to be used later (the default of FatrReplenish will be used).
        </description>
        <implements service="mantle.account.FinancialAccountServices.deposit#FinancialAccount"/>
        <in-parameters>
            <parameter name="paymentInstrumentEnumId" required="true"/>
            <parameter name="reasonEnumId" default-value="FatrReplenish"/>
            <parameter name="paymentMethodId"/>
            <parameter name="effectiveDate" type="Timestamp"/>
            <parameter name="depositNow" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="finAccountTransId"/>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount" for-update="true"/>

            <!-- create Payment first (then update after with finAccountTransId, because FinancialAccountTrans is create-only/immutable) -->
            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                    in-map="[paymentTypeEnumId:'PtFinancialAccount', statusId:'PmntPromised', comments:comments,
                        fromPartyId:financialAccount.ownerPartyId, toPartyId:financialAccount.organizationPartyId,
                        amount:amount, amountUomId:financialAccount.currencyUomId, finAccountId:finAccountId,
                        paymentInstrumentEnumId:paymentInstrumentEnumId, paymentMethodId:paymentMethodId, effectiveDate:effectiveDate]"/>

            <if condition="depositNow">
                <!-- deposit to FinancialAccount -->
                <service-call name="mantle.account.FinancialAccountServices.deposit#FinancialAccount" in-map="context" out-map="context"/>
                <!-- update Payment record, set finAccountTransId -->
                <service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:paymentId, finAccountTransId:finAccountTransId]"/>
            </if>
        </actions>
    </service>

    <service verb="checkCreate" noun="InvoiceTransactions">
        <description>Called by SECA rule on Invoice statusId change to InvoiceFinalized (receivable) or  InvoiceApproved (payable).
            Calls checkCreate#InvoiceItemTrans for each InvoiceItem with finAccountId populated.</description>
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <actions>
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="faItemList">
                <econdition field-name="invoiceId"/><econdition field-name="finAccountId" operator="is-not-null"/></entity-find>
            <iterate list="faItemList" entry="faItem">
                <service-call name="mantle.account.FinancialAccountServices.checkCreate#InvoiceItemTrans"
                        in-map="[invoiceId:faItem.invoiceId, invoiceItemSeqId:faItem.invoiceItemSeqId]"/>
            </iterate>
        </actions>
    </service>
    <service verb="checkCreate" noun="InvoiceItemTrans">
        <description>If the InvoiceItem has a finAccountId but no finAccountTransId create a deposit or withdrawal and populate InvoiceItem.finAccountTransId</description>
        <in-parameters>
            <parameter name="invoiceId" required="true"/>
            <parameter name="invoiceItemSeqId" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="finAccountTransId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.invoice.InvoiceItem" value-field="invoiceItem" for-update="true"/>
            <set field="finAccountId" from="invoiceItem.finAccountId"/>
            <if condition="!finAccountId"><return/></if>
            <set field="amount" from="(invoiceItem.quantity != null ? invoiceItem.quantity : 1.0) * (invoiceItem.amount ?: 0.0)"/>
            <if condition="!amount"><return/></if>
            <if condition="invoiceItem.finAccountTransId">
                <set field="finAccountTransId" from="invoiceItem.finAccountTransId"/>
                <return/>
            </if>

            <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="invoice"/>
            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount"/>
            <!-- is this a deposit, withdrawal, or invalid  -->
            <set field="organizationPartyId" from="financialAccount.organizationPartyId"/>
            <set field="ownerPartyId" from="financialAccount.ownerPartyId"/>
            <set field="fromPartyId" from="invoice.fromPartyId"/>
            <set field="toPartyId" from="invoice.toPartyId"/>
            <if condition="organizationPartyId != fromPartyId &amp;&amp; organizationPartyId != toPartyId">
                <message error="true">Financial Account organization ${organizationPartyId} is not a party to invoice ${invoiceId}</message></if>
            <if condition="ownerPartyId != fromPartyId &amp;&amp; ownerPartyId != toPartyId">
                <message error="true">Financial Account owner ${ownerPartyId} is not a party to invoice ${invoiceId}</message></if>
            <check-errors/>

            <!-- invoice from org is receivable, settled on the ITEM level by deposit to fin account in exchange for part/all of corresponding payment -->
            <!-- note that this is the opposite of the invoice level, for example funds flow from payment to invoice to invoice item (as FA trans) -->
            <set field="isDeposit" from="organizationPartyId == fromPartyId"/>
            <!-- unless the amount is negative on the InvoiceItem, then it is withdrawn (or a deposit for payable invoices) -->
            <if condition="amount &lt; 0.0">
                <set field="isDeposit" from="!isDeposit"/>
                <set field="amount" from="-amount"/>
            </if>

            <if condition="isDeposit"><then>
                <service-call name="mantle.account.FinancialAccountServices.deposit#FinancialAccount" out-map="txOut"
                        in-map="[finAccountId:finAccountId, amount:amount, transactionDate:invoice.invoiceDate, invoiceId:invoiceId]"/>
            </then><else>
                <service-call name="mantle.account.FinancialAccountServices.withdraw#FinancialAccount" out-map="txOut"
                        in-map="[finAccountId:finAccountId, amount:amount, transactionDate:invoice.invoiceDate, invoiceId:invoiceId]"/>
            </else></if>

            <set field="finAccountTransId" from="txOut.finAccountTransId"/>
            <set field="invoiceItem.finAccountTransId" from="finAccountTransId"/>
            <entity-update value-field="invoiceItem"/>

            <!-- TODO: adjust InvoiceItem GL posting to post to Financial Account In Transit account (deposit or withdraw)
                instead of to account configured for item type, maybe do here with InvoiceItem.overrideGlAccountId and then
                make sure this runs before the GL posting? -->
        </actions>
    </service>
    <service verb="reverse" noun="InvoiceTransactions">
        <description>Called by SECA rule on Invoice statusId change to cancel or resume changes.
            Calls reverse#FinancialAccountTrans for each InvoiceItem with finAccountTransId populated.</description>
        <in-parameters><parameter name="invoiceId" required="true"/></in-parameters>
        <actions>
            <entity-find entity-name="mantle.account.invoice.InvoiceItem" list="faItemList">
                <econdition field-name="invoiceId"/><econdition field-name="finAccountTransId" operator="is-not-null"/></entity-find>
            <iterate list="faItemList" entry="faItem">
                <service-call name="mantle.account.FinancialAccountServices.reverse#FinancialAccountTrans"
                        in-map="[finAccountTransId:faItem.finAccountTransId]"/>
            </iterate>
        </actions>
    </service>

    <service verb="checkCreate" noun="PaymentTrans">
        <description>
            If the Payment has a finAccountId but no finAccountTransId create a deposit or withdrawal and populate Payment.finAccountTransId.

            This is meant for two scenarios:
            1. paymentTypeEnumId == 'PtFinancialAccount': should have a payment instrument/method that is not FinancialAccount to represent transfer of funds to/from the FA account via the payment (deposit for incoming, withdraw for outgoing)
            2. paymentTypeEnumId != 'PtFinancialAccount' AND paymentInstrumentEnumId == 'PiFinancialAccount' then it is a payment for invoice/etc paid via FinancialAccount (withdraw for incoming, deposit for outgoing)
        </description>
        <in-parameters>
            <parameter name="paymentId" required="true"/>
            <parameter name="reasonEnumId"/>
        </in-parameters>
        <out-parameters><parameter name="finAccountTransId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/>
            <set field="finAccountId" from="payment.finAccountId"/>
            <if condition="!finAccountId"><return/></if>
            <set field="amount" from="payment.amount"/>
            <if condition="!amount"><return/></if>
            <if condition="payment.finAccountTransId">
                <set field="finAccountTransId" from="payment.finAccountTransId"/>
                <return/>
            </if>
            <if condition="payment.statusId in ['PmntProposed', 'PmntPromised', 'PmntCancelled', 'PmntVoid', 'PmntDeclined']">
                <return message="Not creating Financial Account transaction for Payment ${paymentId} in status ${payment.status?.description}, must be Authorized or Delivered"/></if>

            <entity-find-one entity-name="mantle.account.financial.FinancialAccount" value-field="financialAccount"/>
            <!-- is this a deposit, withdrawal, or invalid  -->
            <set field="organizationPartyId" from="financialAccount.organizationPartyId"/>
            <set field="ownerPartyId" from="financialAccount.ownerPartyId"/>
            <set field="fromPartyId" from="payment.fromPartyId"/>
            <set field="toPartyId" from="payment.toPartyId"/>
            <if condition="organizationPartyId != fromPartyId &amp;&amp; organizationPartyId != toPartyId">
                <message error="true">Financial Account organization ${organizationPartyId} is not a party to payment ${paymentId}</message></if>
            <if condition="ownerPartyId != fromPartyId &amp;&amp; ownerPartyId != toPartyId">
                <message error="true">Financial Account owner ${ownerPartyId} is not a party to payment ${paymentId}</message></if>
            <check-errors/>

            <if condition="payment.paymentTypeEnumId == 'PtFinancialAccount'"><then>
                <!-- payment represents a transfer of funds from the payment instrument/method to the finAccountId -->
                <set field="isDeposit" from="organizationPartyId == toPartyId"/>
            </then><else-if condition="payment.paymentInstrumentEnumId == 'PiFinancialAccount'">
                <!-- payment represents a payment via finAccountId -->
                <!-- other party (non org) owns the FA, so: from org to owner (deposit); from owner to org (withdraw) -->
                <!-- payment to org is incoming payment (for receivable), settled by withdraw from fin account in exchange for part/all of corresponding payment -->
                <set field="isDeposit" from="organizationPartyId == fromPartyId"/>
            </else-if><else>
                <return message="Payment has a Financial Account ID but is not a Financial Account type payment OR some other type of payment with a Financial Account payment instrument, so not creating financial account transaction"/>
            </else></if>
            <!-- unless the amount is negative on the Payment, then it is withdrawn (or a deposit for payable invoices) -->
            <if condition="amount &lt; 0.0">
                <set field="isDeposit" from="!isDeposit"/>
                <set field="amount" from="-amount"/>
            </if>

            <if condition="isDeposit"><then>
                <service-call name="mantle.account.FinancialAccountServices.deposit#FinancialAccount" out-map="txOut"
                        in-map="[finAccountId:finAccountId, amount:amount, transactionDate:payment.effectiveDate,
                            paymentId:paymentId, reasonEnumId:(reasonEnumId ?: 'FatrReplenish')]"/>
            </then><else>
                <service-call name="mantle.account.FinancialAccountServices.withdraw#FinancialAccount" out-map="txOut"
                        in-map="[finAccountId:finAccountId, amount:amount, transactionDate:payment.effectiveDate,
                            paymentId:paymentId, reasonEnumId:(reasonEnumId ?: 'FatrDisbursement')]"/>
            </else></if>

            <set field="finAccountTransId" from="txOut.finAccountTransId"/>
            <set field="payment.finAccountTransId" from="finAccountTransId"/>
            <entity-update value-field="payment"/>

            <!-- if status Authorized now consider Delivered; make sure finAccountTransId set first so not redone from SECA rule -->
            <if condition="payment.statusId == 'PmntAuthorized'">
                <service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:paymentId, statusId:'PmntDelivered']"/></if>

            <!-- TODO: adjust Payment GL posting to post to Financial Account In Transit account (deposit or withdraw)
                instead of to account configured for item type, maybe do here with Payment.overrideGlAccountId and then
                make sure this runs before the GL posting? -->
        </actions>
    </service>
    <service verb="reverse" noun="PaymentTrans">
        <description>If the Payment has a finAccountId but no finAccountTransId create a deposit or withdrawal and populate Payment.finAccountTransId</description>
        <in-parameters><parameter name="paymentId" required="true"/></in-parameters>
        <out-parameters><parameter name="finAccountTransId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/>
            <if condition="!payment.finAccountTransId"><return/></if>
            <service-call name="mantle.account.FinancialAccountServices.reverse#FinancialAccountTrans"
                    in-map="[finAccountTransId:payment.finAccountTransId]"/>
        </actions>
    </service>

    <!-- ============================================= -->
    <!-- Financial Account Payment Processing Services -->
    <!-- ============================================= -->

    <service verb="authorize" noun="FinancialAccountPayment">
        <implements service="mantle.account.PaymentServices.authorize#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/>
            <set field="finAccountId" from="payment.finAccountId"/>
            <if condition="!finAccountId &amp;&amp; payment.paymentMethodId">
                <!-- if there is a FinancialAccount PaymentMethod, use that -->
                <set field="paymentMethod" from="payment.method"/>
                <set field="finAccountId" from="paymentMethod.finAccountId"/>
            </if>
            <if condition="!finAccountId"><return error="true" message="No Financial Account associated with Payment ${payment.paymentId}"/></if>

            <if condition="!amount"><set field="amount" from="payment.amount"/></if>

            <service-call name="mantle.account.FinancialAccountServices.authorize#FinancialAccount" out-map="authOut"
                    in-map="[finAccountId:finAccountId, amount:amount, paymentId:paymentId]"/>

            <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context"
                    in-map="[paymentGatewayConfigId:paymentGatewayConfigId, paymentOperationEnumId:'PgoAuthorize',
                        paymentId:paymentId, paymentMethodId:payment.paymentMethodId, finAccountId:finAccountId,
                        amount:amount, amountUomId:payment.amountUomId,
                        referenceNum:authOut.finAccountAuthId, approvalCode:authOut.finAccountAuthId,
                        responseCode:authOut.responseCode, reasonCode:null, reasonMessage:authOut.responseMessage,
                        transactionDate:ec.user.nowTimestamp,
                        resultSuccess:(authOut.responseCode == 'success' ? 'Y' : 'N'),
                        resultDeclined:(authOut.responseCode == 'success' ? 'N' : 'Y'),
                        resultError:'N',
                        resultNsf:(authOut.responseCode == 'nsf' ? 'Y' : 'N')]"/>

            <if condition="authOut.finAccountAuthId">
                <set field="payment.finAccountAuthId" from="authOut.finAccountAuthId"/>
                <entity-update value-field="payment"/>
            </if>
        </actions>
    </service>
    <service verb="capture" noun="FinancialAccountPayment">
        <implements service="mantle.account.PaymentServices.capture#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/>
            <set field="finAccountId" from="payment.finAccountId"/>
            <if condition="!finAccountId &amp;&amp; payment.paymentMethodId">
                <!-- if there is a FinancialAccount PaymentMethod, use that -->
                <set field="paymentMethod" from="payment.method"/>
                <set field="finAccountId" from="paymentMethod.finAccountId"/>
            </if>
            <if condition="!finAccountId"><return error="true" message="No Financial Account associated with Payment ${payment.paymentId}"/></if>

            <if condition="!amount"><set field="amount" from="payment.amount"/></if>

            <service-call name="mantle.account.FinancialAccountServices.withdraw#FinancialAccount" out-map="wdOut"
                    in-map="[finAccountId:finAccountId, amount:amount, finAccountAuthId:payment.finAccountAuthId, paymentId:paymentId]"/>

            <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context"
                    in-map="[paymentGatewayConfigId:paymentGatewayConfigId, paymentOperationEnumId:'PgoCapture',
                        paymentId:paymentId, paymentMethodId:payment.paymentMethodId, finAccountId:finAccountId,
                        amount:amount, amountUomId:payment.amountUomId,
                        referenceNum:wdOut.finAccountTransId, approvalCode:wdOut.finAccountTransId,
                        responseCode:wdOut.responseCode, reasonCode:null, reasonMessage:wdOut.responseMessage,
                        transactionDate:ec.user.nowTimestamp,
                        resultSuccess:(wdOut.responseCode == 'success' ? 'Y' : 'N'),
                        resultDeclined:(wdOut.responseCode == 'success' ? 'N' : 'Y'),
                        resultError:'N',
                        resultNsf:(wdOut.responseCode == 'nsf' ? 'Y' : 'N')]"/>

            <if condition="wdOut.finAccountTransId">
                <set field="payment.finAccountTransId" from="wdOut.finAccountTransId"/>
                <entity-update value-field="payment"/>
            </if>
        </actions>
    </service>
    <service verb="release" noun="FinancialAccountPayment">
        <implements service="mantle.account.PaymentServices.release#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/>
            <if condition="!payment.finAccountAuthId"><return error="true" message="No authorization associated with Payment ${payment.paymentId}"/></if>

            <service-call name="mantle.account.FinancialAccountServices.expire#FinancialAccountAuth" out-map="wdOut"
                    in-map="[finAccountAuthId:payment.finAccountAuthId]"/>

            <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context"
                    in-map="[paymentGatewayConfigId:paymentGatewayConfigId, paymentOperationEnumId:'PgoRelease',
                        paymentId:paymentId, paymentMethodId:payment.paymentMethodId, finAccountId:finAccountId,
                        amount:payment.amount, amountUomId:payment.amountUomId,
                        transactionDate:ec.user.nowTimestamp,
                        resultSuccess:'Y', resultDeclined:'N', resultError:'N', resultNsf:'N']"/>

            <set field="payment.finAccountAuthId" from="null"/>
            <entity-update value-field="payment"/>
        </actions>
    </service>
    <service verb="refund" noun="FinancialAccountPayment">
        <implements service="mantle.account.PaymentServices.refund#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/>
            <set field="finAccountId" from="payment.finAccountId"/>
            <if condition="!finAccountId &amp;&amp; payment.paymentMethodId">
                <!-- if there is a FinancialAccount PaymentMethod, use that -->
                <set field="paymentMethod" from="payment.method"/>
                <set field="finAccountId" from="paymentMethod.finAccountId"/>
            </if>
            <if condition="!finAccountId"><return error="true" message="No Financial Account associated with Payment ${payment.paymentId}"/></if>

            <if condition="!amount"><set field="amount" from="payment.amount"/></if>

            <service-call name="mantle.account.FinancialAccountServices.deposit#FinancialAccount" out-map="dpOut"
                    in-map="[finAccountId:finAccountId, amount:amount, reasonEnumId:'FatrRefund']"/>

            <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context"
                    in-map="[paymentGatewayConfigId:paymentGatewayConfigId, paymentOperationEnumId:'PgoRefund',
                        paymentId:paymentId, paymentMethodId:payment.paymentMethodId, finAccountId:finAccountId,
                        amount:amount, amountUomId:payment.amountUomId,
                        referenceNum:dpOut.finAccountTransId, approvalCode:dpOut.finAccountTransId,
                        transactionDate:ec.user.nowTimestamp,
                        resultSuccess:'Y', resultDeclined:'N', resultError:'N', resultNsf:'N']"/>

            <!-- NOTE: don't update Payment status to refunded, let calling code do that -->
        </actions>
    </service>
</services>
