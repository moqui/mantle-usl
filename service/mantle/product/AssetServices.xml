<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="get" noun="AssetDisplayInfo">
        <in-parameters><parameter name="assetId"/></in-parameters>
        <out-parameters>
            <parameter name="asset" type="EntityValue"/>
            <parameter name="isFixedAsset" type="Boolean"/>
            <parameter name="statusItem" type="EntityValue"/>
            <parameter name="statusId"/>
            <parameter name="statusHistoryList" type="EntityList"><parameter name="auditLog" type="EntityValue"/></parameter>
            <parameter name="product" type="EntityValue"/>
            <parameter name="facility" type="EntityValue"/>
            <parameter name="facilityLocation" type="EntityValue"/>
            <parameter name="originFacility" type="EntityValue"/>
            <parameter name="assetDetailList" type="EntityList"><parameter name="assetDetail" type="EntityValue"/></parameter>
            <parameter name="assetReservationList" type="EntityList"><parameter name="assetReservation" type="EntityValue"/></parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
            <if condition="asset == null"><return error="true" message="Asset not found with ID ${assetId}"/></if>

            <set field="isFixedAsset" from="!(asset.assetTypeEnumId in ['AstTpInventory', 'AstTpSupplies'])"/>

            <set field="statusItem" from="asset.'Asset#moqui.basic.StatusItem'"/>
            <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusHistoryList">
                <econdition field-name="changedEntityName" value="mantle.product.asset.Asset"/>
                <econdition field-name="changedFieldName" value="statusId"/>
                <econdition field-name="pkPrimaryValue" from="assetId"/>
                <order-by field-name="changedDate"/>
            </entity-find>
            <set field="statusId" from="asset.statusId"/>

            <set field="facility" from="asset.'mantle.facility.Facility'"/>
            <set field="facilityLocation" from="asset.'mantle.facility.FacilityLocation'"/>
            <set field="product" from="asset.'mantle.product.Product'"/>
            <set field="originFacility" from="asset.'Origin#mantle.facility.Facility'"/>

            <entity-find entity-name="mantle.product.asset.AssetDetail" list="assetDetailList" limit="20">
                <econdition field-name="assetId"/><order-by field-name="-effectiveDate"/></entity-find>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetReservationList">
                <econdition field-name="assetId"/><order-by field-name="reservedDate"/></entity-find>
        </actions>
    </service>

    <service verb="update" noun="Asset">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk">
                <exclude field-name="productId"/><exclude field-name="hasQuantity"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="acquireCost"/><exclude field-name="facilityId"/><exclude field-name="locationSeqId"/>
            </auto-parameters>
        </in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
        <actions>
            <service-call name="update#mantle.product.asset.Asset" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AssetAcquireCost" transaction-timeout="600">
        <description>Update (or set) Asset.acquireCost and re-post all GL transactions for receipt, issuance, and physical inventory changes.</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="acquireCost" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <set field="asset.acquireCost" from="acquireCost"/>
            <entity-update value-field="asset"/>

            <service-call name="mantle.ledger.AssetAutoPostServices.repost#Asset" in-map="[assetId:assetId]"/>
        </actions>
    </service>

    <service verb="update" noun="AssetFromDetail" no-tx-cache="true">
        <description>Called by EECA rule to update Asset quantities when an AssetDetail record is created.</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="availableToPromiseDiff" type="BigDecimal"/>
            <parameter name="quantityOnHandDiff" type="BigDecimal"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                <field-map field-name="assetId"/></entity-find-one>

            <!-- <log message="========== start update#AssetFromDetail ${assetId}: ${availableToPromiseDiff}/${quantityOnHandDiff} :: ${asset.availableToPromiseTotal}/${asset.quantityOnHandTotal}"/> -->

            <!-- View queries won't work with transaction cache (for data updated within the tx), so if active use different approach -->
            <if condition="ec.transaction.isTransactionCacheActive()"><then>
                <!-- incremental update -->
                <set field="asset.availableToPromiseTotal" from="(asset.availableToPromiseTotal ?: 0) + (availableToPromiseDiff ?: 0)"/>
                <set field="asset.quantityOnHandTotal" from="(asset.quantityOnHandTotal ?: 0) + (quantityOnHandDiff ?: 0)"/>
            </then><else>
                <!-- sum all records, update with new totals -->
                <entity-find-one entity-name="mantle.product.asset.AssetDetailSummary" value-field="assetDetailSummary"/>
                <if condition="assetDetailSummary != null"><then>
                    <set field="asset.availableToPromiseTotal" from="assetDetailSummary.availableToPromiseTotal ?: 0"/>
                    <set field="asset.quantityOnHandTotal" from="assetDetailSummary.quantityOnHandTotal ?: 0"/>
                </then><else>
                    <set field="asset.availableToPromiseTotal" from="(asset.availableToPromiseTotal ?: 0) + (availableToPromiseDiff ?: 0)"/>
                    <set field="asset.quantityOnHandTotal" from="(asset.quantityOnHandTotal ?: 0) + (quantityOnHandDiff ?: 0)"/>
                </else></if>
            </else></if>

            <entity-update value-field="asset"/>

            <!-- never let quantityOnHandTotal stay negative, do a physical inventory found for the difference -->
            <!-- NOTE: this may be better to do at a higher level in some cases, but this will make sure -->
            <if condition="asset.quantityOnHandTotal &lt; 0">
                <service-call name="mantle.product.AssetServices.record#PhysicalInventoryChange"
                        in-map="[productId:asset.productId, facilityId:asset.facilityId, locationSeqId:asset.locationSeqId,
                            quantityChange:-asset.quantityOnHandTotal, varianceReasonEnumId:'InVrFound',
                            assetList:[asset]]"/>
            </if>

            <!-- <set field="message" from="'========== end update#AssetFromDetail ' + assetId + ': ' + availableToPromiseDiff + '/' + quantityOnHandDiff + ' :: ' + asset.availableToPromiseTotal + '/' + asset.quantityOnHandTotal"/><log message="${message}"/> -->
        </actions>
    </service>

    <!-- ========================================== -->
    <!-- ========== Reservation Services ========== -->
    <!-- ========================================== -->

    <service verb="reserve" noun="AssetsForOrder" no-tx-cache="true">
        <description>Triggered by an SECA rule on OrderHeader status change to OrderPlaced (see ProductAsset.secas.xml)</description>
        <in-parameters><parameter name="orderId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <set field="productStore" from="orderHeader.'mantle.product.store.ProductStore'"/>
            <if condition="productStore == null"><then>
                <set field="orderParts" from="orderHeader.parts"/>
                <iterate list="orderParts" entry="orderPart">
                    <!-- if vendorPartyId is not an internal org this is not a sales order, so don't do inventory res (return) -->
                    <entity-find-one entity-name="mantle.party.PartyRole" value-field="orgPartyRole" cache="true">
                        <field-map field-name="partyId" from="orderPart.vendorPartyId"/>
                        <field-map field-name="roleTypeId" value="OrgInternal"/>
                    </entity-find-one>
                    <if condition="orgPartyRole == null"><return/></if>
                </iterate>
            </then><else>
                <!-- if store setup for no reservation return now -->
                <if condition="productStore.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
            </else></if>

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/>
                <order-by field-name="orderItemSeqId"/>
            </entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId, productStore:productStore]"/>
            </iterate>
        </actions>
    </service>
    <service verb="checkReserve" noun="AssetForOrderItem">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>
            <!-- only do this automatically if order placed or later but not completed/cancelled/etc -->
            <set field="resStatusList" from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderHold']"/>
            <if condition="!(orderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)"><return/></if>
            <!-- reserve assets, or update reservations as needed -->
            <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem" in-map="context"/>
        </actions>
    </service>
    <service verb="reserve" noun="AssetForOrderItem" no-tx-cache="true">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="productStore" type="EntityValue"><description>Optional, gets from OrderHeader if not passed.
                If there is no OrderHeader.productStoreId defaults to reservationOrderEnumId=AsResOrdFifoRec and gets
                inventoryFacilityId from OrderPart.facilityId and organizationPartyId from OrderPart.vendorPartyId.</description></parameter>
            <parameter name="assetId"><description>Optional assetId, reserves against this first if specified.</description></parameter>
            <parameter name="assetIdList" type="List">
                <description>Optional List of assetId values, reserves against these first (in order) if specified.</description>
                <parameter name="assetId"/>
            </parameter>
            <parameter name="resetReservations" type="Boolean" default="false"><description>If true remove existing reservations before reserving.</description></parameter>
            <parameter name="skipAssetIds" type="Collection"><description>Don't reserve to this Asset, for displace/etc</description></parameter>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>

            <!-- do a FOR UPDATE query on OrderItem as a semaphore (will also need on Asset records, done below) -->
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>

            <!-- first check the OrderItem, make sure we have a productId otherwise don't reserve -->
            <set field="productId" from="orderItem.productId"/>
            <if condition="!productId"><return/></if>

            <!-- see if Product is a physical item -->
            <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
            <if condition="!(product.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse'])"><return/></if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>

            <!-- check OrderHeader and OrderPart status, return immediately if not Input, Placed, Processing, Approved, Sent, or Hold -->
            <set field="resStatusList" from="['OrderOpen', 'OrderRequested', 'OrderProposed', 'OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderHold']"/>
            <if condition="!(orderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)">
                <return message="Not reserving, order or part not in status that allows reservation"/></if>

            <!-- before finding remaining quantity and getting existing reservations, resetReservations if specified -->
            <if condition="resetReservations">
                <service-call name="mantle.product.AssetServices.remove#OrderItemReservations" in-map="context"/></if>

            <set field="quantityRemaining" from="orderItem.quantity"/>

            <!-- if there are any existing reservations, deduct their quantity -->
            <!-- NOTE this was for-update=true but should not be needed, we already locked the OrderItem -->
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                <order-by field-name="-reservedDate"/><!-- get most recent first for reducing reservation quantities -->
            </entity-find>
            <iterate list="existingResList" entry="existingRes">
                <set field="quantityRemaining" from="quantityRemaining - existingRes.quantity"/>
            </iterate>
            <!-- if nothing to reserve or un-reserve return now -->
            <if condition="quantityRemaining == 0"><return/></if>

            <!-- handle too much reserved -->
            <if condition="quantityRemaining &lt; 0">
                <set field="quantityToDeduct" from="-quantityRemaining"/>
                <iterate list="existingResList" entry="existingRes">
                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut"
                            in-map="[assetReservationId:existingRes.assetReservationId, quantityToDeduct:quantityToDeduct]"/>
                    <set field="quantityToDeduct" from="quantityToDeduct - reduceArOut.quantityDeducted"/>
                    <if condition="quantityToDeduct == 0"><break/></if>
                </iterate>

                <if condition="quantityToDeduct != 0">
                    <return error="true" message="Unable to remove reservations for ${quantityToDeduct} out of ${-quantityRemaining} attempted, not enough quantity reserved and not issued"/>
                    <else><return/></else>
                </if>
            </if>
            <if condition="quantityRemaining &lt; 0">
                <log level="error" message="Quantity to reserve ${quantityRemaining} is less than zero; order item ${orderId}:${orderItemSeqId}, quantity ${orderItem.quantity}; existingResList: ${existingResList}"/>
                <return error="true" message="Quantity to reserve ${quantityRemaining} is less than zero"/>
            </if>

            <!-- no store passed? find it from OrderHeader -->
            <if condition="productStore == null">
                <entity-find-related-one value-field="orderHeader" relationship-name="mantle.product.store.ProductStore"
                        to-value-field="productStore" cache="true"/>
            </if>
            <!-- if store setup for no reservation return now -->
            <if condition="productStore?.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
            <!-- otherwise set assetOrderBy field based on reservationOrderEnumId -->
            <set field="reservationOrderEnumId" from="productStore?.reservationOrderEnumId ?: 'AsResOrdFifoRec'"/>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="resOrderEnum">
                <field-map field-name="enumId" from="reservationOrderEnumId"/></entity-find-one>
            <set field="assetOrderBy" from="resOrderEnum?.enumCode ?: 'receivedDate'"/><!-- default: FIFO by received date -->

            <set field="inventoryFacilityId" from="orderPart?.facilityId ?: productStore?.inventoryFacilityId"/>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="inventoryFacility">
                <field-map field-name="facilityId" from="inventoryFacilityId"/></entity-find-one>
            <set field="assetAllowOtherOwner" from="inventoryFacility?.assetAllowOtherOwner"/>

            <!-- determine organizationPartyId -->
            <set field="organizationPartyId" from="productStore?.organizationPartyId ?: orderPart?.vendorPartyId"/>
            <!-- if organizationPartyId is not an internal org this is not a sales order, so don't do inventory res (return) -->
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="orgPartyRole" cache="true">
                <field-map field-name="partyId" from="organizationPartyId"/>
                <field-map field-name="roleTypeId" value="OrgInternal"/>
            </entity-find-one>
            <if condition="productStore == null &amp;&amp; orgPartyRole == null"><return/></if>

            <!-- check and lock individual Asset records -->
            <set field="lockedAssetList" from="[]"/>
            <set field="checkQuantityRemaining" from="quantityRemaining"/>

            <!-- check/lock explicit assetIds -->
            <set field="explicitAssetIdList" from="[]"/>
            <if condition="assetId"><script>explicitAssetIdList.add(assetId)</script></if>
            <if condition="assetIdList"><script>explicitAssetIdList.addAll(assetIdList)</script></if>
            <if condition="explicitAssetIdList">
                <entity-find entity-name="mantle.product.asset.Asset" list="explicitAssetList">
                    <econdition field-name="assetId" operator="in" from="explicitAssetIdList"/>
                    <econdition field-name="productId"/>
                    <econdition field-name="quantityOnHandTotal" operator="greater" from="0.0"/>
                    <order-by field-name="${assetOrderBy},assetId"/>
                </entity-find>
                <iterate list="explicitAssetList" entry="checkAsset">
                    <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>
                    <!-- here we do the lock query, check the ATP using the locked value -->
                    <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                        <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>
                    <set field="quantityToReserve" from="asset.quantityOnHandTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.quantityOnHandTotal"/>
                    <if condition="quantityToReserve &gt; asset.availableToPromiseTotal">
                        <!-- displace existing reservations for explicit assetIds -->
                        <service-call name="mantle.product.AssetServices.displace#AssetReservations"
                                in-map="[assetId:asset.assetId, orderId:orderId, orderItemSeqId:orderItemSeqId, quantity:quantityToReserve]"/>
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="asset.assetId"/></entity-find-one>
                    </if>

                    <if condition="quantityToReserve &gt; 0.0">
                        <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                        <script>lockedAssetList.add(asset)</script>
                    </if>
                </iterate>
            </if>
            <if condition="checkQuantityRemaining &gt; 0.0">
                <set field="baseAssetCond" from="[productId:productId, statusId:'AstAvailable']"/>
                <if condition="inventoryFacilityId"><set field="baseAssetCond.facilityId" from="inventoryFacilityId"/></if>
                <if condition="organizationPartyId &amp;&amp; assetAllowOtherOwner != 'Y'">
                    <set field="baseAssetCond.ownerPartyId" from="organizationPartyId"/></if>

                <!-- see if we need to try for single lot and newer inventory, done via lotsToUse list -->
                <set field="lotsToUse" from="null"/>
                <set field="singleLot" from="false"/>
                <set field="newerInventory" from="false"/>
                <if condition="orderPart.customerPartyId">
                    <set field="singleLot" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerSingleLot').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                    <set field="newerInventory" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerNewerInventory').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                </if>

                <if condition="singleLot || newerInventory">
                    <set field="newerThanExpireDate" from="null"/>
                    <if condition="newerInventory">
                        <!-- get most recent asset issued and lot expire date for it -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuanceLotSummary" list="issuanceLotList" limit="1">
                            <econdition field-name="toPartyId" from="orderPart.customerPartyId"/>
                            <econdition field-name="productId"/>
                            <select-field field-name="expirationDate,expectedEndOfLife"/>
                            <order-by field-name="-issuedDate"/>
                        </entity-find>
                        <if condition="issuanceLotList">
                            <set field="newerThanExpireDate" from="issuanceLotList[0].expirationDate ?: issuanceLotList[0].expectedEndOfLife"/></if>
                    </if>
                    <!-- do pre-query to find sufficient lots, or if no sufficient largest lots by order to minimize lots -->
                    <entity-find entity-name="mantle.product.asset.AssetLotSummary" list="lotSummaryList">
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="expirationDate" operator="greater-equals" from="newerThanExpireDate" ignore-if-empty="true"/>
                        <select-field field-name="lotId,availableToPromiseTotal,manufacturedDate,expirationDate"/>
                        <!-- order to get fewest but sufficient available in a lot -->
                        <order-by field-name="availableToPromiseTotal"/>
                    </entity-find>
                    <set field="availableFoundByLot" from="0.0"/>
                    <iterate list="lotSummaryList" entry="lotSummary">
                        <set field="availableFoundByLot" from="availableFoundByLot + lotSummary.availableToPromiseTotal"/></iterate>
                    <!-- if no or insufficient records found and newerThanExpireDate, search again without -->
                    <if condition="availableFoundByLot &lt; checkQuantityRemaining &amp;&amp; newerThanExpireDate != null">
                        <!-- in this case we could get most recent inventory (-expirationDate) since we failed the newer than
                            constraint, but that would prioritize age over single lot so only do if !singleLot -->
                        <!-- when finding minimal lot or newest results are used in reverse order, so use expirationDate and not -expirationDate -->
                        <set field="lotRetryOrderBy" from="singleLot ? 'availableToPromiseTotal' : 'expirationDate'"/>
                        <entity-find entity-name="mantle.product.asset.AssetLotSummary" list="lotSummaryList">
                            <econdition-object field="baseAssetCond"/>
                            <select-field field-name="lotId,availableToPromiseTotal,manufacturedDate,expirationDate"/>
                            <order-by field-name="${lotRetryOrderBy}"/>
                        </entity-find>
                    </if>
                    <!-- if we found any lots look for singleLotId if singleLot, else use best candidate lots based on queries above -->
                    <if condition="lotSummaryList">
                        <set field="singleLotId" from="null"/>
                        <if condition="singleLot">
                            <!-- find first in list (smallest) lot with sufficient inventory and use it -->
                            <iterate list="lotSummaryList" entry="lotSummary">
                                <if condition="lotSummary.availableToPromiseTotal &gt;= checkQuantityRemaining">
                                    <set field="singleLotId" from="lotSummary.lotId"/><break/></if>
                            </iterate>
                        </if>
                        <if condition="singleLotId"><then>
                            <log level="warn" message="Found single lot ${singleLotId}"/>
                            <set field="lotsToUse" from="[singleLotId]"/>
                        </then><else><script><![CDATA[
                            // no single lot found? go end to beginning and use as many lots as needed
                            lotsToUse = []
                            BigDecimal lotQuantityRemaining = checkQuantityRemaining
                            for (int i = lotSummaryList.size() - 1; i >= 0; i--) {
                                def curLotSummary = lotSummaryList.get(i)
                                lotQuantityRemaining -= curLotSummary.availableToPromiseTotal
                                lotsToUse.add(curLotSummary.lotId)
                                if (lotQuantityRemaining <= 0.0) break
                            }
                        ]]></script></else></if>
                        <log level="warn" message="Lots to use: ${lotsToUse}"/>
                    </if>
                </if>

                <!-- ========== main available query ========== -->
                <!-- don't lock here, we'll lock records we need individually to avoid contention -->
                <entity-find entity-name="mantle.product.asset.Asset" list="checkAssetList">
                    <econdition-object field="baseAssetCond"/>
                    <!-- only look for Assets with available quantity, to reduce lock contention we'll create new records for negative ATP -->
                    <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                    <econdition field-name="assetId" operator="not-in" from="explicitAssetIdList" ignore-if-empty="true"/>
                    <econdition field-name="assetId" operator="not-in" from="skipAssetIds" ignore-if-empty="true"/>
                    <econdition field-name="lotId" operator="in" from="lotsToUse" ignore-if-empty="true"/>
                    <econdition field-name="statusId" value="AstAvailable"/>
                    <order-by field-name="${assetOrderBy},assetId"/>
                </entity-find>
                <iterate list="checkAssetList" entry="checkAsset">
                    <if condition="checkQuantityRemaining &lt;= 0"><break/></if>
                    <!-- here we do the lock query, check the ATP using the locked value -->
                    <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                        <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>
                    <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.availableToPromiseTotal"/>
                    <if condition="quantityToReserve &gt; 0">
                        <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                        <script>lockedAssetList.add(asset)</script>
                    </if>
                    <!-- <log level="warn" message="Locked Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal} for Reservation quantityToReserve=${quantityToReserve}, checkQuantityRemaining=${checkQuantityRemaining}"/> -->
                </iterate>
            </if>

            <!-- <log level="warn" message="Reserve order ${orderId}:${orderItemSeqId} asset ${assetId} lockedAssetList: ${lockedAssetList*.assetId} ${lockedAssetList*.availableToPromiseTotal}"/> -->

            <!-- do the reservations... -->
            <set field="baseMap" from="[orderId:orderId, orderItemSeqId:orderItemSeqId, productId:productId]"/>
            <iterate list="lockedAssetList" entry="asset">
                <if condition="quantityRemaining &gt; 0.0">
                    <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                    <if condition="quantityToReserve == 0.0"><continue/></if>
                    <set field="quantityRemaining" from="quantityRemaining - quantityToReserve"/>
                    <if condition="quantityToReserve &lt; 0.0">
                        <return error="true" message="In reserve#AssetForOrderItem (with assets found) got negative quantityToReserve ${quantityToReserve}"/></if>
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                            [assetId:asset.assetId, reservedDate:nowTimestamp, quantity:quantityToReserve,
                            quantityNotAvailable:0.0, quantityNotIssued:quantityToReserve, priority:orderItem.priority,
                            sequenceNum:asset_index, reservationOrderEnumId:reservationOrderEnumId]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                            [assetId:asset.assetId, effectiveDate:nowTimestamp,
                            availableToPromiseDiff:-quantityToReserve, assetReservationId:resOut.assetReservationId]"/>
                    <!-- <log level="warn" message="Reserved Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal}, quantityToReserve=${quantityToReserve}, quantityRemaining=${quantityRemaining}"/> -->
                </if>
            </iterate>

            <if condition="quantityRemaining &gt; 0.0">
                <!-- no asset... create a shell one to record the reservation and detail against -->
                <service-call name="mantle.product.AssetServices.create#ProductAssetAdHoc" out-map="assetOut"
                        in-map="[productId:productId, facilityId:inventoryFacilityId, ownerPartyId:organizationPartyId,
                            createdDate:nowTimestamp]"/>
                <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                        [assetId:assetOut.assetId, reservedDate:nowTimestamp, quantity:quantityRemaining,
                        quantityNotAvailable:quantityRemaining, quantityNotIssued:quantityRemaining,
                        priority:orderItem.priority, sequenceNum:0,
                        reservationOrderEnumId:reservationOrderEnumId]"/>
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                        [assetId:assetOut.assetId, effectiveDate:nowTimestamp,
                        availableToPromiseDiff:-quantityRemaining, assetReservationId:resOut.assetReservationId]"/>
            </if>
        </actions>
    </service>

    <service verb="remove" noun="OrderItemReservations">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on OrderItem as a semaphore -->
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>

            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList" for-update="true">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/></entity-find>
            <iterate list="existingResList" entry="existingRes">
                <service-call name="mantle.product.AssetServices.reduce#AssetReservation"
                        in-map="[assetReservationId:existingRes.assetReservationId]"/>
            </iterate>
        </actions>
    </service>
    <service verb="reduce" noun="AssetReservation" no-tx-cache="true">
        <description>Reduce quantity on AssetReservation, if reduced to zero delete.</description>
        <in-parameters>
            <parameter name="assetReservationId" required="true"/>
            <parameter name="quantityToDeduct" type="BigDecimal"><description>Defaults to entire quantityNotIssued</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="quantityDeducted" type="BigDecimal"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="existingRes"/>
            <if condition="!quantityToDeduct"><set field="quantityToDeduct" from="existingRes.quantityNotIssued"/></if>
            <if condition="quantityToDeduct &gt;= existingRes.quantity &amp;&amp; existingRes.quantity == existingRes.quantityNotIssued"><then>
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                                effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:existingRes.quantity,
                                assetReservationId:existingRes.assetReservationId, productId:existingRes.productId]"/>

                <set field="quantityDeducted" from="existingRes.quantity"/>
                <entity-delete value-field="existingRes"/>
            </then><else>
                <set field="curQuantityToDeduct" from="existingRes.quantityNotIssued &gt; quantityToDeduct ?
                                quantityToDeduct : existingRes.quantityNotIssued"/>
                <!-- add to ATP on Asset through a detail record -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                            effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:curQuantityToDeduct,
                            assetReservationId:existingRes.assetReservationId, productId:existingRes.productId,
                            orderId:existingRes.orderId, orderItemSeqId:existingRes.orderItemSeqId]"/>
                <!-- reduce quantities on AssetReservation -->
                <set field="existingRes.quantity" from="existingRes.quantity - curQuantityToDeduct"/>
                <set field="existingRes.quantityNotAvailable"
                        from="existingRes.quantityNotAvailable &gt; curQuantityToDeduct ?
                                    existingRes.quantityNotAvailable - curQuantityToDeduct : 0"/>
                <set field="existingRes.quantityNotIssued" from="existingRes.quantityNotIssued - curQuantityToDeduct"/>
                <if condition="existingRes.quantity &lt; 0">
                    <return error="true" message="In reduce#AssetReservation got negative quantity ${existingRes.quantity}, quantity deducted ${curQuantityToDeduct}"/></if>
                <entity-update value-field="existingRes"/>

                <set field="quantityDeducted" from="curQuantityToDeduct"/>
            </else></if>
        </actions>
    </service>

    <!-- TODO: implement this (and populate priority on order/item and on reservation)
    <service verb="reReserve" noun="ProductAssets">
        <description>Clear out all reservations for a Product and re-reserve</description>
        <in-parameters><parameter name="productId" required="true"/></in-parameters>
        <actions>
        </actions>
    </service>
    -->
    <service verb="checkReserve" noun="ProductAssets">
        <description>For a given productId see if there are AssetReservation.quantityNotAvailable and Asset.availableToPromiseTotal, if so update reservations</description>
        <in-parameters><parameter name="productId" required="true"/></in-parameters>
        <actions>
            <entity-find-count entity-name="mantle.product.issuance.AssetReservation" count-field="notAvailResCount">
                <econdition field-name="productId"/><econdition field-name="quantityNotAvailable" operator="greater" from="0.0"/></entity-find-count>
            <if condition="notAvailResCount == 0"><return/></if>

            <while condition="notAvailResCount &gt; 0">
                <entity-find entity-name="mantle.product.asset.Asset" list="availAssetList" limit="1">
                    <econdition field-name="productId"/>
                    <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                    <order-by field-name="receivedDate"/><!-- get oldest first for filling quantityNotAvailable -->
                </entity-find>
                <if condition="availAssetList.size() == 0"><break/></if>
                <!-- move reservation(s) to this asset -->
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:availAssetList[0].assetId]"/>
                <!-- see if we have any more not available reservations -->
                <entity-find-count entity-name="mantle.product.issuance.AssetReservation" count-field="notAvailResCount">
                    <econdition field-name="productId"/><econdition field-name="quantityNotAvailable" operator="greater" from="0.0"/></entity-find-count>
            </while>
        </actions>
    </service>

    <service verb="reserve" noun="IncreasedAsset" no-tx-cache="true">
        <description>For Asset with availableToPromiseTotal > 0 find AssetReservation with quantityNotAvailable and reserve against it</description>
        <in-parameters><parameter name="assetId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <if condition="asset.availableToPromiseTotal &lt;= 0"><return/></if>
            <if condition="!asset.productId"><return/></if>

            <set field="availableRemaining" from="asset.availableToPromiseTotal"/>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="resList">
                <econdition field-name="productId" from="asset.productId"/>
                <econdition field-name="quantityNotAvailable" operator="greater" from="0"/>
                <order-by field-name="priority"/><order-by field-name="reservedDate"/>
            </entity-find>
            <iterate list="resList" entry="res">
                <set field="quantityToMove" from="availableRemaining &lt; res.quantityNotAvailable ?
                        availableRemaining : res.quantityNotAvailable"/>
                <!-- quantityNotAvailable > 0 from query so if 0 means nothing left -->
                <if condition="quantityToMove == 0"><break/></if>
                <!-- make sure quantityToMove is less than res.quantityNotIssued, don't move issued quantities! -->
                <if condition="quantityToMove &gt; res.quantityNotIssued"><set field="quantityToMove" from="res.quantityNotIssued"/></if>
                <if condition="quantityToMove &gt; 0">
                    <service-call name="mantle.product.AssetServices.move#AssetReservation" out-map="moveArOut"
                            in-map="[assetId:assetId, assetReservationId:res.assetReservationId, quantity:quantityToMove]"/>
                    <set field="availableRemaining" from="availableRemaining - moveArOut.quantityMoved"/>
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="move" noun="AssetReservation" no-tx-cache="true">
        <description>Move partial or full reservation quantity to another asset.</description>
        <in-parameters>
            <parameter name="assetReservationId" required="true"/>
            <parameter name="assetId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="forceFullQuantity" type="Boolean" default="false"><description>If true ignore
                available to promise on asset and moves the quantity to it anyway.</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="quantityMoved"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="assetReservation" for-update="true"/>

            <if condition="quantity &gt; assetReservation.quantityNotIssued">
                <return error="true" message="Quantity to move (${quantity}) is greater than reservation [${assetReservationId}] quantity not yet issued (${assetReservation.quantityNotIssued}), not moving reservation"/></if>

            <if condition="forceFullQuantity">
                <set field="quantityToMove" from="quantity"/>
                <else>
                    <set field="quantityToMove" from="asset.availableToPromiseTotal &lt; quantity ? asset.availableToPromiseTotal : quantity"/>
                    <if condition="quantityToMove &lt; 0"><set field="quantityToMove" from="0"/></if>
                </else>
            </if>

            <set field="quantityMoved" from="quantityToMove"/>
            <if condition="quantityToMove == 0"><return/></if>

            <if condition="quantityToMove == assetReservation.quantity"><then>
                <!-- move over the whole reservation -->

                <!-- increment old Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                <!-- decrement new Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:-quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>

                <!-- set the new assetId and decrease quantityNotAvailable (should be to 0!) -->
                <set field="assetReservation.assetId" from="assetId"/>
                <set field="assetReservation.quantityNotAvailable"
                        from="assetReservation.quantityNotAvailable &gt; quantityToMove ?
                            assetReservation.quantityNotAvailable - quantityToMove : 0"/>
                <entity-update value-field="assetReservation"/>
            </then><else>
                <!-- create a new reservation, split the quantity -->
                <service-call name="create#mantle.product.issuance.AssetReservation" out-map="newResOut"
                        in-map="assetReservation.getMap() + [assetReservationId:null, assetId:assetId,
                            quantity:quantityToMove, quantityNotAvailable:0, quantityNotIssued:quantityToMove]"/>
                <!-- decrement old reservation quantities -->
                <set field="assetReservation.quantity" from="assetReservation.quantity - quantityToMove"/>
                <set field="assetReservation.quantityNotAvailable"
                        from="assetReservation.quantityNotAvailable &gt; quantityToMove ?
                            assetReservation.quantityNotAvailable - quantityToMove : 0"/>
                <set field="assetReservation.quantityNotIssued" from="assetReservation.quantityNotIssued - quantityToMove"/>
                <if condition="assetReservation.quantity &lt; 0">
                    <return error="true" message="In move#AssetReservation got negative quantity ${assetReservation.quantity}, quantity to move ${quantityToMove}"/></if>
                <entity-update value-field="assetReservation"/>

                <!-- increment old Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                    effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:quantityToMove,
                    assetReservationId:assetReservationId, productId:assetReservation.productId,
                    orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                <!-- decrement new Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetId,
                    effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:-quantityToMove,
                    assetReservationId:newResOut.assetReservationId, productId:assetReservation.productId,
                    orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="displace" noun="AssetReservations" no-tx-cache="true">
        <description>When forcing the use of a certain Asset for an OrderItem, move other reservations as needed to
            handle quantity that the given OrderItem will be using (note that this doesn't do an additional reservation,
            just removes reservations from other OrderItems).</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"><description>The full quantity, for an OrderItem
                quantity already on asset specified and the asset's availableToPromiseTotal will be subtracted</description></parameter>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
        </in-parameters>
        <actions>
            <!-- get quantity available for the asset, don't need to move reservations to cover this quantity -->
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <set field="availableToPromiseTotal" from="asset.availableToPromiseTotal"/>

            <!-- get quantity already reserved on this asset -->
            <set field="assetQuantityReserved" from="0.0"/>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetAllResList">
                <econdition field-name="quantityNotIssued" operator="greater" from="0.0"/>
                <econdition field-name="assetId"/>
                <order-by field-name="-reservedDate"/><!-- so that newest reservations are moved first -->
            </entity-find>
            <if condition="orderId &amp;&amp; orderItemSeqId"><then>
                <filter-map-list list="assetAllResList" to-list="assetReservationList">
                    <field-map field-name="orderId"/><field-map field-name="orderItemSeqId"/></filter-map-list>
                <set field="assetOtherResList" from="assetAllResList - assetReservationList"/>

                <iterate list="assetReservationList" entry="assetReservation">
                    <set field="assetQuantityReserved" from="assetQuantityReserved + assetReservation.quantityNotIssued"/></iterate>
            </then><else>
                <set field="assetOtherResList" from="assetAllResList"/>
            </else></if>

            <!-- calc quantity of reservations we need to move -->
            <set field="resQuantityToMove" from="quantity - assetQuantityReserved - availableToPromiseTotal"/>

            <!-- <log level="warn" message="Displace asset ${assetId} order ${orderId} assetQuantityReserved ${assetQuantityReserved} resQuantityToMove ${resQuantityToMove}"/> -->

            <if condition="resQuantityToMove &gt; 0.0">
                <!-- move from the most recent, but remove res and re-reserve oldest first -->
                <set field="resQuantityRemaining" from="resQuantityToMove"/>
                <set field="resToMoveList" from="[]"/>
                <iterate list="assetOtherResList" entry="assetOtherRes">
                    <if condition="resQuantityRemaining == 0.0"><break/></if>
                    <set field="curMoveQuantity" from="resQuantityRemaining &gt; assetOtherRes.quantityNotIssued ? assetOtherRes.quantityNotIssued : resQuantityRemaining"/>
                    <script>resToMoveList.add(assetOtherRes)</script>
                    <set field="resQuantityRemaining" from="resQuantityRemaining - curMoveQuantity"/>
                </iterate>
                <!-- <log level="warn" message="Displace asset ${assetId} resToMoveList ${resToMoveList.collect({[assetReservationId:it.assetReservationId, assetId:it.assetId, orderId:it.orderId, quantity:it.quantity]})}"/> -->

                <!-- now reverse resToMoveList and move 'em -->
                <script>Collections.reverse(resToMoveList)</script>
                <!-- remove the reservation and re-reserve to any asset available -->
                <set field="resQuantityRemaining" from="resQuantityToMove"/>
                <iterate list="resToMoveList" entry="resToMove">
                    <if condition="resQuantityRemaining == 0.0"><break/></if>
                    <set field="curMoveQuantity" from="resQuantityRemaining &gt; resToMove.quantityNotIssued ? resToMove.quantityNotIssued : resQuantityRemaining"/>

                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut" out-map-add-to-existing="false"
                            in-map="[assetReservationId:resToMove.assetReservationId, quantityToDeduct:curMoveQuantity]"/>

                    <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                            in-map="[orderId:resToMove.orderId, orderItemSeqId:resToMove.orderItemSeqId, skipAssetIds:[assetId]]"/>

                    <set field="resQuantityRemaining" from="resQuantityRemaining - reduceArOut.quantityDeducted"/>
                </iterate>
            </if>

            <!-- also clear out other reservations for this OrderItem -->
            <set field="resQuantityToClear" from="quantity - assetQuantityReserved"/>
            <if condition="resQuantityToClear &gt; 0.0 &amp;&amp; orderId &amp;&amp; orderItemSeqId">
                <entity-find entity-name="mantle.product.issuance.AssetReservation" list="oiOtherResList">
                    <econdition field-name="assetId" operator="not-equals"/>
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                    <econdition field-name="quantityNotIssued" operator="greater" from="0.0"/>
                </entity-find>
                <iterate list="oiOtherResList" entry="oiOtherRes">
                    <if condition="resQuantityToClear == 0.0"><break/></if>
                    <set field="curReduceQuantity" from="resQuantityToClear &gt; oiOtherRes.quantityNotIssued ? oiOtherRes.quantityNotIssued : resQuantityToClear"/>
                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut"
                            in-map="[assetReservationId:oiOtherRes.assetReservationId, quantityToDeduct:curReduceQuantity]"/>
                    <set field="resQuantityToClear" from="resQuantityToClear - reduceArOut.quantityDeducted"/>
                </iterate>
            </if>

            <!-- for debugging
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetAllResList">
                <econdition field-name="assetId"/></entity-find>
            <log level="warn" message="Post Displace asset ${assetId} assetAllResList ${assetAllResList.collect({[assetReservationId:it.assetReservationId, assetId:it.assetId, orderId:it.orderId, quantity:it.quantity]})}"/>
            -->
        </actions>
    </service>

    <service verb="change" noun="AssetQuantity" no-tx-cache="true">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.AssetDetail" include="nonpk">
                <exclude field-name="quantityOnHandDiff"/><exclude field-name="availableToPromiseDiff"/></auto-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="quantityDiff" type="BigDecimal" required="true"/>
            <parameter name="effectiveDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                <field-map field-name="assetId"/></entity-find-one>

            <service-call name="create#mantle.product.asset.AssetDetail" in-map="context +
                    [quantityOnHandDiff:quantityDiff, availableToPromiseDiff:quantityDiff]"/>

            <!-- reserve the newly available Asset, if needed -->
            <if condition="quantityDiff &gt; 0.0 &amp;&amp; asset.productId">
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/></if>

            <!-- on decrease adjust reservations down and re-reserve -->
            <if condition="quantityDiff &lt; 0.0 &amp;&amp; asset.productId">
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                    <field-map field-name="assetId"/></entity-find-one>
                <if condition="asset.availableToPromiseTotal &lt; 0.0">
                    <set field="negativeAvailable" from="-asset.availableToPromiseTotal"/>
                    <set field="reduceQuantityRemaining" from="-quantityDiff"/>
                    <if condition="reduceQuantityRemaining &gt; negativeAvailable">
                        <set field="reduceQuantityRemaining" from="negativeAvailable"/></if>

                    <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                        <econdition field-name="assetId"/>
                        <order-by field-name="-reservedDate"/><!-- get most recent first for reducing reservation quantities -->
                    </entity-find>
                    <iterate list="existingResList" entry="res">
                        <if condition="reduceQuantityRemaining == 0.0"><break/></if>

                        <!-- don't just adjust quantityNotAvailable, try to re-reserve against other assets:
                        <set field="quantityAvailable" from="res.quantity - (res.quantityNotAvailable ?: 0.0)"/>
                        <set field="quantityToReduce" from="quantityAvailable &gt; reduceQuantityRemaining ? reduceQuantityRemaining : quantityAvailable"/>
                        <set field="res.quantityNotAvailable" from="res.quantityNotAvailable + quantityToReduce"/>
                        <entity-update value-field="res"/>
                        <set field="reduceQuantityRemaining" from="reduceQuantityRemaining - quantityToReduce"/>
                        -->

                        <set field="quantityToReduce" from="reduceQuantityRemaining &gt; res.quantityNotIssued ? res.quantityNotIssued : reduceQuantityRemaining"/>

                        <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut" out-map-add-to-existing="false"
                                in-map="[assetReservationId:res.assetReservationId, quantityToDeduct:quantityToReduce]"/>
                        <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                                in-map="[orderId:res.orderId, orderItemSeqId:res.orderItemSeqId, skipAssetIds:[assetId]]"/>

                        <set field="reduceQuantityRemaining" from="reduceQuantityRemaining - reduceArOut.quantityDeducted"/>
                    </iterate>
                    <!-- now that quantityNotAvailable is updated see if we can reserve those on other assets -->
                    <service-call name="mantle.product.AssetServices.checkReserve#ProductAssets" in-map="[productId:asset.productId]"/>
                </if>
            </if>
        </actions>
    </service>

    <!-- ======================================= -->
    <!-- ========== Issuance Services ========== -->
    <!-- ======================================= -->

    <service verb="issue" noun="AssetReservation" no-tx-cache="true">
        <description>Issue an Asset based on a reservation (AssetReservation). This is currently only called by
            ShipmentServices.pack#ShipmentItemSource. All callers should query and lock all Asset records planned to
            issue from before from issuing any (as ShipmentServices.pack#ShipmentItemSource does).</description>
        <in-parameters>
            <parameter name="assetReservation" type="EntityValue" required="true"/>
            <parameter name="shipmentId" required="true"/>
            <parameter name="shipmentItemSourceId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <if condition="quantity &gt; assetReservation.quantityNotIssued">
                <return error="true" message="For reservation ${assetReservation.assetReservationId} tried to issue quantity ${quantity} which is greater than quantity not issued ${assetReservation.quantityNotIssued} for the reservation"/></if>

            <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="context"
                    in-map="[assetId:assetReservation.assetId, assetReservationId:assetReservation.assetReservationId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId,
                        shipmentId:shipmentId, shipmentItemSourceId:shipmentItemSourceId, productId:assetReservation.productId,
                        issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantity]"/>

            <!-- create AssetDetail to decrement quantityOnHand -->
            <!-- NOTE: no availableToPromiseDiff because that was modified during the reservation -->
            <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                    effectiveDate:issuedDate, quantityOnHandDiff:-quantity,
                    assetReservationId:assetReservation.assetReservationId, shipmentId:shipmentId,
                    productId:assetReservation.productId, assetIssuanceId:assetIssuanceId]"/>

            <set field="assetReservation.quantityNotIssued" from="assetReservation.quantityNotIssued - quantity"/>
            <if condition="assetReservation.quantityNotIssued == 0.0"><then>
                <entity-delete value-field="assetReservation"/>
            </then><else>
                <entity-update value-field="assetReservation"/>
            </else></if>
        </actions>
    </service>
    <service verb="issue" noun="Asset" no-tx-cache="true">
        <description>Issue an Asset with no reservation.</description>
        <in-parameters>
            <parameter name="assetId"><description>Optional assetId, issues against this first if specified.</description></parameter>
            <parameter name="shipmentId" required="true"/>
            <parameter name="shipmentItemSourceId"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <if condition="assetId"><entity-find-one entity-name="mantle.product.asset.Asset" value-field="passedAsset"/></if>
            <if condition="quantity == 0.0"><return message="Not issuing zero quantity for shipment ${shipmentId}"/></if>

            <if condition="orderId &amp;&amp; orderItemSeqId"><then>
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
                <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
                <set field="productStore" from="orderHeader.'mantle.product.store.ProductStore'"/>
                <!-- <set field="inventoryFacility" from="productStore?.'Inventory#mantle.facility.Facility'"/> -->
                <set field="productId" from="orderItem.productId"/>

                <set field="facilityId" from="productStore?.inventoryFacilityId"/>
                <!-- no ProductStore inventoryFacilityId? look at OrderPart -->
                <if condition="!facilityId">
                    <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>
                    <set field="facilityId" from="orderPart.facilityId"/>
                    <!-- no OrderPart facilityId? look at ShipmentRouteSegment.originFacilityId -->
                    <if condition="!facilityId">
                        <entity-find entity-name="mantle.shipment.ShipmentRouteSegment" list="srsList">
                            <econdition field-name="shipmentId"/><order-by field-name="shipmentRouteSegmentSeqId"/></entity-find>
                        <if condition="srsList"><set field="facilityId" from="srsList[0].originFacilityId"/></if>
                    </if>
                </if>
                <if condition="!facilityId"><return error="true" message="Could not find inventory facility for shipment ${shipmentId} and order item ${ec.resource.expand('OrderItemNameTemplate','')}"/></if>
            </then><else>
                <if condition="passedAsset != null"><then>
                    <set field="productId" from="passedAsset.productId"/>
                    <set field="facilityId" from="passedAsset.facilityId"/>
                    <set field="ownerPartyId" from="passedAsset.ownerPartyId"/>
                </then><else>
                    <return error="true" message="Cannot issue asset for Shipment ${shipmentId} without either assetId or orderId and orderItemSeqId"/>
                </else></if>
            </else></if>

            <set field="baseMap" from="[orderId:orderId, orderItemSeqId:orderItemSeqId, shipmentId:shipmentId,
                    shipmentItemSourceId:shipmentItemSourceId, productId:productId]"/>

            <set field="ownerPartyId" from="productStore?.organizationPartyId"/>
            <!-- no ProductStore organizationPartyId? try OrderPart.vendorPartyId (for sales orders should be an internal org) -->
            <if condition="!ownerPartyId &amp;&amp; orderItem != null">
                <if condition="orderPart == null"><set field="orderPart" from="orderItem.'mantle.order.OrderPart'"/></if>
                <set field="ownerPartyId" from="orderPart.vendorPartyId"/>
                <!-- if still not found, ignore -->
            </if>

            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId"/>
                <econdition field-name="ownerPartyId" ignore-if-empty="true"/>
                <!-- reserve from oldest first (ascending receivedDate) -->
                <!-- TODO: this may be configurable in the future -->
                <order-by field-name="receivedDate"/>
            </entity-find>
            <!-- if assetId specified add it to the list -->
            <if condition="passedAsset != null"><script>assetList.add(0, passedAsset)</script></if>

            <if condition="assetList"><then>
                <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
                <set field="quantityRemaining" from="quantity"/>
                <iterate list="assetList" entry="asset">
                    <set field="lastAsset" from="asset"/>
                    <if condition="quantityRemaining &gt; 0.0">
                        <set field="quantityToIssue" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                        <if condition="quantityToIssue &lt;= 0.0"><continue/></if>
                        <set field="quantityRemaining" from="quantityRemaining - quantityToIssue"/>
                        <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                                [assetId:asset.assetId, issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantityToIssue]"/>
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:asset.assetId,
                                effectiveDate:issuedDate, quantityDiff:-quantityToIssue, assetIssuanceId:issueOut.assetIssuanceId]"/>
                    </if>
                </iterate>
                <!-- not all issued? issue to last (most recent) Asset -->
                <if condition="quantityRemaining &gt; 0">
                    <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                            [assetId:lastAsset.assetId, issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantityRemaining]"/>
                    <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:lastAsset.assetId,
                            effectiveDate:issuedDate, quantityDiff:-quantityRemaining, assetIssuanceId:issueOut.assetIssuanceId]"/>
                </if>
            </then><else>
                <!-- no asset... create a shell one to record the issuance and detail against -->
                <service-call name="create#mantle.product.asset.Asset" out-map="context"
                        in-map="[assetTypeEnumId:'AstTpInventory', hasQuantity:'Y', statusId:'AstAvailable',
                            productId:productId, facilityId:productStore.inventoryFacilityId,
                            ownerPartyId:productStore?.organizationPartyId, receivedDate:ec.user.nowTimestamp,
                            availableToPromiseTotal:0, quantityOnHandTotal: 0]"/>
                <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut"
                        in-map="baseMap + [assetId:assetId, issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantity]"/>
                <!-- create AssetDetail to decrement QOH and ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap + [assetId:assetId,
                        effectiveDate:issuedDate, quantityOnHandDiff:-quantity,
                        availableToPromiseDiff:-quantity, assetIssuanceId:issueOut.assetIssuanceId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="issue" noun="AssetToWorkEffort" no-tx-cache="true">
        <!-- NOTE: tested with transaction="cache" and works fine, but only a small performance improvement (this is a fairly small service) -->
        <description>Issue an Asset to a WorkEffort (production run, etc).</description>
        <in-parameters>
            <parameter name="assetId" required="true" default="defaultAssetId"/>
            <parameter name="asset" type="EntityValue"/>
            <parameter name="defaultAssetId"/>
            <parameter name="workEffortId" required="true"/>
            <parameter name="quantity" type="BigDecimal"><description>If not specified entire quantity of given Asset record will be used.</description></parameter>
            <parameter name="quantityUomId"><description>If not specified product Uom Id will be used.</description></parameter>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="noConsumeProduct" default-value="error"><description>If the asset has a productId that is
                not one of the WorkEffort consume products, "add" it, "ignore" it, or return an "error"?</description></parameter>
            <parameter name="noOriginFacility" default-value="error"><description>If the asset has a originFacilityId that is
                not one of the WorkEffort origin facilities, "add" it, "ignore" it, or return an "error"?</description></parameter>
        </in-parameters>
        <actions>
            <if condition="asset == null">
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                    <field-map field-name="assetId"/></entity-find-one>
            </if>
            <if condition="asset == null"><return error="true" message="Asset not found with ID ${assetId}"/></if>

            <if condition="quantity &amp;&amp; quantityUomId">
                <service-call name="mantle.shipment.ShipmentServices.convert#ProductBoxQuantity" in-map="[
                            productId:asset.productId, originalQuantity:quantity, originalQuantityUomId:quantityUomId]" out-map="cvtQty"/>
                <if condition="cvtQty">
                    <set field="quantity" from="cvtQty.convertedQuantity"/>
                </if>
            <else-if condition="!quantity">
                 <set field="quantity" from="asset.availableToPromiseTotal"/>
            </else-if>
            </if>

            <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
            <if condition="quantity &gt; asset.availableToPromiseTotal">
                <set field="uomDescription" from="asset?.product?.amountUom?' '+(ec.resource.expand('UomNameTemplate','',asset.product.amountUom)):''"/>
                <message error="true">Quantity specified (${ec.l10n.format(quantity, '#,##0.00')}${uomDescription}) is greater than the quantity available (${ec.l10n.format(asset.availableToPromiseTotal, '#,##0.00')}${uomDescription})</message></if>

            <!-- check consume product -->
            <entity-find entity-name="mantle.work.effort.WorkEffortProduct" list="consumeProductList">
                <econdition field-name="workEffortId"/><econdition field-name="productId" from="asset.productId"/>
                <econdition field-name="typeEnumId" value="WeptConsume"/>
            </entity-find>
            <if condition="!consumeProductList">
                <if condition="noConsumeProduct == 'add'"><then>
                    <service-call name="create#mantle.work.effort.WorkEffortProduct" in-map="[workEffortId:workEffortId,
                            productId:asset.productId, typeEnumId:'WeptConsume', estimatedQuantity:quantity]"/>
                </then><else-if condition="noConsumeProduct != 'ignore'">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product">
                        <field-map field-name="productId" from="asset.productId"/></entity-find-one>
                    <message error="true">Not issuing Asset [${assetId}], Product ${ec.resource.expand('ProductNameTemplate','',product)} is not a product to consume</message>
                </else-if></if>
            </if>

            <!-- check origin facility -->
            <if condition="asset.originFacilityId">
                <entity-find entity-name="mantle.work.effort.WorkEffortFacility" list="originFacilityList">
                    <econdition field-name="workEffortId"/><econdition field-name="facilityId" from="asset.originFacilityId"/>
                    <econdition field-name="typeEnumId" value="WeftOrigin"/>
                </entity-find>
                <if condition="!originFacilityList">
                    <if condition="noOriginFacility == 'add'"><then>
                        <service-call name="create#mantle.work.effort.WorkEffortFacility" in-map="[workEffortId:workEffortId,
                            facilityId:asset.originFacilityId, typeEnumId:'WeftOrigin']"/>
                    </then><else-if condition="noOriginFacility != 'ignore'">
                        <entity-find-one entity-name="mantle.facility.Facility" value-field="facility">
                            <field-map field-name="facilityId" from="asset.originFacilityId"/></entity-find-one>
                        <message error="true">Not issuing Asset [${assetId}], Origin Facility ${ec.resource.expand('FacilityNameTemplate','',facility)} is not an origin facility</message>
                    </else-if></if>
                </if>
            </if>

            <check-errors/>

            <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut"
                    in-map="[workEffortId:workEffortId, productId:asset.productId, assetId:asset.assetId,
                        issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantity]"/>
            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="[workEffortId:workEffortId,
                    productId:asset.productId, assetId:asset.assetId, effectiveDate:issuedDate, quantityDiff:-quantity,
                    assetIssuanceId:issueOut.assetIssuanceId]"/>
        </actions>
    </service>

    <service verb="issue" noun="AnyAssetToWorkEffort" no-tx-cache="true">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="workEffortId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters><parameter name="assetIdList" type="List"><parameter name="assetId"/></parameter></out-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/><econdition field-name="facilityId"/>
                <econdition field-name="availableToPromiseTotal" operator="greater" from="0"/>
                <econdition field-name="statusId" value="AstAvailable"/>
                <order-by field-name="receivedDate"/>
            </entity-find>
            <set field="assetIdList" from="[]"/>
            <set field="remainingQuantity" from="quantity"/>
            <iterate list="assetList" entry="asset">
                <set field="curQuantity" from="asset.availableToPromiseTotal &gt; remainingQuantity ? remainingQuantity : asset.availableToPromiseTotal"/>
                <if condition="curQuantity">
                    <service-call name="mantle.product.AssetServices.issue#AssetToWorkEffort"
                            in-map="[workEffortId:workEffortId, assetId:asset.assetId, issuedDate:issuedDate, quantity:curQuantity]"/>
                    <set field="remainingQuantity" from="remainingQuantity - curQuantity"/>
                    <if condition="remainingQuantity == 0"><break/></if>
                </if>
            </iterate>
            <if condition="remainingQuantity &gt; 0"><message>Could not find available inventory for ${remainingQuantity} out of ${quantity}</message></if>
        </actions>
    </service>

    <service verb="move" noun="IssuancesToNewShipment">
        <description>Move AssetIssuance details to new records for another Shipment. Doesn't delete original record or
            receive assets back into inventory, just moves quantity to AssetIssuance.quantityCancelled and then creates
            a new record with the same assetId, etc for the new Shipment and corresponding Order.</description>
        <in-parameters>
            <parameter name="shipmentId" required="true"/>
            <parameter name="newOrderId" required="true"/>
            <parameter name="newShipmentId" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="issuanceList" for-update="true">
                <econdition field-name="shipmentId"/></entity-find>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" from="newOrderId"/></entity-find>
            <iterate list="issuanceList" entry="issuance">
                <!-- cancel original issuance quantity -->
                <service-call name="update#mantle.product.issuance.AssetIssuance"
                        in-map="[assetIssuanceId:issuance.assetIssuanceId, quantityCancelled:issuance.quantity, quantity:0]"/>
                <!-- create new issuance -->
                <filter-map-list list="orderItemList" to-list="prodOrderItemList">
                    <field-map field-name="productId" from="issuance.productId"/></filter-map-list>
                <if condition="!prodOrderItemList">
                    <return error="true" message="In move issuance to new shipment no Order Item found on order ${newOrderId} for product ${issuance.productId}"/></if>
                <service-call name="create#mantle.product.issuance.AssetIssuance"
                        in-map="[assetId:issuance.assetId, quantity:issuance.quantity, orderId:newOrderId,
                            orderItemSeqId:prodOrderItemList[0].orderItemSeqId, shipmentId:newShipmentId,
                            productId:issuance.productId, issuedDate:issuedDate, issuedByUserId:ec.user.userId]"/>

                <!-- TODO check GL inventory transactions on cancel, direct issuance create; need any since this is a direct replacement? -->
            </iterate>
        </actions>
    </service>

    <service verb="cancel" noun="AssetIssuance">
        <in-parameters>
            <parameter name="assetIssuanceId" required="true"/>
            <parameter name="reserveAsset" type="Boolean" default="true"/>
            <parameter name="cancelDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters><parameter name="assetReservationId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.issuance.AssetIssuance" value-field="assetIssuance" for-update="true"/>
            <set field="originalQuantity" from="assetIssuance.quantity"/>
            <if condition="!originalQuantity"><return message="No quantity to cancel for issuance ${assetIssuanceId} of asset ${assetIssuance.assetId}"/></if>
            <if condition="assetIssuance.invoiceId">
                <return error="true" message="Cannot cancel issuance ${assetIssuanceId}, already on invoice ${assetIssuance.invoiceId}"/></if>

            <set field="quantityCancelled" from="(assetIssuance.quantityCancelled ?: 0.0) + originalQuantity"/>
            <service-call name="update#mantle.product.issuance.AssetIssuance" in-map="[assetIssuanceId:assetIssuanceId,
                    quantity:0.0, quantityCancelled:quantityCancelled]"/>

            <if condition="reserveAsset &amp;&amp; assetIssuance.orderId"><then>
                <!-- create AssetDetail to increment QOH only, keep ATP -->
                <!-- NOTE: no availableToPromiseDiff because we are going to reserve again right now -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetIssuance.assetId,
                    effectiveDate:cancelDate, quantityOnHandDiff:originalQuantity,
                    productId:assetIssuance.productId, assetIssuanceId:assetIssuanceId]"/>
                <service-call name="create#mantle.product.issuance.AssetReservation" out-map="context" in-map="[
                    orderId:assetIssuance.orderId, orderItemSeqId:assetIssuance.orderItemSeqId, productId:assetIssuance.productId,
                    assetId:assetIssuance.assetId, reservedDate:cancelDate, quantity:originalQuantity,
                    quantityNotAvailable:0, quantityNotIssued:originalQuantity, priority:null,
                    sequenceNum:1, reservationOrderEnumId:null]"/>
            </then><else>
                <!-- create AssetDetail to increment QOH and ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetIssuance.assetId,
                    effectiveDate:cancelDate, quantityOnHandDiff:originalQuantity, availableToPromiseDiff:originalQuantity,
                    productId:assetIssuance.productId, assetIssuanceId:assetIssuanceId]"/>
            </else></if>
        </actions>
    </service>
    <service verb="update" noun="AssetIssuedDate">
        <in-parameters>
            <parameter name="assetIssuanceId" required="true"/>
            <parameter name="issuedDate" type="Timestamp" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.issuance.AssetIssuance" value-field="assetIssuance" for-update="true"/>
            <if condition="assetIssuance.issuedDate == issuedDate"><return/></if>
            <set field="assetIssuance.issuedDate" from="issuedDate"/>
            <entity-update value-field="assetIssuance"/>
            <!-- if issuedDate was changed then after updating the AssetIssuance record repost the GL TX -->
            <service-call name="mantle.ledger.AssetAutoPostServices.repost#AssetIssuance"
                    in-map="[assetIssuanceId:assetIssuance.assetIssuanceId]"/>
            <!-- AssetDetail.effectiveDate is based on issuedDate, so update those too -->
            <entity-find entity-name="mantle.product.asset.AssetDetail" list="assetDetailList" for-update="true">
                <econdition field-name="assetIssuanceId"/></entity-find>
            <iterate list="assetDetailList" entry="assetDetail">
                <set field="assetDetail.effectiveDate" from="issuedDate"/>
                <entity-update value-field="assetDetail"/>
            </iterate>
        </actions>
    </service>

    <!-- ====================================== -->
    <!-- ========== Receipt Services ========== -->
    <!-- ====================================== -->

    <service verb="receive" noun="Asset" no-tx-cache="true">
        <!-- NOTE: tested with transaction="cache" and works fine, but only a small performance improvement (this is a fairly small service) -->
        <description>Receive an Asset</description>
        <in-parameters>
            <parameter name="assetId"><description>If specified receives to that Asset (uncommon) otherwise creates a new one.</description></parameter>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"/>

            <parameter name="productId" required="true" default="defaultProductId"/>
            <parameter name="defaultProductId"><description>Field for special forms, if passed can be used as a default for the productId parameter.</description></parameter>
            <parameter name="quantity" type="BigDecimal" default="1"/>
            <parameter name="assetTypeEnumId"><description>Defaults to Product.assetTypeEnumId</description></parameter>
            <parameter name="classEnumId"><description>Defaults to Product.assetClassEnumId</description></parameter>
            <parameter name="statusId"><description>If assetTypeEnumId == AstTpInventory then defaults to AstAvailable,
                otherwise defaults to AstInStorage.</description></parameter>
            <parameter name="receivedDate"><description>If statusId == AstIncoming then defaults to null, otherwise defaults to now.</description></parameter>

            <parameter name="assetName"><description>Defaults to OrderItem.itemDescription if available.</description></parameter>
            <parameter name="facilityId" required="true"/>
            <parameter name="ownerPartyId"><description>If not passed in and orderId and orderItemSeqId are then uses
                OrderPart.customerPartyId, otherwise uses Facility.ownerPartyId.</description></parameter>

            <parameter name="shipmentId"/>
            <parameter name="shipmentItemSourceId"/>
            <parameter name="shipmentPackageSeqId"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="returnId"/>
            <parameter name="returnItemSeqId"/>
            <parameter name="workEffortId"/>
            <parameter name="noProduceProduct" default-value="add"><description>If the asset has a productId that is
                not one of the WorkEffort produce products, "add" it, "ignore" it, or return an "error"?</description></parameter>

            <!-- Container fields -->
            <parameter name="containerId"><description>Put the new Asset in this Container, set its Facility and Location if not set.</description></parameter>
            <parameter name="containerTypeEnumId"><description>If specified and there is no containerId create a
                Container of this type (with Facility and Location) and put Asset in it (set Asset.containerId).</description></parameter>
            <parameter name="containerSerialNumber"><description>Lookup Container with this ID as an alternative to the
                containerId (if not specified), if none found create a Container with this serialNumber.</description></parameter>
            <!-- AssetReceipt fields -->
            <parameter name="quantityRejected" type="BigDecimal"/>
            <parameter name="rejectionReasonEnumId"/>
            <!-- Lot fields (note that both Asset and Lot have manufacturedDate; Asset.expectedEndOfLife is equivalent to Lot.expirationDate) -->
            <parameter name="lotNumber"><description>If specified and no there is no lotId create a Lot with this number and the
                expirationDate and mfgPartyId parameters.</description></parameter>
            <parameter name="expirationDate" type="Date"><description>Used when creating a lot, defaults to expectedEndOfLife.
                If this is specified and no expectedEndOfLife is then set expectedEndOfLife to this (regardless of whether Lot is created).</description></parameter>
            <parameter name="mfgPartyId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="assetId"/>
            <parameter name="assetReceiptId"/>
            <parameter name="assetDetailId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product"><field-map field-name="productId"/></entity-find-one>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"><field-map field-name="orderId"/></entity-find-one>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem">
                <field-map field-name="orderId"/><field-map field-name="orderItemSeqId"/></entity-find-one>
            <entity-find-one entity-name="mantle.work.effort.WorkEffort" value-field="workEffort"><field-map field-name="workEffortId"/></entity-find-one>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"><field-map field-name="facilityId"/></entity-find-one>

            <!-- set type and class from product if not passed in -->
            <set field="assetTypeEnumId" from="assetTypeEnumId ?: (product.assetTypeEnumId ?: 'AstTpInventory')"/>
            <set field="classEnumId" from="classEnumId ?: product.assetClassEnumId"/>

            <!-- get ownerPartyId from OrderPart if needed -->
            <if condition="!ownerPartyId &amp;&amp; orderItem">
                <set field="orderPart" from="orderItem?.'mantle.order.OrderPart'"/>
                <set field="ownerPartyId" from="orderPart?.customerPartyId"/>
            </if>
            <!-- get ownerPartyId from WorkEffort if needed -->
            <if condition="!ownerPartyId"><set field="ownerPartyId" from="workEffort?.ownerPartyId"/></if>
            <!-- get ownerPartyId from Facility if needed -->
            <if condition="!ownerPartyId"><set field="ownerPartyId" from="facility?.ownerPartyId"/></if>

            <!-- set default status, receivedDate, hasQuantity, and assetName -->
            <if condition="!statusId"><set field="statusId" from="assetTypeEnumId == 'AstTpInventory' ? 'AstAvailable' : 'AstInStorage'"/></if>
            <if condition="!receivedDate &amp;&amp; statusId != 'AstIncoming'"><set field="receivedDate" from="ec.user.nowTimestamp"/></if>
            <set field="hasQuantity" from="!serialNumber &amp;&amp; quantity > 1 ? 'Y' : 'N'"/>
            <set field="assetName" from="assetName ?: orderItem?.itemDescription"/>

            <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="expirationDate"/></if>

            <!-- create a Lot if needed -->
            <if condition="lotId"><then>
                <entity-find-one entity-name="mantle.product.asset.Lot" value-field="lot"><field-map field-name="lotId"/></entity-find-one>
                <if condition="manufacturedDate == null"><set field="manufacturedDate" from="lot.manufacturedDate"/></if>
                <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="lot.expirationDate"/></if>
            </then><else-if condition="lotNumber">
                <entity-find entity-name="mantle.product.asset.Lot" list="existingLots">
                    <econdition field-name="lotNumber"/><econdition field-name="mfgPartyId"/></entity-find>
                <if condition="existingLots"><then>
                    <set field="lotId" from="existingLots[0].lotId"/>
                    <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="existingLots[0].expirationDate"/></if>
                </then><else>
                    <if condition="!mfgPartyId &amp;&amp; shipmentId">
                        <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
                        <set field="mfgPartyId" from="shipment.fromPartyId"/>
                    </if>
                    <if condition="expirationDate == null"><set field="expirationDate" from="expectedEndOfLife"/></if>
                    <service-call name="create#mantle.product.asset.Lot" out-map="context"
                            in-map="[lotNumber:lotNumber, mfgPartyId:mfgPartyId, manufacturedDate:manufacturedDate, expirationDate:expirationDate]"/>
                </else></if>
            </else-if></if>

            <!-- create a Container if needed -->
            <if condition="!containerId &amp;&amp; (containerTypeEnumId || containerSerialNumber)">
                <!-- will put containerId for the new record in the context -->
                <service-call name="create#mantle.product.asset.Container" out-map="context"
                        in-map="[containerTypeEnumId:containerTypeEnumId, serialNumber:containerSerialNumber,
                            facilityId:facilityId, locationSeqId:locationSeqId, geoPointId:geoPointId]"/>
            </if>

            <!-- have originalQuantity default to quantity received -->
            <set field="originalQuantity" from="originalQuantity ?: quantity"/>

            <!-- create or update the Asset record -->
            <if condition="!assetId"><then>
                <!-- TODO: if this has a workEffortId and not an orderId get acquireCost from WorkEffort based on cost? -->
                <service-call name="create#mantle.product.asset.Asset" out-map="context"
                        in-map="context + [quantityOnHandTotal:0, availableToPromiseTotal:0,
                            acquiredDate:(orderHeader?.placedDate ?: ec.user.nowTimestamp),
                            acquireOrderId:orderId, acquireOrderItemSeqId:orderItemSeqId,
                            acquireShipmentId:shipmentId, acquireCost:(acquireCost ?: orderItem?.standardCost ?: orderItem?.unitAmount),
                            acquireCostUomId:orderHeader?.currencyUomId, acquireWorkEffortId:workEffortId]"/>
            </then><else>
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
                <set field="asset.originalQuantity" from="(asset.originalQuantity ?: 0) + originalQuantity"/>
                <set field="asset.containerId" from="asset.containerId ?: containerId"/>
                <set field="asset.geoPointId" from="asset.geoPointId ?: geoPointId"/>
                <set field="asset.acquireWorkEffortId" from="asset.acquireWorkEffortId ?: workEffortId"/>
                <set field="asset.acquireOrderId" from="asset.acquireOrderId ?: orderId"/>
                <set field="asset.acquireOrderItemSeqId" from="asset.acquireOrderItemSeqId ?: orderItemSeqId"/>
                <set field="asset.acquireShipmentId" from="asset.acquireShipmentId ?: shipmentId"/>
                <set field="asset.acquireCost" from="asset.acquireCost ?: orderItem?.standardCost ?: orderItem?.unitAmount"/>
                <set field="asset.acquireCostUomId" from="asset.acquireCostUomId ?: orderHeader?.currencyUomId"/>
                <entity-update value-field="asset"/>
            </else></if>

            <!-- create AssetReceipt -->
            <service-call name="create#mantle.product.receipt.AssetReceipt" out-map="context"
                    in-map="[assetId:assetId, productId:productId, orderId:orderId, orderItemSeqId:orderItemSeqId,
                        returnId:returnId, returnItemSeqId:returnItemSeqId, workEffortId:workEffortId,
                        shipmentId:shipmentId, shipmentItemSourceId:shipmentItemSourceId,
                        shipmentPackageSeqId:shipmentPackageSeqId, receivedByUserId:ec.user.userId,
                        receivedDate:receivedDate, quantityAccepted:quantity, quantityRejected:quantityRejected,
                        rejectionReasonEnumId:rejectionReasonEnumId]"/>

            <!-- if there are OrderItemBilling records matching orderId, orderItemSeqId, and shipmentId set assetReceiptId -->
            <if condition="orderId &amp;&amp; orderItemSeqId &amp;&amp; shipmentId">
                <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                    <econdition field-name="shipmentId"/><econdition field-name="assetReceiptId" from="null"/>
                </entity-find>
                <iterate list="orderItemBillingList" entry="orderItemBilling">
                    <set field="orderItemBilling.assetReceiptId" from="assetReceiptId"/>
                    <entity-update value-field="orderItemBilling"/>
                </iterate>
            </if>

            <!-- create AssetDetail -->
            <!-- don't do this, better to make always available given how ATP is used for issuance/etc: <set field="availableToPromiseDiff" from="statusId == 'AstAvailable' ? quantity : 0"/> -->
            <set field="availableToPromiseDiff" from="quantity"/>
            <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                    in-map="[assetId:assetId, effectiveDate:(receivedDate ?: ec.user.nowTimestamp), quantityOnHandDiff:quantity,
                        availableToPromiseDiff:availableToPromiseDiff, unitCost:orderItem?.unitAmount,
                        shipmentId:shipmentId, productId:productId, returnId:returnId, returnItemSeqId:returnItemSeqId,
                        workEffortId:workEffortId, assetReceiptId:assetReceiptId]"/>

            <!-- if this is for a WorkEffort (production run, etc)  -->
            <if condition="workEffortId">
                <entity-find entity-name="mantle.work.effort.WorkEffortProduct" list="produceProductList">
                    <date-filter/>
                    <econdition field-name="workEffortId"/><econdition field-name="productId"/>
                    <econdition field-name="typeEnumId" value="WeptProduce"/>
                </entity-find>
                <if condition="!produceProductList">
                    <if condition="noProduceProduct == 'error'"><then>
                        <message error="true">Not issuing Asset [${assetId}], Product ${ec.resource.expand('ProductNameTemplate','',product)} is not a product to produce</message>
                    </then><else-if condition="noProduceProduct != 'ignore'">
                        <service-call name="create#mantle.work.effort.WorkEffortProduct" in-map="[workEffortId:workEffortId,
                            productId:productId, typeEnumId:'WeptProduce', estimatedQuantity:quantity]"/>
                    </else-if></if>
                </if>
            </if>

            <!-- call through AssetDetail create? NO, would get called from the move#AssetReservation record recursively -->
            <!-- reserve the newly available Asset, if needed -->
            <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
        </actions>
    </service>

    <service verb="update" noun="AssetAndReceipt" no-tx-cache="true">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="assetReceiptId"><description>If not specified will look it up with assetId and shipmentId.</description></parameter>
            <parameter name="shipmentId"/>
            <auto-parameters entity-name="mantle.product.receipt.AssetReceipt" include="nonpk"/>
            <auto-parameters entity-name="mantle.product.asset.AssetDetail" include="nonpk">
                <exclude field-name="availableToPromiseDiff"/>
                <exclude field-name="quantityOnHandDiff"/>
            </auto-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk">
                <exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="quantityOnHandTotal"/>
            </auto-parameters>
            <parameter name="receivedDate"><description>If statusId == AstIncoming then no default, otherwise defaults to now.</description></parameter>
            <!-- Lot fields (note that both Asset and Lot have manufacturedDate; Asset.expectedEndOfLife is equivalent to Lot.expirationDate) -->
            <parameter name="lotNumber"><description>If specified and no there is no lotId create a Lot with this number and the
                expirationDate and mfgPartyId parameters.</description></parameter>
            <parameter name="expirationDate" type="Date"><description>Used when creating a lot, defaults to expectedEndOfLife.
                If this is specified and no expectedEndOfLife is then set expectedEndOfLife to this (regardless of whether Lot is created).</description></parameter>
            <parameter name="mfgPartyId"/>
        </in-parameters>
        <out-parameters><parameter name="assetDetailId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
            <set field="oldStatusId" from="asset.statusId"/>
            <set field="oldAtp" from="asset.availableToPromiseTotal"/>
            <set field="oldQoh" from="asset.quantityOnHandTotal"/>
            <set field="oldAcquireCost" from="asset.acquireCost"/>

            <!-- update the AssetReceipt -->
            <if condition="!assetReceiptId"><then>
                <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="assetReceiptList">
                    <econdition field-name="assetId"/><econdition field-name="shipmentId"/>
                    <order-by field-name="assetReceiptId"/>
                </entity-find>
                <set field="originalAssetReceipt" from="assetReceiptList?.first"/>
                <set field="assetReceiptId" from="originalAssetReceipt?.assetReceiptId"/>
            </then><else>
                <entity-find-one entity-name="mantle.product.receipt.AssetReceipt" value-field="originalAssetReceipt"/>
            </else></if>
            <if condition="!assetReceiptId"><return error="true" message="Cannot update Asset and Receipt, could not find AssetReceipt record for assetId [${assetId}], shipmentId [${shipmentId}]"/></if>

            <!-- calculate the quantityAccepted difference, will be set in quantityOnHandDiff and availableToPromiseDiff -->
            <set field="quantityDiff" from="(quantityAccepted != null ? quantityAccepted : originalAssetReceipt.quantityAccepted) - originalAssetReceipt.quantityAccepted"/>
            <set field="quantityRejectedDiff" from="(quantityRejected != null ? quantityRejected : originalAssetReceipt.quantityRejected) - originalAssetReceipt.quantityRejected"/>

            <!-- <log level="warn" message="======= quantityAccepted ${quantityAccepted}, quantityRejected ${quantityRejected}, quantityDiff ${quantityDiff}, originalAssetReceipt: ${originalAssetReceipt}"/> -->

            <!-- Ensure the ShipmentItem has sufficient remaining quantity -->
            <set field="newQuantityRemaining" from="(quantityDiff ?: 0) + (quantityRejectedDiff ?: 0)"/>
            <if condition="newQuantityRemaining">
                <service-call name="mantle.shipment.ShipmentServices.ensure#ShipmentItemQuantityRemaining"
                        in-map="[shipmentId:shipmentId, productId:productId, newQuantityRemaining:newQuantityRemaining]"/>
            </if>

            <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="expirationDate"/></if>

            <!-- create a Lot if needed -->
            <if condition="lotId"><then>
                <entity-find-one entity-name="mantle.product.asset.Lot" value-field="lot"><field-map field-name="lotId"/></entity-find-one>
                <if condition="manufacturedDate == null"><set field="manufacturedDate" from="lot.manufacturedDate"/></if>
                <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="lot.expirationDate"/></if>
            </then><else-if condition="lotNumber">
                <entity-find entity-name="mantle.product.asset.Lot" list="existingLots">
                    <econdition field-name="lotNumber"/><econdition field-name="mfgPartyId"/></entity-find>
                <if condition="existingLots"><then>
                    <set field="lotId" from="existingLots[0].lotId"/>
                    <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="existingLots[0].expirationDate"/></if>
                </then><else>
                    <if condition="!mfgPartyId &amp;&amp; shipmentId">
                        <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
                        <set field="mfgPartyId" from="shipment.fromPartyId"/>
                    </if>
                    <if condition="expirationDate == null"><set field="expirationDate" from="expectedEndOfLife"/></if>
                    <service-call name="create#mantle.product.asset.Lot" out-map="context"
                            in-map="[lotNumber:lotNumber, mfgPartyId:mfgPartyId, manufacturedDate:manufacturedDate, expirationDate:expirationDate]"/>
                </else></if>
            </else-if></if>

            <!-- update AssetReceipt -->
            <service-call name="update#mantle.product.receipt.AssetReceipt" in-map="context" out-map="context"/>

            <if condition="!receivedDate &amp;&amp; statusId &amp;&amp; statusId != 'AstIncoming'">
                <set field="receivedDate" from="ec.user.nowTimestamp"/></if>

            <!-- update the Asset record -->
            <service-call name="update#mantle.product.asset.Asset" in-map="context" out-map="context"/>

            <!-- before adjusting new quantity see if we just changed status to Available and if so set ATP to QOH -->
            <if condition="oldAtp &lt;= 0 &amp;&amp; statusId == 'AstAvailable' &amp;&amp; oldStatusId != 'AstAvailable'">
                <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                        in-map="[assetId:assetId, effectiveDate:receivedDate, quantityOnHandDiff:0,
                        availableToPromiseDiff:oldQoh, shipmentId:shipmentId, productId:asset.productId,
                        assetReceiptId:assetReceiptId]"/>

                <!-- reserve the newly available Asset, if needed -->
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
            </if>

            <if condition="quantityDiff != 0"><service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context"/></if>

            <!-- if acquireCost is updated adjust the GL, if set from null do GL posting -->
            <!-- if quantityAccepted is updated and GL entry exists adjust the GL! -->
            <if condition="(acquireCost != null &amp;&amp; acquireCost != oldAcquireCost) ||
                    (quantityAccepted != null &amp;&amp; quantityAccepted != originalAssetReceipt.quantityAccepted)">
                <service-call name="mantle.ledger.AssetAutoPostServices.repost#Asset" in-map="[assetId:assetId]"/>
            </if>
        </actions>
    </service>

    <!-- ==================================== -->
    <!-- ========== Other Services ========== -->
    <!-- ==================================== -->

    <service verb="replace" noun="AssetPartyAssignment">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="roleTypeId" required="true"/>
            <parameter name="newPartyId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.AssetPartyAssignment" list="apaList">
                <date-filter/><econdition field-name="assetId"/><econdition field-name="roleTypeId"/></entity-find>
            <set field="foundExisting" from="false"/>
            <iterate list="apaList" entry="apaValue">
                <if condition="apaValue.partyId != newPartyId"><then>
                    <set field="apaValue.thruDate" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="apaValue"/>
                </then><else>
                    <set field="foundExisting" from="true"/>
                </else></if>
            </iterate>
            <if condition="!foundExisting">
                <service-call name="create#mantle.product.asset.AssetPartyAssignment" in-map="[assetId:assetId,
                    partyId:newPartyId, roleTypeId:roleTypeId, fromDate:ec.user.nowTimestamp]"/>
            </if>
        </actions>
    </service>
    <service verb="move" noun="Asset">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="facilityId"><description>Defaults to current facilityId</description></parameter>
            <parameter name="locationSeqId"/>
            <parameter name="containerId"><description>May be actual containerId or serialNumber</description></parameter>
            <parameter name="scanLocation"><description>May be locationSeqId within facility, containerId, or container serialNumber</description></parameter>
            <parameter name="quantity" type="BigDecimal"><description>Defaults to quantityOnHandTotal if hasQuantity, generally move entire Asset</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <if condition="asset == null"><message error="true">No asset found for ID ${assetId}</message></if>
            <if condition="!facilityId"><set field="facilityId" from="asset.facilityId"/></if>

            <!-- see if scanLocation is a locationSeqId in the Facility -->
            <if condition="scanLocation &amp;&amp; facilityId">
                <entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                    <field-map field-name="facilityId"/>
                    <field-map field-name="locationSeqId" from="scanLocation"/>
                </entity-find-one>
                <if condition="checkFacLoc != null">
                    <set field="locationSeqId" from="checkFacLoc.locationSeqId"/>
                    <set field="scanLocation" from="null"/>
                </if>
            </if>
            <!-- see if scanLocation is a containerId -->
            <if condition="scanLocation">
                <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                    <field-map field-name="containerId" from="scanLocation"/></entity-find-one>
                <if condition="container != null">
                    <set field="containerId" from="container.containerId"/>
                    <set field="scanLocation" from="null"/>
                </if>
            </if>
            <!-- see if scanLocation is a Container.serialNumber -->
            <if condition="scanLocation">
                <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                    <field-map field-name="serialNumber" from="scanLocation"/></entity-find-one>
                <if condition="container != null">
                    <set field="containerId" from="container.containerId"/>
                    <set field="scanLocation" from="null"/>
                </if>
            </if>

            <!-- get facilityId and locationSeqId from Container, do here instead of relying on EECA rule just in case involves a move to another facility -->
            <if condition="containerId"><then>
                <if condition="container == null">
                    <entity-find-one entity-name="mantle.product.asset.Container" value-field="container"/></if>
                <if condition="container == null">
                    <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                        <field-map field-name="serialNumber" from="containerId"/></entity-find-one>
                    <if condition="container == null"><return error="true" message="Container not found with ID or serial number ${containerId}"/></if>
                    <set field="containerId" from="container.containerId"/>
                </if>
                <set field="facilityId" from="container.facilityId"/>
                <set field="locationSeqId" from="container.locationSeqId"/>
            </then><else-if condition="asset.containerId">
                <!-- no containerId passed but Asset has containerId, clear otherwise new location won't get set (will be overridden by container -->
                <set field="asset.containerId" from="null"/>
                <entity-update value-field="asset"/>
            </else-if></if>

            <set field="facLoc" from="asset.location"/>
            <if condition="locationSeqId">
                <if condition="checkFacLoc == null"><entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                    <field-map field-name="facilityId"/><field-map field-name="locationSeqId"/></entity-find-one></if>
                <if condition="checkFacLoc == null"><return error="true" message="Location [${locationSeqId}] is not valid in facility ${ec.resource.expand('FacilityNameTemplate', '', asset.facility)}"/></if>
            </if>
            <if condition="asset.hasQuantity != 'N'">
                <if condition="!quantity"><set field="quantity" from="asset.quantityOnHandTotal"/></if>
                <if condition="quantity &gt; asset.quantityOnHandTotal">
                    <return error="true" message="Move quantity ${quantity?.toPlainString()} is greater than on hand quantity ${asset.quantityOnHandTotal?.toPlainString()}"/></if>
                <if condition="quantity &gt; asset.availableToPromiseTotal">
                    <message>Warning: move quantity ${quantity?.toPlainString()} is greater than available quantity ${asset.availableToPromiseTotal?.toPlainString()}</message>
                </if>
            </if>

            <!-- for partial quantity or facilityId change reduce quantity on original and create new with given quantity -->
            <if condition="(quantity &amp;&amp; quantity &lt; asset.quantityOnHandTotal) || (facilityId &amp;&amp; facilityId != asset.facilityId)"><then>
                <!-- clone asset in new facility/location with quantity -->
                <service-call name="create#mantle.product.asset.Asset" out-map="newAssetOut"
                        in-map="asset.getMap() + [assetId:null, facilityId:facilityId, locationSeqId:locationSeqId,
                                containerId:containerId, quantityOnHandTotal:0, availableToPromiseTotal:0]"/>
                <set field="newAssetId" from="newAssetOut.assetId"/>
                <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                        in-map="[assetId:newAssetId, effectiveDate:ec.user.nowTimestamp, quantityOnHandDiff:quantity,
                                 availableToPromiseDiff:quantity, productId:productId, otherAssetId:assetId]"/>

                <if condition="quantity &gt; asset.availableToPromiseTotal">
                    <if condition="facilityId != asset.facilityId"><then>
                        <!-- for move to a different facility displace reservations on original, don't do reservations on newAsset -->
                        <service-call name="mantle.product.AssetServices.displace#AssetReservations"
                                in-map="[assetId:assetId, quantity:quantity]"/>
                    </then><else>
                        <!-- move reservations as needed -->
                        <set field="availableRemaining" from="quantity - asset.availableToPromiseTotal"/>
                        <entity-find entity-name="mantle.product.issuance.AssetReservation" list="resList">
                            <econdition field-name="assetId"/><order-by field-name="reservedDate"/></entity-find>
                        <iterate list="resList" entry="res">
                            <if condition="availableRemaining == 0"><break/></if>
                            <set field="quantityToMove" from="availableRemaining &lt; res.quantity ? availableRemaining : res.quantity"/>
                            <if condition="quantityToMove == 0"><continue/></if>
                            <!-- make sure quantityToMove is less than res.quantityNotIssued, don't move issued quantities! -->
                            <if condition="quantityToMove &gt; res.quantityNotIssued"><set field="quantityToMove" from="res.quantityNotIssued"/></if>
                            <if condition="quantityToMove &gt; 0">
                                <service-call name="mantle.product.AssetServices.move#AssetReservation" out-map="moveArOut"
                                        in-map="[assetId:newAssetId, assetReservationId:res.assetReservationId, quantity:quantityToMove]"/>
                                <set field="availableRemaining" from="availableRemaining - moveArOut.quantityMoved"/>
                            </if>
                        </iterate>
                    </else></if>
                </if>

                <!-- reduce asset QOH/ATP by quantity -->
                <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                        in-map="[assetId:assetId, effectiveDate:ec.user.nowTimestamp, quantityOnHandDiff:-quantity,
                                 availableToPromiseDiff:-quantity, productId:productId, otherAssetId:newAssetId]"/>
            </then><else>
                <service-call name="update#mantle.product.asset.Asset" in-map="context"/>
            </else></if>

            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="newAsset"/>
            <set field="newFacLoc" from="newAsset.location"/>
            <message>Moved asset ${ec.resource.expand('AssetNameTemplate', '', asset)} from ${ec.resource.expand('FacilityLocationNameTemplate', '', facLoc?:[:])} to ${ec.resource.expand('FacilityLocationNameTemplate', '', newFacLoc?:[:])}${container ? ' in container ' + (container.serialNumber ?: container.description ?: containerId) : ''}.</message>
        </actions>
    </service>

    <!-- ================================================= -->
    <!-- ========== Physical Inventory Services ========== -->
    <!-- ================================================= -->

    <service verb="record" noun="PhysicalInventoryQuantity" no-tx-cache="true">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"><exclude field-name="classEnumId"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="hasQuantity"/><exclude field-name="receivedDate"/><exclude field-name="acquiredDate"/></auto-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="physicalInventoryId"/>
            <parameter name="physicalInventoryCountId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="partyId" default="ec.user.userAccount.partyId"/>
            <parameter name="physicalInventoryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="varianceReasonEnumId"/>
        </in-parameters>
        <out-parameters><parameter name="physicalInventoryId"/></out-parameters>
        <actions>
            <if condition="physicalInventoryCountId">
                <service-call name="update#mantle.product.asset.PhysicalInventoryCount"
                              in-map="[physicalInventoryCountId:physicalInventoryCountId, quantityOnHand:quantity]"/>
            </if>

            <set field="currentQoh" from="0"/>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/><econdition field-name="facilityId"/>
                <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0"/>
                <econdition field-name="locationSeqId" ignore-if-empty="true"/>
                <econdition field-name="lotId" ignore-if-empty="true"/>
            </entity-find>
            <iterate list="assetList" entry="asset"><set field="currentQoh" from="currentQoh + asset.quantityOnHandTotal"/></iterate>

            <set field="quantityChange" from="quantity - currentQoh"/>
            <if condition="quantityChange">
                <service-call name="mantle.product.AssetServices.record#PhysicalInventoryChange" in-map="context"/></if>
        </actions>
    </service>
    <service verb="record" noun="PhysicalInventoryChange" no-tx-cache="true">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"><exclude field-name="classEnumId"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="hasQuantity"/><exclude field-name="receivedDate"/><exclude field-name="acquiredDate"/></auto-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="physicalInventoryId"/>
            <parameter name="physicalInventoryCountId"/>
            <parameter name="quantityChange" type="BigDecimal" required="true"/>
            <parameter name="partyId" default="ec.user.userAccount.partyId"/>
            <parameter name="physicalInventoryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="varianceReasonEnumId"/>
            <parameter name="assetList" type="EntityList">
                <description>Optional, meant to be used when called by other physical inventory services.</description>
                <parameter name="asset" type="EntityValue"/>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="physicalInventoryId"/>
            <parameter name="quantityRemaining" type="BigDecimal"><description>Always zero (0) if quantityChange is
                greater than zero. If quantityChange is less than zero and could not find enough quantity on hand this
                is the quantity that could not be removed.</description></parameter>
            <parameter name="assetIdList" type="List"/>
        </out-parameters>
        <actions>
            <!-- set the date to be used on AssetDetail records -->
            <set field="effectiveDate" from="physicalInventoryDate"/>
            <!-- create the PhysicalInventory inventory record -->
            <if condition="!physicalInventoryId">
                <service-call name="create#mantle.product.asset.PhysicalInventory" in-map="context" out-map="context"/></if>

            <if condition="!ownerPartyId">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"/>
                <set field="ownerPartyId" from="facility.ownerPartyId"/>
            </if>
            <set field="assetIdList" from="[]"/>

            <!-- <log level="warn" message="======= Changing product [${productId}] in facility [${facilityId}:${locationSeqId}] by ${quantityChange}; assetList: ${assetList}"/> -->
            <if condition="quantityChange &gt; 0.0"><then>
                <if condition="assetList"><then>
                    <set field="quantityRemaining" from="quantityChange"/>
                    <iterate list="assetList" entry="asset">
                        <!-- NOTE: no real reason for iterating here, will always add it all to the first Asset record; leaving it for now to make more complex logic easier in the future -->
                        <set field="quantityDiff" from="quantityRemaining"/>
                        <if condition="quantityDiff != 0">
                            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context + [assetId:asset.assetId]"/></if>
                        <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                        <script>assetIdList.add(asset.assetId)</script>
                        <if condition="quantityRemaining == 0"><break/></if>
                    </iterate>
                </then><else>
                    <set field="quantityRemaining" from="0.0"/>
                    <!-- no passed assetList and quantityChange > 0, create new Asset -->
                    <service-call name="mantle.product.AssetServices.create#ProductAssetAdHoc" out-map="context"
                            in-map="context + [createdDate:physicalInventoryDate]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                            in-map="[assetId:assetId, effectiveDate:physicalInventoryDate, quantityOnHandDiff:quantityChange,
                                availableToPromiseDiff:quantityChange, productId:productId,
                                physicalInventoryId:physicalInventoryId, physicalInventoryCountId:physicalInventoryCountId,
                                varianceReasonEnumId:varianceReasonEnumId]"/>
                    <!-- reserve the newly available Asset, if needed -->
                    <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
                    <script>assetIdList.add(assetId)</script>
                </else></if>
            </then><else-if condition="quantityChange &lt; 0.0">
                <if condition="!assetList">
                    <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                        <econdition field-name="productId"/><econdition field-name="facilityId"/>
                        <econdition field-name="locationSeqId" ignore-if-empty="true"/>
                        <econdition field-name="lotId" ignore-if-empty="true"/>
                        <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0"/>
                        <econdition field-name="ownerPartyId" ignore-if-empty="true"/>
                        <order-by field-name="receivedDate"/><!-- oldest first -->
                        <order-by field-name="-quantityOnHandTotal"/><!-- then by most QOH (should be rare in real world, useful mostly for consistency in tests) -->
                        <order-by field-name="-assetId"/><!-- by ID to make sure we have a consistent order for locking -->
                    </entity-find>
                </if>

                <!-- lock the records we need -->
                <set field="quantityRemaining" from="-quantityChange"/>
                <set field="lockedAssetList" from="[]"/>
                <iterate list="assetList" entry="asset">
                    <set field="quantityDiff" from="quantityRemaining &gt; asset.quantityOnHandTotal ? asset.quantityOnHandTotal : quantityRemaining"/>
                    <if condition="quantityDiff != 0.0">
                        <!-- get a locked record -->
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="lockedAsset" for-update="true">
                            <field-map field-name="assetId" from="asset.assetId"/></entity-find-one>
                        <set field="quantityDiff" from="quantityRemaining &gt; lockedAsset.quantityOnHandTotal ? lockedAsset.quantityOnHandTotal : quantityRemaining"/>
                        <if condition="quantityDiff != 0.0">
                            <script>lockedAssetList.add(lockedAsset)</script>
                            <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                        </if>
                    </if>
                    <if condition="quantityRemaining == 0.0"><break/></if>
                </iterate>

                <!-- do the actual quantity changes -->
                <set field="quantityRemaining" from="-quantityChange"/>
                <iterate list="lockedAssetList" entry="asset">
                    <set field="quantityDiff" from="quantityRemaining &gt; asset.quantityOnHandTotal ? asset.quantityOnHandTotal : quantityRemaining"/>
                    <if condition="quantityDiff != 0.0">
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context +
                                [assetId:asset.assetId, quantityDiff:-quantityDiff]"/></if>
                    <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                    <script>assetIdList.add(asset.assetId)</script>
                    <if condition="quantityRemaining == 0.0"><break/></if>
                </iterate>
            </else-if></if>
            <if condition="quantityRemaining != 0">
                <message>Could not reduce quantity by ${quantityRemaining}, insufficient quantity on hand.</message></if>
        </actions>
    </service>
    <service verb="create" noun="ProductAssetAdHoc">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"><exclude field-name="classEnumId"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="hasQuantity"/><exclude field-name="receivedDate"/><exclude field-name="acquiredDate"/></auto-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="createdDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters><parameter name="assetId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
            <set field="assetTypeEnumId" from="product.assetTypeEnumId ?: 'AstTpInventory'"/>
            <set field="statusId" from="assetTypeEnumId == 'AstTpInventory' ? 'AstAvailable' : 'AstInStorage'"/>
            <if condition="!acquireCost">
                <!-- we may want more options for this, for now grab the most recent record to try to find a reasonable cost -->
                <entity-find entity-name="mantle.product.asset.Asset" list="costAssetList" limit="1">
                    <econdition field-name="productId"/><econdition field-name="facilityId"/>
                    <econdition field-name="ownerPartyId" ignore-if-empty="true"/>
                    <order-by field-name="-assetId"/>
                </entity-find>
                <if condition="costAssetList">
                    <set field="acquireCost" from="costAssetList[0].acquireCost"/>
                    <set field="acquireCostUomId" from="costAssetList[0].acquireCostUomId"/>
                </if>
            </if>
            <service-call name="create#mantle.product.asset.Asset" out-map="assetOut"
                    in-map="context + [classEnumId:product.assetClassEnumId, quantityOnHandTotal:0, availableToPromiseTotal:0,
                        hasQuantity:'Y', receivedDate:createdDate, acquiredDate:createdDate]"/>
            <set field="assetId" from="assetOut.assetId"/>
        </actions>
    </service>
</services>
