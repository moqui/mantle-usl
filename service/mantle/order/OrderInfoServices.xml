<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="get" noun="OrderDisplayInfo">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="templateSettingSuffix" default-value="TemplateOrderPrint"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderId"/>
            <parameter name="orderHeader" type="Map"><auto-parameters entity-name="mantle.order.OrderHeader"/></parameter>
            <parameter name="productStore" type="Map"/>
            <parameter name="statusItem" type="Map"><auto-parameters entity-name="moqui.basic.StatusItem"/></parameter>
            <parameter name="editableStatusIds" type="Set"><parameter name="statusId"/></parameter>
            <parameter name="orderEditable" type="Boolean"/>
            <parameter name="placeWarnings" type="List"><parameter name="placeWarning"/></parameter>

            <parameter name="orderItemList" type="List"><parameter name="orderItem" type="Map">
                <auto-parameters entity-name="mantle.order.OrderItem"/></parameter></parameter>
            <parameter name="allItemsAuditLogList" type="List"><parameter name="orderItem" type="Map"/></parameter>
            <parameter name="orderItemWithChildrenSet" type="Set"><parameter name="orderItemSeqId"/></parameter>

            <parameter name="orderPromoCodeDetailList" type="List"><parameter name="orderPromoCode" type="Map"/></parameter>
            <parameter name="paymentList" type="List"><parameter name="payment" type="Map">
                <auto-parameters entity-name="mantle.account.payment.Payment"/></parameter></parameter>

            <parameter name="shipmentItemSourceList" type="List"><parameter name="sis" type="Map">
                <auto-parameters entity-name="mantle.shipment.ShipmentItemSource"/></parameter></parameter>
            <parameter name="shipmentIdSet" type="Set"><parameter name="shipmentId"/></parameter>
            <parameter name="quantityNotShippedByItem" type="Map">
                <description>Key is orderItemSeqId, value is quantity not shipped for item.</description></parameter>
            <parameter name="quantityNotShippedByPart" type="Map">
                <description>Key is orderPartSeqId, value is quantity not shipped for all items in part.</description></parameter>

            <parameter name="orderItemBillingList" type="List"><parameter name="oib" type="Map">
                <auto-parameters entity-name="mantle.order.OrderItemBilling"/></parameter></parameter>
            <parameter name="invoiceIdSet" type="Set"><parameter name="invoiceId"/></parameter>
            <parameter name="quantityNotBilledByItem" type="Map">
                <description>Key is orderItemSeqId, value is quantity not billed for item.</description></parameter>
            <parameter name="quantityNotBilledByPart" type="Map">
                <description>Key is orderPartSeqId, value is quantity not billed for all items in part.</description></parameter>

            <parameter name="returnItemList" type="List"><parameter name="returnItem" type="Map">
                <auto-parameters entity-name="mantle.order.return.ReturnItem"/></parameter></parameter>

            <parameter name="requestItemOrderList" type="List"><parameter name="rio" type="Map">
                <auto-parameters entity-name="mantle.request.RequestItemOrder"/></parameter></parameter>
            <parameter name="requestIdSet" type="Set"><parameter name="requestId"/></parameter>

            <parameter name="statusHistoryList" type="List"><parameter name="auditLog" type="Map">
                <auto-parameters entity-name="moqui.entity.EntityAuditLog"/></parameter></parameter>
            <parameter name="orderNoteList" type="List"><parameter name="orderNote" type="Map">
                <auto-parameters entity-name="mantle.order.OrderNote"/></parameter></parameter>

            <parameter name="orderPartList" type="List"><parameter name="orderPart" type="Map">
                <auto-parameters entity-name="mantle.order.OrderPart"/></parameter></parameter>
            <parameter name="firstPart" type="Map"/>
            <parameter name="firstPartInfo" type="Map"/>
            <parameter name="orderPartInfoList" type="List"><parameter name="orderPartInfo" type="Map">
                <parameter name="orderPart" type="Map"><auto-parameters entity-name="mantle.order.OrderPart"/></parameter>
                <parameter name="partEditable" type="Boolean"/>
                <parameter name="partOrderItemList" type="List"><parameter name="partOrderItem" type="Map">
                    <auto-parameters entity-name="mantle.order.OrderItem"/></parameter></parameter>
                <parameter name="partNoParentOrderItemList" type="List"><parameter name="partOrderItem" type="Map">
                    <auto-parameters entity-name="mantle.order.OrderItem"/></parameter></parameter>
                <parameter name="hasShippableItems" type="Boolean"/>
                <parameter name="singleLot" type="Boolean"/>
                <parameter name="newerInventory" type="Boolean"/>
                <parameter name="shipmentMethodEnum" type="Map">
                    <auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
                <parameter name="partPaymentList" type="List"><parameter name="partPayment" type="Map">
                    <auto-parameters entity-name="mantle.account.payment.Payment"/></parameter></parameter>
                <parameter name="partPaymentInfoList" type="List"><parameter name="partPaymentInfo" type="Map">
                    <parameter name="partPayment" type="Map"><auto-parameters entity-name="mantle.account.payment.Payment"/></parameter>
                    <parameter name="statusItem" type="Map"><auto-parameters entity-name="moqui.basic.StatusItem"/></parameter>
                    <parameter name="paymentMethod" type="Map"><auto-parameters entity-name="mantle.account.method.PaymentMethod"/></parameter>
                    <parameter name="creditCard" type="Map"><auto-parameters entity-name="mantle.account.method.CreditCard"/></parameter>
                    <parameter name="creditCardTypeEnum" type="Map"><auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
                    <parameter name="maskedCardNumber"/>
                    <parameter name="postalAddress" type="Map"><auto-parameters entity-name="mantle.party.contact.PostalAddress"/></parameter>
                    <parameter name="postalAddressStateGeo" type="Map"><auto-parameters entity-name="moqui.basic.Geo"/></parameter>
                    <parameter name="telecomNumber" type="Map"><auto-parameters entity-name="mantle.party.contact.TelecomNumber"/></parameter>
                    <parameter name="paymentMethodTypeEnum" type="Map"><auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
                    <parameter name="paymentInstrumentEnum" type="Map"><auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
                </parameter></parameter>
                <parameter name="paymentsTotal" type="BigDecimal"/>
                <parameter name="partTotalUnpaid" type="BigDecimal"/>
                <parameter name="postalAddress" type="Map">
                    <auto-parameters entity-name="mantle.party.contact.PostalAddress"/></parameter>
                <parameter name="postalAddressStateGeo" type="Map">
                    <auto-parameters entity-name="moqui.basic.Geo"/></parameter>
                <parameter name="telecomNumber" type="Map">
                    <auto-parameters entity-name="mantle.party.contact.TelecomNumber"/></parameter>
                <parameter name="facility" type="Map">
                    <auto-parameters entity-name="mantle.facility.Facility"/></parameter>
                <parameter name="facilityContactInfo" type="Map">
                    <parameter name="postalContactMechId"/>
                    <parameter name="postalContactMechPurposeId"/>
                    <parameter name="postalAddress" type="Map">
                        <auto-parameters entity-name="mantle.party.contact.PostalAddress"/></parameter>
                    <parameter name="postalAddressStateGeo" type="Map">
                        <auto-parameters entity-name="moqui.basic.Geo"/></parameter>
                    <parameter name="postalAddressGeoPoint" type="Map">
                        <auto-parameters entity-name="moqui.basic.GeoPoint"/></parameter>
                    <parameter name="telecomContactMechId"/>
                    <parameter name="telecomContactMechPurposeId"/>
                    <parameter name="telecomNumber" type="Map">
                        <auto-parameters entity-name="mantle.party.contact.TelecomNumber"/></parameter>
                </parameter>
                <parameter name="customerDetail" type="Map"><auto-parameters entity-name="mantle.party.PartyDetail"/></parameter>
                <parameter name="customerEmail"/>
                <parameter name="vendorDetail" type="Map"><auto-parameters entity-name="mantle.party.PartyDetail"/></parameter>
                <parameter name="isCustomerInternalOrg" type="Boolean"/>
                <parameter name="isVendorInternalOrg" type="Boolean"/>
                <parameter name="orderPartPartyList" type="List"><parameter name="orderPartParty">
                    <auto-parameters entity-name="mantle.order.OrderPartPartyDetail"/></parameter></parameter>
                <parameter name="customerShipToDetail" type="Map">
                    <auto-parameters entity-name="mantle.order.OrderPartPartyDetail"/></parameter>
                <parameter name="customerBillToDetail" type="Map">
                    <auto-parameters entity-name="mantle.order.OrderPartPartyDetail"/></parameter>
                <parameter name="partShipmentItemSourceList" type="List"><parameter name="partSis" type="Map">
                    <auto-parameters entity-name="mantle.shipment.ShipmentItemSource"/></parameter></parameter>
                <parameter name="partShipmentIdSet" type="Set"><parameter name="partShipmentId"/></parameter>
            </parameter></parameter>

            <parameter name="templateLocation"><description>Looked up from ProductStoreSetting and if no setting found for store or
                no store is associated with the Order then from PartySetting (for vendorPartyId).</description></parameter>
        </out-parameters>
        <actions>
            <set field="placeWarnings" from="[]"/>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <if condition="orderHeader == null"><return error="true" message="Order not found with ID ${orderId}"/></if>
            <!--
            <set field="headerMaster" from="orderHeader.getMasterValueMap('default')"/>
            <log message="======== Order Master:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(headerMaster))}"/>
            -->

            <set field="productStore" from="orderHeader.productStore"/>

            <set field="statusItem" from="orderHeader.status"/>
            <!-- NOTE: these statuses are fairly liberal, may want to restrict more in certain scenarios (such as customer changing an order) -->
            <set field="editableStatusIds" from="new HashSet(['OrderBeingChanged', 'OrderOpen', 'OrderRequested',
                'OrderProposed', 'OrderPlaced', 'OrderHold', 'OrderProcessing', 'OrderWishList', 'OrderGiftRegistry', 'OrderAutoReorder'])"/>
            <set field="orderEditable" from="editableStatusIds.contains(orderHeader.statusId)"/>

            <entity-find-related value-field="orderHeader" relationship-name="mantle.order.OrderItem"
                    list="orderItemList" order-by-list="['orderItemSeqId']"/>
            <if condition="!orderItemList"><script>placeWarnings.add("Order has no items")</script></if>
            <!-- put items with parentItemSeqId in the list after their parent -->
            <script><![CDATA[
                orderItemWithChildrenSet = new HashSet()
                List reverseList = orderItemList.cloneList().orderByFields(["-orderItemSeqId"])
                for (orderItem in reverseList) {
                    if (orderItem.parentItemSeqId) {
                        orderItemWithChildrenSet.add(orderItem.parentItemSeqId)
                        orderItemList.move(orderItemList.indexMatching([orderItemSeqId:orderItem.orderItemSeqId]),
                                orderItemList.indexMatching([orderItemSeqId:orderItem.parentItemSeqId])+1)
                    }
                }
            ]]></script>
            <entity-find entity-name="moqui.entity.EntityAuditLog" list="allItemsAuditLogList">
                <econdition field-name="changedEntityName" value="mantle.order.OrderItem"/>
                <econdition field-name="changedFieldName" operator="in" value="quantity,unitAmount"/>
                <econdition field-name="pkPrimaryValue" from="orderId"/>
                <select-field field-name="changedFieldName,pkSecondaryValue,newValueText,oldValueText,changeReason,changedByUserId,changedDate"/>
                <order-by field-name="-changedDate"/>
            </entity-find>

            <!-- get orderPromoCodeDetailList -->
            <entity-find entity-name="mantle.product.store.OrderPromoCodeDetail" list="orderPromoCodeDetailList">
                <econdition field-name="orderId"/></entity-find>
            <!-- get paymentList -->
            <entity-find-related value-field="orderHeader" relationship-name="mantle.account.payment.Payment"
                    list="paymentList" order-by-list="['paymentId']"/>

            <!-- get ShipmentItemSource list and derived data -->
            <entity-find entity-name="mantle.shipment.ShipmentAndItemSource" list="shipmentItemSourceList">
                <econdition field-name="orderId"/>
                <econdition field-name="shipmentStatusId" operator="not-in" value="ShipRejected,ShipCancelled"/>
                <econdition field-name="statusId" operator="not-equals" value="SisCancelled"/>
            </entity-find>
            <set field="shipmentIdSet" from="new TreeSet()"/>
            <set field="quantityNotShippedByItem" from="[:]"/>
            <set field="quantityNotShippedByPart" from="[:]"/>
            <script>
                for (orderItem in orderItemList) {
                    if (!(orderItem.product?.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse'])) continue
                    def orderItemQuantity = (orderItem.quantity ?: 1) * (orderItem.selectedAmount ?: 1)
                    addToBigDecimalInMap(orderItem.orderItemSeqId, orderItemQuantity, quantityNotShippedByItem)
                    addToBigDecimalInMap(orderItem.orderPartSeqId, orderItemQuantity, quantityNotShippedByPart)
                }
            </script>
            <iterate list="shipmentItemSourceList" entry="shipmentItemSource"><script>
                def curOrderItem = orderItemList.find({ it.orderItemSeqId == shipmentItemSource.orderItemSeqId })
                shipmentIdSet.add(shipmentItemSource.shipmentId)
                addToBigDecimalInMap(curOrderItem.orderItemSeqId, -shipmentItemSource.quantity, quantityNotShippedByItem)
                addToBigDecimalInMap(curOrderItem.orderPartSeqId, -shipmentItemSource.quantity, quantityNotShippedByPart)
            </script></iterate>

            <!-- get OrderItemBilling list and derived data -->
            <!-- TODO: exclude OrderItemBilling records for cancelled invoices -->
            <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                <econdition field-name="orderId"/><order-by field-name="orderItemSeqId"/></entity-find>
            <set field="invoiceIdSet" from="new TreeSet()"/>
            <set field="quantityNotBilledByItem" from="[:]"/>
            <set field="quantityNotBilledByPart" from="[:]"/>
            <iterate list="orderItemList" entry="orderItem"><script>
                def orderItemQuantity = (orderItem.quantity ?: 1) * (orderItem.selectedAmount ?: 1)
                addToBigDecimalInMap(orderItem.orderItemSeqId, orderItemQuantity, quantityNotBilledByItem)
                addToBigDecimalInMap(orderItem.orderPartSeqId, orderItemQuantity, quantityNotBilledByPart)
            </script></iterate>
            <iterate list="orderItemBillingList" entry="orderItemBilling"><script>
                def curOrderItem = orderItemList.find({ it.orderItemSeqId == orderItemBilling.orderItemSeqId })
                invoiceIdSet.add(orderItemBilling.invoiceId)
                addToBigDecimalInMap(curOrderItem.orderItemSeqId, -orderItemBilling.quantity, quantityNotBilledByItem)
                addToBigDecimalInMap(curOrderItem.orderPartSeqId, -orderItemBilling.quantity, quantityNotBilledByPart)
            </script></iterate>

            <!-- get ReturnItem list -->
            <entity-find entity-name="mantle.order.return.ReturnItem" list="returnItemList">
                <econdition field-name="orderId"/>
                <econdition field-name="statusId" operator="not-equals" value="ReturnCancelled"/>
                <order-by field-name="orderItemSeqId"/>
            </entity-find>

            <!-- get RequestItemOrder list and derived data -->
            <entity-find entity-name="mantle.request.RequestItemOrder" list="requestItemOrderList">
                <econdition field-name="orderId"/></entity-find>
            <set field="requestIdSet" from="new TreeSet()"/>
            <iterate list="requestItemOrderList" entry="requestItemOrder">
                <script>requestIdSet.add(requestItemOrder.requestId)</script></iterate>

            <!-- get order status history from EntityAuditLog -->
            <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusHistoryList">
                <econdition field-name="changedEntityName" value="mantle.order.OrderHeader"/>
                <econdition field-name="changedFieldName" value="statusId"/>
                <econdition field-name="pkPrimaryValue" from="orderId"/>
                <order-by field-name="changedDate"/>
            </entity-find>

            <entity-find entity-name="mantle.order.OrderNote" list="orderNoteList">
                <econdition field-name="orderId"/><order-by field-name="-noteDate"/></entity-find>

            <entity-find-related value-field="orderHeader" relationship-name="mantle.order.OrderPart" list="orderPartList"/>
            <set field="firstPart" from="orderPartList ? orderPartList[0] : null"/>

            <!-- get order info by part for more detailed display -->
            <script><![CDATA[
            import org.moqui.entity.EntityList
            import org.moqui.entity.EntityValue
            import org.moqui.context.ExecutionContext
            ExecutionContext ec = context.ec

            orderPartInfoList = []
            for (EntityValue orderPart in orderPartList) {
                EntityList partOrderItemList = orderItemList.findAll({ it.orderPartSeqId == orderPart.orderPartSeqId })
                EntityList partNoParentOrderItemList = partOrderItemList.findAll({ it.parentItemSeqId == null })

                EntityValue customerDetail = ec.entity.find("mantle.party.PartyDetail").condition("partyId", orderPart.customerPartyId).one()
                EntityValue vendorDetail = ec.entity.find("mantle.party.PartyDetail").condition("partyId", orderPart.vendorPartyId).one()
                boolean isCustomerInternalOrg = ec.entity.find("mantle.party.PartyRole")
                        .condition("partyId", orderPart.customerPartyId).condition("roleTypeId", "OrgInternal").one() as boolean
                boolean isVendorInternalOrg = ec.entity.find("mantle.party.PartyRole")
                        .condition("partyId", orderPart.vendorPartyId).condition("roleTypeId", "OrgInternal").one() as boolean

                String customerEmail = null
                if (orderPart.customerPartyId) {
                    customerEmail = ec.service.sync().name("mantle.party.ContactServices.get#PartyContactInfo")
                            .parameter("partyId", orderPart.customerPartyId).parameter("emailContactMechPurposeId", "EmailOrder")
                            .parameter("defaultToPrimaryPurpose", true).call()?.emailAddress
                }

                boolean hasShippableItems = orderItemList.find({ it.product?.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse'] }) != null
                boolean singleLot = false
                boolean newerInventory = false
                if (hasShippableItems && orderPart.customerPartyId) {
                    singleLot = "BlY".equals(ec.service.sync().name("mantle.party.PartyServices.get#PartySettingValue")
                            .parameter("partySettingTypeId", "CustomerSingleLot").parameter("partyId", orderPart.customerPartyId).call()?.get("settingValue"))
                    newerInventory = "BlY".equals(ec.service.sync().name("mantle.party.PartyServices.get#PartySettingValue")
                            .parameter("partySettingTypeId", "CustomerNewerInventory").parameter("partyId", orderPart.customerPartyId).call()?.get("settingValue"))
                }

                def partPaymentList = paymentList.cloneList().filterByAnd([orderPartSeqId:orderPart.orderPartSeqId])
                def partPaymentInfoList = []
                BigDecimal paymentsTotal = 0
                for (EntityValue partPayment in partPaymentList) {
                    if (!(((String) partPayment.statusId) in ['PmntCancelled', 'PmntVoid', 'PmntDeclined']))
                        paymentsTotal += (partPayment.amount ?: 0)
                    Map partPaymentInfo = [partPayment:partPayment, statusItem:partPayment.status]
                    EntityValue paymentMethod = (EntityValue) partPayment.method
                    if (paymentMethod != null) {
                        partPaymentInfo.paymentMethod = paymentMethod
                        creditCard = paymentMethod.creditCard
                        partPaymentInfo.creditCard = creditCard
                        partPaymentInfo.creditCardTypeEnum = creditCard?.type
                        cardNumber = creditCard?.cardNumber
                        partPaymentInfo.maskedCardNumber = cardNumber ? '*'.padRight(cardNumber.length() - 4, '*') + cardNumber.substring(cardNumber.length() - 4, cardNumber.length()) : ''
                        partPaymentInfo.postalAddress = paymentMethod.PostalAddress
                        partPaymentInfo.postalAddressStateGeo = partPaymentInfo.postalAddress?."StateProvince#moqui.basic.Geo"
                        partPaymentInfo.telecomNumber = paymentMethod.TelecomNumber
                        partPaymentInfo.paymentMethodTypeEnum = paymentMethod.methodType
                    }
                    partPaymentInfo.paymentInstrumentEnum = partPayment.instrument
                    partPaymentInfoList.add(partPaymentInfo)
                }
                BigDecimal partTotalUnpaid = (orderPart.partTotal ?: 0.0) - (paymentsTotal ?: 0.0)

                if (!orderPart.vendorPartyId) placeWarnings.add("Part ${orderPart.orderPartSeqId} has no vendor")
                if (!orderPart.customerPartyId) placeWarnings.add("Part ${orderPart.orderPartSeqId} has no customer")
                if (paymentsTotal < (BigDecimal) orderPart.partTotal)
                    placeWarnings.add("Part ${orderPart.orderPartSeqId} payments total (${ec.l10n.formatCurrency(paymentsTotal ?: 0.0, (String) orderHeader?.currencyUomId)}) is less than order part total (${ec.l10n.formatCurrency(orderPart.partTotal ?: 0.0, (String) orderHeader?.currencyUomId)})")
                if (!isCustomerInternalOrg && !orderPart.postalContactMechId)
                    placeWarnings.add("Part ${orderPart.orderPartSeqId} has no shipping address selected")
                if (!isCustomerInternalOrg && !orderPart.shipmentMethodEnumId)
                    placeWarnings.add("Part ${orderPart.orderPartSeqId} has no shipment method selected")

                List orderItemSeqIdList = partOrderItemList.orderItemSeqId
                List partShipmentItemSourceList = []
                Set partShipmentIdSet = new TreeSet()
                for (EntityValue sis in shipmentItemSourceList) if (sis.orderItemSeqId in orderItemSeqIdList) {
                    partShipmentItemSourceList.add(sis)
                    partShipmentIdSet.add(sis.shipmentId)
                }

                EntityValue telecomNumber = (EntityValue) orderPart.'mantle.party.contact.TelecomNumber'
                EntityValue postalAddress = (EntityValue) orderPart.'mantle.party.contact.PostalAddress'
                EntityValue postalAddressStateGeo = (EntityValue) postalAddress?."StateProvince#moqui.basic.Geo"
                EntityValue facility = (EntityValue) orderPart.'mantle.facility.Facility'
                Map facilityContactInfo = null
                if (facility) {
                    Map facShipOut = ec.service.sync().name("mantle.facility.ContactServices.get#FacilityDefaultShipDest")
                            .parameter("facilityId", orderPart.facilityId).call()
                    facilityContactInfo = ec.service.sync().name("mantle.facility.ContactServices.get#FacilityContactInfo")
                            .parameters([facilityId:orderPart.facilityId, postalContactMechId:facShipOut.postalContactMechId,
                                         telecomContactMechId:facShipOut.telecomContactMechId]).call()
                }

                EntityList orderPartPartyList = ec.entity.find("mantle.order.OrderPartPartyDetail")
                        .condition([orderId:orderPart.orderId, orderPartSeqId:orderPart.orderPartSeqId]).orderBy("description").list()
                EntityValue customerShipToDetail = orderPartPartyList.find({ it.roleTypeId == 'CustomerShipTo' })
                EntityValue customerBillToDetail = orderPartPartyList.find({ it.roleTypeId == 'CustomerBillTo' })

                // find duplicate orders by customerPartyId and otherPartyOrderId
                def duplicateOrderPartList = null
                if (!isCustomerInternalOrg && orderPart.otherPartyOrderId) {
                    duplicateOrderPartList = ec.entity.find("mantle.order.OrderPart").condition("orderId", "!=", orderId)
                            .condition("otherPartyOrderId", orderPart.otherPartyOrderId)
                            .condition("customerPartyId", orderPart.customerPartyId).list()
                }

                // find applicable open returns
                Map openReturnsResult = ec.service.sync().name("mantle.order.ReturnServices.find#OrderOpenReturns")
                        .parameters([orderId:orderPart.orderId, orderPartSeqId:orderPart.orderPartSeqId]).call()

                orderPartInfoList.add([orderPart:orderPart, partEditable:editableStatusIds.contains(orderPart.statusId),
                        partOrderItemList:partOrderItemList, partNoParentOrderItemList:partNoParentOrderItemList,
                        hasShippableItems:hasShippableItems, singleLot:singleLot, newerInventory:newerInventory,
                        shipmentMethodEnum:orderPart."ShipmentMethod#moqui.basic.Enumeration",
                        partPaymentList:partPaymentList, partPaymentInfoList:partPaymentInfoList,
                        paymentsTotal:paymentsTotal, partTotalUnpaid:partTotalUnpaid,
                        postalAddress:postalAddress, postalAddressStateGeo:postalAddressStateGeo,
                        telecomNumber:telecomNumber, facility:facility,
                        facilityContactInfo:facilityContactInfo, customerDetail:customerDetail, customerEmail:customerEmail,
                        vendorDetail:vendorDetail, isCustomerInternalOrg:isCustomerInternalOrg, isVendorInternalOrg:isVendorInternalOrg,
                        orderPartPartyList:orderPartPartyList, customerShipToDetail:customerShipToDetail,
                        customerBillToDetail:customerBillToDetail, partShipmentItemSourceList:partShipmentItemSourceList,
                        partShipmentIdSet:partShipmentIdSet, duplicateOrderPartList:duplicateOrderPartList,
                        openReturnList:openReturnsResult.openReturnList])
            }
            ]]></script>
            <set field="firstPartInfo" from="orderPartInfoList ? orderPartInfoList[0] : null"/>
            <!-- <log level="warn" message="======== OrderDisplayInfo orderPartInfoList: ${orderPartInfoList}"/> -->

            <!-- Get templateLocation from settings -->
            <set field="templateLocation" from="null"/>
            <!-- see if a template is configured by ProductStoreSetting -->
            <if condition="orderHeader.productStoreId">
                <entity-find entity-name="mantle.product.store.ProductStoreSetting" list="productStoreSettingList" cache="true">
                    <date-filter/>
                    <econdition field-name="productStoreId" from="orderHeader.productStoreId"/>
                    <econdition field-name="settingTypeEnumId" value="Psst${templateSettingSuffix}"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="productStoreSettingList">
                    <set field="templateLocation" from="productStoreSettingList[0].settingValue"/></if>
            </if>
            <!-- if no template setting for store look for PartySetting on Shipment.fromPartyId -->
            <if condition="!templateLocation &amp;&amp; firstPart.vendorPartyId">
                <service-call name="mantle.party.PartyServices.get#PartySettingValue" out-map="ptySettingOut"
                        in-map="[partyId:firstPart.vendorPartyId, partySettingTypeId:('Org' + templateSettingSuffix)]"/>
                <set field="templateLocation" from="ptySettingOut?.settingValue"/>
            </if>
        </actions>
    </service>
    <service verb="get" noun="OrderItemsTotalCount">
        <in-parameters><parameter name="orderId"/></in-parameters>
        <out-parameters><parameter name="itemCount" type="BigDecimal"/></out-parameters>
        <actions>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <set field="itemCount" from="0.0"/>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList"><econdition field-name="orderId"/></entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <if condition="!(orderItem.itemTypeEnumId in productItemTypes)"><continue/></if>
                <set field="itemCount" from="itemCount + orderItem.quantity"/>
            </iterate>
        </actions>
    </service>

    <service verb="check" noun="OrderPreApprove">
        <description>A basic set of checks for possible issues before approving an order. Use an SECA on this service to do
            additional checks, adding to the approveWarnings List as needed.</description>
        <in-parameters><parameter name="orderId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="approveWarnings" type="List"><parameter name="approveWarning"/></parameter>
        </out-parameters>
        <actions>
            <set field="approveWarnings" from="[]"/>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <set field="placedDate" from="orderHeader.placedDate"/>
            <set field="currencyUomId" from="orderHeader.currencyUomId"/>
            <set field="productStoreId" from="orderHeader.productStoreId"/>

            <set field="orderPartList" from="orderHeader.parts"/>
            <set field="firstOrderPart" from="orderPartList[0]"/>
            <set field="orderItemList" from="orderHeader.items"/>

            <set field="customerPartyId" from="firstOrderPart.customerPartyId"/>
            <set field="vendorPartyId" from="firstOrderPart.vendorPartyId"/>
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="vendorOrgInternal">
                <field-map field-name="partyId" from="vendorPartyId"/><field-map field-name="roleTypeId" value="OrgInternal"/></entity-find-one>
            <set field="isVendorInternalOrg" from="vendorOrgInternal != null"/>

            <!-- check payments for sufficient authorized, promised (or later statuses for each) -->
            <set field="totalPromised" from="0"/>
            <set field="totalAuthorized" from="0"/>
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="orderId"/></entity-find>
            <iterate list="paymentList" entry="payment">
                <if condition="payment.statusId in ['PmntAuthorized', 'PmntDelivered', 'PmntConfirmed']"><then>
                    <set field="totalPromised" from="totalPromised + (payment.amount ?: 0.0)"/>
                    <set field="totalAuthorized" from="totalAuthorized + (payment.amount ?: 0.0)"/>
                </then><else-if condition="payment.statusId == 'PmntPromised'">
                    <set field="totalPromised" from="totalPromised + (payment.amount ?: 0.0)"/>
                </else-if></if>
                <if condition="payment.amountUomId != orderHeader.currencyUomId">
                    <script>approveWarnings.add(ec.resource.expand('OrderApproveCurrencyDifferent', null))</script></if>
            </iterate>
            <if condition="totalPromised &lt; orderHeader.grandTotal">
                <script>approveWarnings.add(ec.resource.expand('OrderApprovePaymentPromisedLow', null))</script></if>
            <if condition="totalAuthorized &lt; orderHeader.grandTotal">
                <script>approveWarnings.add(ec.resource.expand('OrderApprovePaymentAuthorizedLow', null))</script></if>

            <!-- don't go beyond here if there is no customer or vendor -->
            <set field="noCustomerOrVendor" from="false"/>
            <iterate list="orderPartList" entry="orderPart">
                <if condition="!orderPart.vendorPartyId">
                    <script>approveWarnings.add(ec.resource.expand('Part ${orderPart.orderPartSeqId} has no vendor', null))</script>
                    <set field="noCustomerOrVendor" from="true"/>
                </if>
                <if condition="!orderPart.customerPartyId">
                    <script>approveWarnings.add(ec.resource.expand('Part ${orderPart.orderPartSeqId} has no customer', null))</script>
                    <set field="noCustomerOrVendor" from="true"/>
                </if>
            </iterate>
            <if condition="noCustomerOrVendor"><return/></if>

            <if condition="isVendorInternalOrg"><then>
                <!-- ========== Sales Order Validations ========== -->

                <!-- TODO: add ProductStore based configuration for all of these validations -->

                <!-- get other OrderParts for various validations -->
                <set field="includeStatuses" from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderHold']"/>
                <entity-find entity-name="mantle.order.OrderPart" list="otherPartList">
                    <econdition field-name="customerPartyId"/><econdition field-name="orderId" operator="not-equals"/>
                    <econdition field-name="statusId" operator="in" from="includeStatuses"/>
                </entity-find>
                <set field="otherPartCount" from="otherPartList.size()"/>

                <!-- is this a new customer? (no other orders; see also PromotionServices.apply#NewCustomerDiscount) -->
                <if condition="otherPartCount == 0"><script>approveWarnings.add(ec.resource.expand('Customer ${firstOrderPart.customerPartyId} is a new customer', null))</script></if>

                <!-- is the shipping address (for each part) validated? -->
                <iterate list="orderPartList" entry="orderPart">
                    <if condition="!orderPart.postalContactMechId">
                        <script>approveWarnings.add(ec.resource.expand('Part ${orderPart.orderPartSeqId} has no shipping address', null))</script>
                        <continue/>
                    </if>
                    <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="postalCm">
                        <field-map field-name="contactMechId" from="orderPart.postalContactMechId"/></entity-find-one>
                    <set field="trustLevelEnumId" from="postalCm.trustLevelEnumId ?: 'CmtlNew'"/>
                    <if condition="!'CmtlValid'.equals(trustLevelEnumId) &amp;&amp; !'CmtlVerified'.equals(trustLevelEnumId)">
                        <entity-find-one entity-name="moqui.basic.Enumeration" value-field="trustLevelEnum">
                            <field-map field-name="enumId" from="trustLevelEnumId"/></entity-find-one>
                        <script>approveWarnings.add(ec.resource.expand('Part ${orderPart.orderPartSeqId} shipping address ${orderPart.postalContactMechId} has trust level of ${trustLevelEnum.description}', null))</script>
                    </if>
                </iterate>

                <!-- is this order much larger than past orders? (by part if 3 or more; avg + 3 std devs) -->
                <if condition="otherPartCount &gt;= 3">
                    <set field="partMaxTotal" from="stdDevMaxFromMapField(otherPartList, 'partTotal', 3.0)?.maximum"/>
                    <iterate list="orderPartList" entry="orderPart">
                        <if condition="partMaxTotal &amp;&amp; orderPart.partTotal &gt; partMaxTotal"><script>approveWarnings.add(ec.resource.expand(
                                'Part ${orderPart.orderPartSeqId} total ${ec.l10n.format(orderPart.partTotal, "#,##0.00")} is greater than ${ec.l10n.format(partMaxTotal, "#,##0.00")}, the average of other order parts plus 3 standard deviations', null))</script></if>
                    </iterate>
                </if>

                <!-- is this order much larger than past orders? (by product if 3 or more; avg + 3 std devs) -->
                <iterate list="orderItemList" entry="orderItem">
                    <set field="productId" from="orderItem.productId"/>
                    <if condition="!productId"><continue/></if>
                    <entity-find entity-name="mantle.order.OrderItemAndPart" list="pastItemPartList">
                        <econdition field-name="customerPartyId"/><econdition field-name="orderId" operator="not-equals"/>
                        <econdition field-name="productId"/>
                        <select-field field-name="quantity"/>
                    </entity-find>
                    <if condition="pastItemPartList.size() &lt; 3"><continue/></if>
                    <set field="quantityMax" from="stdDevMaxFromMapField(pastItemPartList, 'quantity', 3.0)?.maximum"/>
                    <if condition="quantityMax &amp;&amp; orderItem.quantity &gt; quantityMax"><script>approveWarnings.add(ec.resource.expand(
                            'Item ${orderItem.orderItemSeqId} product ${productId} quantity ${ec.l10n.format(orderItem.quantity, "0.##")} is greater than ${ec.l10n.format(quantityMax, "#,##0.##")}, the average of previously ordered quantities plus 3 standard deviations', null))</script></if>
                </iterate>

                <!-- get AssetReservation records for various validations -->
                <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetResList">
                    <econdition field-name="orderId"/><order-by field-name="orderItemSeqId"/></entity-find>

                <!-- are there any unavailable reservations? -->
                <set field="arUnavailableMap" from="[:]"/>
                <iterate list="assetResList" entry="assetRes">
                    <if condition="assetRes.quantityNotAvailable">
                        <script>addToBigDecimalInMap(assetRes.orderItemSeqId, assetRes.quantityNotAvailable, arUnavailableMap)</script></if>
                </iterate>
                <iterate list="arUnavailableMap" key="orderItemSeqId" entry="quantityNotAvailable">
                    <set field="curOrderItem" from="orderItemList.find({ it.orderItemSeqId == orderItemSeqId })"/>
                    <script>approveWarnings.add(ec.resource.expand(
                            'Item ${orderItemSeqId} has ${ec.l10n.format(quantityNotAvailable, "0.##")} of ${ec.l10n.format(curOrderItem.quantity, "0.##")} not available in inventory', null))</script>
                </iterate>

                <!-- see if we need to check for single lot or newer inventory -->
                <set field="singleLot" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerSingleLot').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                <set field="newerInventory" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerNewerInventory').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>

                <set field="lotIdSetByItemSeqId" from="[:]"/>
                <set field="oldestLotExpireByItemSeqId" from="[:]"/>
                <iterate list="assetResList" entry="assetRes">
                    <set field="orderItemSeqId" from="assetRes.orderItemSeqId"/>

                    <!-- get data for single lot and newer inventory -->
                    <if condition="singleLot || newerInventory">
                        <entity-find-one entity-name="mantle.product.asset.AssetLotAndMfgParty" value-field="assetLot">
                            <field-map field-name="assetId" from="assetRes.assetId"/>
                            <select-field field-name="lotId,pseudoId,lotNumber,manufacturedDate,expirationDate"/>
                        </entity-find-one>
                        <script><![CDATA[
                            if (singleLot && assetLot?.lotId) addToSetInMap(orderItemSeqId, assetLot.lotId, lotIdSetByItemSeqId)
                            def oldestLotExpire = oldestLotExpireByItemSeqId.get(orderItemSeqId)
                            if (newerInventory && assetLot?.expirationDate != null && (oldestLotExpire == null || assetLot.expirationDate < oldestLotExpire))
                                oldestLotExpireByItemSeqId.put(orderItemSeqId, assetLot.expirationDate)
                        ]]></script>
                    </if>
                </iterate>

                <!-- if customer has single lot constraint is inventory available from single lot for each item? -->
                <if condition="singleLot">
                    <iterate list="lotIdSetByItemSeqId" entry="lotIdSet" key="orderItemSeqId">
                        <if condition="lotIdSet != null &amp;&amp; lotIdSet.size() &gt; 1"><script>approveWarnings.add(ec.resource.expand(
                            'Item ${orderItemSeqId} has inventory in more than one lot: ${lotIdSet}', null))</script></if>
                    </iterate>
                </if>
                <if condition="newerInventory">
                    <iterate list="orderItemList" entry="orderItem">
                        <set field="oldestLotExpire" from="oldestLotExpireByItemSeqId.get(orderItem.orderItemSeqId)"/>
                        <if condition="oldestLotExpire == null"><continue/></if>

                        <set field="newerThanExpireDate" from="null"/>
                        <!-- get most recent asset issued and lot expire date for it -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuanceLotSummary" list="issuanceLotList" limit="1">
                            <econdition field-name="toPartyId" from="customerPartyId"/>
                            <econdition field-name="productId" from="orderItem.productId"/>
                            <select-field field-name="expirationDate,expectedEndOfLife"/>
                            <order-by field-name="-issuedDate"/>
                        </entity-find>
                        <if condition="issuanceLotList">
                            <set field="newerThanExpireDate" from="issuanceLotList[0].expirationDate ?: issuanceLotList[0].expectedEndOfLife"/></if>
                        <if condition="newerThanExpireDate == null"><continue/></if>
                        <if condition="oldestLotExpire &lt; newerThanExpireDate"><script>approveWarnings.add(ec.resource.expand(
                            'In item ${orderItem.orderItemSeqId} oldest lot ${ec.l10n.format(oldestLotExpire, "yyyy-MM-dd")} older than last lot expire ${ec.l10n.format(newerThanExpireDate, "yyyy-MM-dd")}', null))</script></if>
                    </iterate>
                </if>

                <!-- is this a large order by percentage of available inventory? more than quantity 10 and 20% of available -->
                <set field="productIdSet" from="new HashSet()"/><!-- prep this for similar order check below -->
                <iterate list="orderItemList" entry="orderItem">
                    <set field="productId" from="orderItem.productId"/>
                    <if condition="!productId"><continue/></if>
                    <script>productIdSet.add(productId)</script>
                    <set field="quantity" from="orderItem.quantity"/>
                    <!-- TODO: make the 10 configurable (by ProductStore) -->
                    <if condition="quantity &lt; 10"><continue/></if>
                    <set field="curOrderPart" from="orderPartList.find({ it.orderPartSeqId == orderItem.orderPartSeqId })"/>
                    <set field="curFacilityId" from="curOrderPart?.facilityId"/>
                    <if condition="!curFacilityId"><continue/></if>
                    <!-- get current available inventory for product in facility; will not include this order as already reserved -->
                    <entity-find entity-name="mantle.product.asset.AssetSummaryView" list="atpList">
                        <econdition field-name="productId"/><econdition field-name="facilityId" from="curFacilityId"/>
                        <having-econditions><econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/></having-econditions>
                        <select-field field-name="availableToPromiseTotal"/>
                    </entity-find>
                    <if condition="!atpList"><continue/></if>
                    <set field="availableToPromiseTotal" from="atpList[0].availableToPromiseTotal"/>
                    <if condition="!availableToPromiseTotal"><continue/></if><!-- if null or zero ATP -->
                    <!-- TODO: make the 20% configurable (by ProductStore) -->
                    <set field="percentOfAvailable" from="20.0"/>
                    <set field="curLimit" from="(quantity + availableToPromiseTotal) * (percentOfAvailable/100.0)"/>
                    <if condition="quantity &gt; curLimit"><script>approveWarnings.add(ec.resource.expand(
                        'Item ${orderItem.orderItemSeqId} has ${ec.l10n.format(quantity, "0.##")} which is greater than ${percentOfAvailable}% of available inventory (${ec.l10n.format(availableToPromiseTotal, "0.##")})', null))</script></if>
                </iterate>

                <!-- duplicate/similar order with 24 hours (+/- 24hrs); any other order with any of the products on this order -->
                <!-- find by OrderHeader.placedDate so it is at least in the Placed status, exclude OrderCancelled and OrderRejected -->
                <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="nearOrderList">
                    <econdition field-name="orderId" operator="not-equals"/><econdition field-name="customerPartyId"/>
                    <econdition field-name="placedDate" operator="greater" from="placedDate - 1"/>
                    <econdition field-name="placedDate" operator="less" from="placedDate + 1"/>
                    <econdition field-name="partStatusId" operator="not-in" value="OrderCancelled,OrderRejected"/>
                    <select-field field-name="orderId,orderPartSeqId,placedDate"/>
                </entity-find>
                <iterate list="nearOrderList" entry="nearOrder">
                    <set field="timeDiff" from="placedDate.time - nearOrder.placedDate.time"/><set field="isFuture" from="false"/>
                    <if condition="timeDiff &lt; 0"><set field="isFuture" from="true"/><set field="timeDiff" from="-timeDiff"/></if>
                    <set field="diffHours" from="timeDiff / (1000*60*60)"/>
                    <entity-find entity-name="mantle.order.OrderItem" list="nearItemList">
                        <econdition field-name="orderId" from="nearOrder.orderId"/>
                        <econdition field-name="orderPartSeqId" from="nearOrder.orderPartSeqId"/>
                        <econdition field-name="productId" operator="in" from="productIdSet"/>
                        <select-field field-name="productId,quantity"/>
                    </entity-find>
                    <iterate list="nearItemList" entry="nearItem">
                        <script>approveWarnings.add(ec.resource.expand('OrderApproveNearOrder', null))</script></iterate>
                </iterate>

                <!-- price min/max compare, for each product with min/max prices -->
                <iterate list="orderItemList" entry="orderItem">
                    <set field="productId" from="orderItem.productId"/>
                    <if condition="!productId"><continue/></if>
                    <set field="unitAmount" from="orderItem.unitAmount"/>

                    <service-call name="mantle.product.PriceServices.get#ProductPriceByType" out-map="minOut"
                            in-map="[productId:orderItem.productId, quantity:orderItem.quantity, validDate:placedDate,
                                priceUomId:currencyUomId, productStoreId:productStoreId, vendorPartyId:vendorPartyId,
                                customerPartyId:customerPartyId, priceTypeEnumId:'PptMinimum']"/>
                    <set field="minPrice" from="minOut.price"/>
                    <service-call name="mantle.product.PriceServices.get#ProductPriceByType" out-map="maxOut"
                            in-map="[productId:orderItem.productId, quantity:orderItem.quantity, validDate:placedDate,
                                priceUomId:currencyUomId, productStoreId:productStoreId, vendorPartyId:vendorPartyId,
                                customerPartyId:customerPartyId, priceTypeEnumId:'PptMaximum']"/>
                    <set field="maxPrice" from="maxOut.price"/>

                    <if condition="minPrice &amp;&amp; unitAmount &lt; minPrice"><script>approveWarnings.add(ec.resource.expand(
                        'Item ${orderItem.orderItemSeqId} price ${ec.l10n.format(unitAmount, "0.00")} is less than minimum price ${ec.l10n.format(minPrice, "0.00")} for product ${orderItem.productId}', null))</script></if>
                    <if condition="maxPrice &amp;&amp; unitAmount &gt; maxPrice"><script>approveWarnings.add(ec.resource.expand(
                        'Item ${orderItem.orderItemSeqId} price ${ec.l10n.format(unitAmount, "0.00")} is greater than maximum price ${ec.l10n.format(maxPrice, "0.00")} for product ${orderItem.productId}', null))</script></if>
                </iterate>
            </then><else>
                <!-- ========== Purchase Order Validations ========== -->

                <!-- purchase price more than 50% of current sale price -->
                <iterate list="orderItemList" entry="orderItem">
                    <set field="productId" from="orderItem.productId"/>
                    <if condition="!productId"><continue/></if>
                    <set field="unitAmount" from="orderItem.unitAmount"/>

                    <!-- we don't know the store, customer, etc here so do a less constrained search -->
                    <entity-find entity-name="mantle.product.ProductPrice" list="currentPriceList" limit="1">
                        <date-filter valid-date="placedDate"/><econdition field-name="productId"/>
                        <econdition field-name="priceTypeEnumId" operator="in" value="PptCurrent,PptList"/>
                        <econdition field-name="priceUomId" from="currencyUomId"/>
                        <econdition field-name="vendorPartyId" from="customerPartyId" or-null="true"/>
                        <econdition field-name="pricePurposeEnumId" value="PppPurchase" or-null="true"/>
                        <order-by field-name="price"/><!-- we want the lowest price -->
                    </entity-find>
                    <set field="lowestPrice" from="currentPriceList ? currentPriceList[0].price : null"/>
                    <set field="purchasePricePercent" from="50.0"/>
                    <set field="maxPurchasePrice" from="lowestPrice ? lowestPrice * (purchasePricePercent / 100) : null"/>

                    <if condition="maxPurchasePrice &amp;&amp; unitAmount &gt; maxPurchasePrice"><script>approveWarnings.add(ec.resource.expand(
                        'Item ${orderItem.orderItemSeqId} price ${ec.l10n.format(unitAmount, "0.00")} is greater than ${ec.l10n.format(purchasePricePercent, "0")}% of the lowest sale price ${ec.l10n.format(lowestPrice, "0.00")} for product ${orderItem.productId}', null))</script></if>
                </iterate>
            </else></if>
        </actions>
    </service>

    <!-- ========== Order Notification Services ========== -->

    <service verb="send" noun="OrderStoreEmail" authenticate="anonymous-view">
        <description>Called by SECA rule in OrderReturn.secas.xml on tx-commit so always run async from triggering thread</description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="emailTypeEnumId" required="true"/>
            <parameter name="toAddresses"><text-email/></parameter>
            <parameter name="forceByType" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <if condition="orderHeader == null"><return/></if>
            <set field="productStoreId" from="orderHeader.productStoreId"/>
            <if condition="!productStoreId"><return/></if>

            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId"/></entity-find-one>
            <entity-find entity-name="mantle.product.store.ProductStoreEmail" list="storeEmailList">
                <date-filter/><econdition field-name="productStoreId"/><econdition field-name="emailTypeEnumId"/></entity-find>
            <if condition="storeEmailList">
                <!-- assume one OrderPart or all order parts have same customerPartyId -->
                <set field="orderPartList" from="orderHeader.parts"/>
                <set field="customerPartyId" from="orderPartList[0].customerPartyId"/>

                <!-- get customer email address -->
                <if condition="!toAddresses &amp;&amp; customerPartyId">
                    <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="emailInfo"
                            in-map="[partyId:customerPartyId, emailContactMechPurposeId:'EmailOrder', defaultToPrimaryPurpose:true]"/>
                    <set field="toAddresses" from="emailInfo.emailAddress"/>
                    <!-- get customer userId for toUserId -->
                    <entity-find entity-name="moqui.security.UserAccount" list="userAccountList" limit="1">
                        <econdition field-name="partyId" from="customerPartyId"/></entity-find>
                    <if condition="userAccountList"><set field="toUserId" from="userAccountList[0].userId"/></if>
                </if>
                <if condition="!toAddresses"><return message="Not sending email for order ${orderId}, no to address specified or found for customer ${customerPartyId}"/></if>

                <!-- send email for each configured -->
                <iterate list="storeEmailList" entry="storeEmail">
                    <if condition="!storeEmail.emailTemplateId"><continue/></if>

                    <!-- if email has already been sent (by orderId, emailTypeEnumId) don't send again -->
                    <if condition="!forceByType">
                        <entity-find entity-name="mantle.order.OrderEmailMessageDetail" list="existingMessages">
                            <econdition field-name="orderId"/>
                            <econdition field-name="emailTypeEnumId"/>
                            <econdition field-name="statusId" operator="in" value="ES_SENT,ES_RECEIVED,ES_VIEWED"/>
                            <select-field field-name="emailMessageId"/>
                        </entity-find>
                        <if condition="existingMessages">
                            <message type="warning">Not sending ${emailTypeEnumId} email for order ${orderId}, found messages: ${existingMessages*.emailMessageId}</message>
                            <continue/>
                        </if>
                    </if>

                    <set field="bccAddresses" from="orderHeader.salesChannelEnumId in ['ScWeb', 'ScWebExternal'] ? storeEmail.webOrderBcc : null"/>

                    <!-- simple bodyParameters, let the screen do data prep -->
                    <set field="bodyParameters" from="[orderId:orderId, storeDomain:productStore.storeDomain,
                        profileUrlPath:productStore.profileUrlPath, headerImagePath:storeEmail.headerImagePath,
                        detailLinkPath:storeEmail.detailLinkPath]"/>

                    <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" out-map="sendOut" out-map-add-to-existing="false"
                            in-map="[emailTemplateId:storeEmail.emailTemplateId, emailTypeEnumId:emailTypeEnumId, toAddresses:toAddresses,
                                bccAddresses:bccAddresses, bodyParameters:bodyParameters, toUserId:toUserId]"/>
                    <script>if (sendOut.emailMessageId) { ec.service.sync().name("create#mantle.order.OrderEmailMessage").parameter("orderId", orderId)
                        .parameter("emailMessageId", sendOut.emailMessageId).parameter("orderRevision", orderHeader.orderRevision).disableAuthz().call() }</script>
                    <message>Email sent to ${toAddresses}${sendOut.emailMessageId ? ', message ID ' + sendOut.emailMessageId : ''}</message>
                </iterate>
            </if>
        </actions>
    </service>
</services>
