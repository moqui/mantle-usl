<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

<!--
General Order Placement and eCommerce Usage

| create customer | PartyServices.create#Account |
| create/update/delete customer address | ContactServices.create#PostalAddress, .update#PartyPostalAddress |
| create/update/delete customer phone | ContactServices.create#TelecomNumber, .update#PartyTelecomNumber |
| create/update/delete customer credit card | PaymentMethodServices.create#CreditCard, .update#CreditCard |

| login: merge with previous open | merge#OrderItems |
| find customer open orders       | find#OpenOrders - TODO |

| init cart (auto on add to cart) | create#Order |
| add to cart                     | add#OrderProductQuantity, create#OrderItem |
| change cart quantity            | update#OrderProductQuantity, update#OrderItem |
| remove from cart                | delete#OrderItem |
| set billing and shipping info   | set#OrderBillingShippingInfo |
| split order                     | create#OrderPart |
| confirm/complete order          | place#Order |

| create order from shopping list (or other existing order) | clone#Order |

-->

    <!-- ========== Order Header and Part Services ========== -->

    <service verb="create" noun="Order">
        <description>
            Create an Order (OrderHeader and one OrderPart).
            All parameters are optional so that this can be called transparently to create a shell/empty order.
        </description>
        <in-parameters>
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk"><exclude field-name="remainingSubTotal"/>
                <exclude field-name="grandTotal"/></auto-parameters>
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk"/>

            <parameter name="statusId" default-value="OrderOpen">
                <description>The initial statusId for both header and part.</description></parameter>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="visitId" default="ec.user.visitId"/>
            <parameter name="enteredByPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="currencyUomId"><description>Defaults to PartyAcctgPreference.baseCurrencyUomId for whichever
                Party (customer or vendor) is an internal organization with an accounting preference record.</description></parameter>
            <parameter name="orderRevision" type="Integer" default="1"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
        </out-parameters>
        <actions>
            <if condition="productStoreId">
                <!-- Get some unspecified values from the ProductStore -->
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
                <set field="vendorPartyId" from="vendorPartyId ?: productStore?.organizationPartyId"/>
                <set field="currencyUomId" from="currencyUomId ?: productStore?.defaultCurrencyUomId"/>
                <set field="salesChannelEnumId" from="salesChannelEnumId ?: productStore?.defaultSalesChannelEnumId"/>
                <set field="facilityId" from="facilityId ?: productStore?.inventoryFacilityId"/>
            </if>

            <if condition="!currencyUomId">
                <if condition="customerPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:customerPartyId]"/></if>
                <if condition="!partyAcctgPreference &amp;&amp; vendorPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:vendorPartyId]"/></if>
                <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId"/>
            </if>
            <!-- MAYBE: get this from configuration somewhere, needed beyond PartyAcctgPreference? -->
            <if condition="!currencyUomId"><set field="currencyUomId" value="USD"/></if>

            <service-call name="create#mantle.order.OrderHeader" in-map="context" out-map="context"/>

            <if condition="customerPartyId">
                <!-- If customer is internal org and there is a facility get default ship dest contact info -->
                <entity-find entity-name="mantle.party.PartyRole" list="custOrgInternalList">
                    <econdition field-name="partyId" from="customerPartyId"/>
                    <econdition field-name="roleTypeId" value="OrgInternal"/></entity-find>
                <if condition="custOrgInternalList">
                    <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest"
                            in-map="context" out-map="context"/></if>

                <!-- if customer Party.shippingInstructions populate if none specified -->
                <if condition="!shippingInstructions">
                    <entity-find-one entity-name="mantle.party.Party" value-field="customerParty">
                        <field-map field-name="partyId" from="customerPartyId"/></entity-find-one>
                    <set field="shippingInstructions" from="customerParty?.shippingInstructions"/>
                </if>
            </if>

            <service-call name="create#mantle.order.OrderPart" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="OrderHeader">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk"><exclude field-name="statusId"/>
                <exclude field-name="orderRevision"/><exclude field-name="remainingSubTotal"/>
                <exclude field-name="grandTotal"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-set value-field="orderHeader" include="nonpk" set-if-empty="true"/>
            <set field="orderHeader.orderRevision" from="orderHeader.orderRevision + 1"/>
            <entity-update value-field="orderHeader"/>
            <!-- <service-call name="update#mantle.order.OrderHeader" in-map="context"/> -->
        </actions>
    </service>
    <service verb="create" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk"/>
            <parameter name="statusId" default-value="OrderOpen"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderPartSeqId" required="true"/>
        </out-parameters>
        <actions>
            <!-- If customer is internal org and there is a facility get default ship dest contact info -->
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="customerOrgRole">
                <field-map field-name="partyId" from="customerPartyId"/><field-map field-name="roleTypeId" value="OrgInternal"/></entity-find-one>
            <if condition="customerOrgRole != null">
                <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest" in-map="context" out-map="context"/></if>

            <!-- if customer Party.shippingInstructions populate if none specified -->
            <if condition="!shippingInstructions &amp;&amp; customerPartyId">
                <entity-find-one entity-name="mantle.party.Party" value-field="customerParty">
                    <field-map field-name="partyId" from="customerPartyId"/></entity-find-one>
                <set field="shippingInstructions" from="customerParty?.shippingInstructions"/>
            </if>

            <service-call name="create#mantle.order.OrderPart" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="customerOrgRole">
                <field-map field-name="partyId" from="customerPartyId"/><field-map field-name="roleTypeId" value="OrgInternal"/></entity-find-one>
            <if condition="customerOrgRole != null">
                <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest" in-map="context" out-map="context"/></if>
            <service-call name="update#mantle.order.OrderPart" in-map="context" out-map="context"/>
        </actions>
    </service>

    <!-- ======================================== -->
    <!-- ========== OrderItem Services ========== -->
    <!-- ======================================== -->

    <service verb="get" noun="OrderItemTotal">
        <in-parameters>
            <parameter name="orderItem" type="EntityValue"><description>Can be a view-entity with OrderItem and at least
                the fields orderId, orderItemSeqId, unitAmount, quantity, selectedAmount.</description></parameter>
            <parameter name="getChildrenTotals" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="combinedAmount" type="BigDecimal"><description>unitAmount (default 0.0) * selectedAmount (default 1.0)</description></parameter>
            <parameter name="combinedQuantity" type="BigDecimal"><description>quantity (1.0 if null) * selectedAmount (default 1.0)</description></parameter>
            <parameter name="itemTotal" type="BigDecimal"/>
            <parameter name="childrenTotal" type="BigDecimal"/>
            <parameter name="itemPlusChildrenTotal" type="BigDecimal"/>
            <parameter name="hasPromo" type="Boolean"/>
            <parameter name="promoQuantityUsed" type="BigDecimal"/>
            <parameter name="childOrderItemList" type="List"><parameter name="childOrderItem" type="Map"/></parameter>
        </out-parameters>
        <actions>
            <!-- for return value, unitAmount * selectedAmount -->
            <set field="combinedAmount" from="((orderItem.unitAmount ?: 0.0) * (orderItem.selectedAmount ?: 1.0))"/>

            <set field="combinedQuantity" from="(orderItem.quantity != null ? orderItem.quantity : 1.0) * (orderItem.selectedAmount ?: 1.0)"/>
            <!-- NOTE: also a sales/VAT tax calculation concern on item vs order level (tax should generally be calculated to 3 digits on the item level then summed and rounded to 2 digits to get a tax total) -->
            <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
            <set field="itemTotal" from="(combinedQuantity * (orderItem.unitAmount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            <if condition="getChildrenTotals">
                <!-- recursively get total of child OrderItems -->
                <!-- don't use relationship, allow view-entities, etc <entity-find-related value-field="orderItem" relationship-name="Child#OrderItem" list="childOrderItemList"/> -->
                <entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                    <econdition field-name="parentItemSeqId" from="orderItem.orderItemSeqId"/>
                </entity-find>
                <set field="childrenTotal" from="0.0"/>
                <set field="hasPromo" from="false"/>
                <set field="promoQuantityUsed" from="0.0"/>
                <iterate list="childOrderItemList" entry="childOrderItem">
                    <service-call name="mantle.order.OrderServices.get#OrderItemTotal" out-map="getOitResult" out-map-add-to-existing="false"
                            in-map="[orderItem:childOrderItem, getChildrenTotals:true]"/>
                    <set field="childrenTotal" from="childrenTotal + getOitResult.itemPlusChildrenTotal"/>
                    <if condition="childOrderItem.isPromo == 'Y' || getOitResult.hasPromo"><set field="hasPromo" from="true"/></if>
                    <set field="promoQuantityUsed" from="promoQuantityUsed + (childOrderItem.promoQuantity ?: 0.0) + getOitResult.promoQuantityUsed"/>
                </iterate>
                <set field="itemPlusChildrenTotal" from="itemTotal + childrenTotal"/>
            </if>
        </actions>
    </service>

    <service verb="create" noun="OrderItem">
        <!-- NOTE had transaction="cache" but causing issues with updating single Payment amount and sometimes part/header total when there are multiple promotions active (ie New Customer and BOGO) -->
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <auto-parameters entity-name="mantle.order.OrderItem" include="nonpk"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="itemTypeEnumId" default-value="ItemProduct"/>
            <parameter name="quantity" type="BigDecimal" default="1"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderItemSeqId" required="true"/>
        </out-parameters>
        <actions>
            <if condition="productId">
                <entity-find-one entity-name="mantle.product.Product" value-field="product"/>
                <if condition="product == null"><return error="true" message="Product [${productId}] not found."/></if>
            </if>
            <if condition="product?.amountRequire == 'Y' &amp;&amp; !selectedAmount">
                <return error="true" message="Product [${productId}] requires a selected amount"/></if>
            <if condition="!itemDescription"><set field="itemDescription" from="product?.productName"/></if>
            <if condition="!quantityUomId"><set field="quantityUomId" from="product?.amountUomId"/></if>

            <service-call name="create#mantle.order.OrderItem" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="OrderItem">
        <!-- NOTE had transaction="cache" but causing issues with updating single Payment amount and sometimes part/header total when there are multiple promotions active (ie New Customer and BOGO) -->
        <in-parameters>
            <auto-parameters include="pk" required="true"/>
            <auto-parameters include="nonpk"/>
            <parameter name="unitAmount_changeReason"/>
            <parameter name="quantity_changeReason"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>
            <set field="productId" from="productId ?: orderItem.productId"/>

            <!-- calculate the price based on quantity, etc, -->
            <if condition="unitAmount == null &amp;&amp; productId"><then>
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
                <set field="orderPart" from="orderItem.part"/>

                <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                              in-map="[productId:productId, quantity:quantity, priceUomId:orderHeader.currencyUomId,
                                  productStoreId:orderHeader.productStoreId, customerPartyId:orderPart.customerPartyId,
                                  vendorPartyId:orderPart.vendorPartyId]"/>

                <set field="unitAmount" from="priceMap.price"/>
                <set field="unitListPrice" from="priceMap.listPrice"/>
                <set field="isModifiedPrice" value="N"/>
            </then><else>
                <set field="isModifiedPrice" value="Y"/>
            </else></if>

            <!-- on quantity changes adjust ShipmentItem/Source (only if some already exist) -->
            <if condition="quantity != null &amp;&amp; quantity != orderItem.quantity">
                <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/><order-by field-name="shipmentId"/></entity-find>
                <if condition="shipmentItemSourceList">
                    <set field="sourceQuantityTotal" from="0"/>
                    <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                        <set field="sourceQuantityTotal" from="sourceQuantityTotal + shipmentItemSource.quantity"/></iterate>
                    <if condition="quantity &gt; sourceQuantityTotal"><then>
                        <set field="quantityIncrease" from="quantity - sourceQuantityTotal"/>
                        <!-- quantity increase, we don't know which shipment it should go on so just pick the first -->
                        <set field="shipmentItemSource" from="shipmentItemSourceList[0]"/>
                        <service-call name="update#mantle.shipment.ShipmentItemSource"
                                      in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                          quantity:(shipmentItemSource.quantity + quantityIncrease),
                                          quantityNotHandled:(shipmentItemSource.quantityNotHandled + quantityIncrease)]"/>

                        <!-- also update ShipmentItem.quantity -->
                        <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                            <field-map field-name="shipmentId" from="shipmentItemSource.shipmentId"/>
                            <field-map field-name="productId" from="orderItem.productId"/></entity-find-one>
                        <service-call name="update#mantle.shipment.ShipmentItem"
                                      in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                          quantity:(shipmentItem.quantity + quantityIncrease)]"/>
                    </then><else>
                        <!-- a little more fun, deduct as available from each item in the list until all handled -->
                        <set field="quantityReduceRemaining" from="sourceQuantityTotal - quantity"/>
                        <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                            <set field="quantityReduce" from="quantityReduceRemaining &gt; shipmentItemSource.quantityNotHandled ?
                                    shipmentItemSource.quantityNotHandled : quantityReduceRemaining"/>
                            <if condition="quantityReduce == 0"><break/></if>
                            <service-call name="update#mantle.shipment.ShipmentItemSource"
                                    in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                        quantity:(shipmentItemSource.quantity - quantityReduce),
                                        quantityNotHandled:(shipmentItemSource.quantityNotHandled - quantityReduce)]"/>
                            <set field="quantityReduceRemaining" from="quantityReduceRemaining - quantityReduce"/>

                            <!-- also update ShipmentItem.quantity -->
                            <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                                <field-map field-name="shipmentId" from="shipmentItemSource.shipmentId"/>
                                <field-map field-name="productId" from="orderItem.productId"/></entity-find-one>
                            <set field="newItemQuantity" from="shipmentItem.quantity &gt; quantityReduce ?
                                    shipmentItem.quantity - quantityReduce : 0"/>
                            <service-call name="update#mantle.shipment.ShipmentItem"
                                    in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                        quantity:newItemQuantity]"/>
                        </iterate>
                    </else></if>
                </if>
            </if>

            <service-call name="update#mantle.order.OrderItem" in-map="context"/>
            <!-- leave this out, may be nice to have a way to easily ignore messages from a specific service call: <message>Order item ${orderItemSeqId} updated</message> -->
        </actions>
    </service>
    <service verb="delete" noun="OrderItem">
        <in-parameters><auto-parameters include="pk" required="true"/></in-parameters>
        <actions>
            <!-- remove reservations -->
            <service-call name="mantle.product.AssetServices.remove#OrderItemReservations" in-map="context"/>
            <!-- delete children -->
            <entity-find entity-name="mantle.order.OrderItem" list="childItemList">
                <econdition field-name="orderId"/><econdition field-name="parentItemSeqId" from="orderItemSeqId"/></entity-find>
            <iterate list="childItemList" entry="childItem">
                <service-call name="mantle.order.OrderServices.delete#OrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:childItem.orderItemSeqId]"/>
            </iterate>
            <!-- delete item -->
            <service-call name="delete#mantle.order.OrderItem" in-map="context"/>
        </actions>
    </service>

    <!-- OrderProductQuantity aka "Cart" Services -->
    <service verb="add" noun="OrderProductQuantity" authenticate="anonymous-all">
        <!-- TODO had transaction="cache" but causing issues with updating single Payment amount and sometimes part/header total when there are multiple promotions active (ie New Customer and BOGO) -->
        <description>A service for an add-to-cart sort of operation, including:
            1. create an Order if no orderId is passed in
            2. determine the price to charge for the Product (and update based on quantity as needed)
            3. find a OrderItem matching the productId, and if found update quantity
            4. if no existing OrderItem is found create a new OrderItem
        </description>
        <in-parameters>
            <parameter name="orderId"/>
            <parameter name="orderPartSeqId"/>
            <!-- OrderHeader settings -->
            <parameter name="productStoreId"/>
            <parameter name="currencyUomId"/>
            <parameter name="salesChannelEnumId"/>
            <!-- OrderPart settings -->
            <parameter name="customerPartyId"/>
            <parameter name="carrierPartyId"/><parameter name="shipmentMethodEnumId"/>

            <parameter name="productId" required="true"/>
            <parameter name="description"/>
            <parameter name="quantity" type="BigDecimal"><description>Defaults to 1 if addToQuantity=true (default)</description></parameter>
            <parameter name="addToQuantity" type="Boolean" default="true">
                <description>If true add to existing quantity, if false set quantity on current item</description></parameter>
            <parameter name="updateExisting" type="Boolean" default="true">
                <description>If true update existing item by productId, if false always create a new item</description></parameter>
            <parameter name="itemTypeEnumId" default-value="ItemProduct"/>
            <parameter name="unitAmount" type="BigDecimal"/>
            <parameter name="standardCost" type="BigDecimal"/>
            <parameter name="requiredByDate" type="Timestamp"/>
            <parameter name="otherPartyProductId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </out-parameters>
        <actions>
            <if condition="quantity == null &amp;&amp; (addToQuantity || !updateExisting)"><set field="quantity" from="1.0"/></if>
            <!-- handle explicit zero quantity -->
            <if condition="(quantity == null || quantity &lt;= 0) &amp;&amp; updateExisting">
                <!-- do nothing if add -->
                <if condition="addToQuantity || !orderId"><return/></if>
                <!-- in set mode remove the item -->
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition-object field="[orderId:orderId, orderPartSeqId:orderPartSeqId, productId:productId,
                        productConfigSavedId:null, forAssetId:null, selectedAmount:null]"/>
                </entity-find>
                <if condition="orderItemList">
                    <service-call name="mantle.order.OrderServices.delete#OrderItem"
                            in-map="[orderId:orderId, orderItemSeqId:orderItemList[0].orderItemSeqId]"/>
                </if>
                <return/>
            </if>

            <!-- lookup orderPartSeqId if not passed in -->
            <if condition="!orderPartSeqId &amp;&amp; orderId">
                <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                    <econdition field-name="orderId"/><order-by field-name="orderPartSeqId"/></entity-find>
                <set field="orderPartSeqId" from="orderPartList?.first?.orderPartSeqId"/>
            </if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" for-update="true"/>

            <set field="productStoreId" from="productStoreId ?: orderHeader?.productStoreId"/>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
            <set field="vendorPartyId" from="orderPart?.vendorPartyId ?: productStore?.organizationPartyId"/>
            <set field="currencyUomId" from="currencyUomId ?: productStore?.defaultCurrencyUomId"/>
            <set field="salesChannelEnumId" from="salesChannelEnumId ?: productStore?.defaultSalesChannelEnumId"/>

            <!-- have customerPartyId default to current user's partyId -->
            <set field="customerPartyId" from="(customerPartyId ?: orderPart?.customerPartyId) ?: ec.user.userAccount?.partyId"/>

            <if condition="!orderId">
                <if condition="customerPartyId">
                    <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList">
                        <econdition field-name="statusId" value="OrderOpen"/>
                        <econdition field-name="customerPartyId"/>
                        <econdition field-name="productStoreId" ignore-if-empty="true"/>
                        <select-field field-name="orderId"/><select-field field-name="orderPartSeqId"/>
                        <order-by field-name="-entryDate"/><!-- get most recent open order -->
                    </entity-find>
                    <if condition="existingOrderList">
                        <set field="orderId" from="existingOrderList[0].orderId"/>
                        <set field="orderPartSeqId" from="existingOrderList[0].orderPartSeqId"/>
                    </if>
                </if>
                <!-- no existing open (cart) order found? create one -->
                <if condition="!orderId">
                    <service-call name="mantle.order.OrderServices.create#Order" out-map="createOrderOut"
                            in-map="[currencyUomId:currencyUomId, productStoreId:productStoreId, salesChannelEnumId:salesChannelEnumId,
                                vendorPartyId:vendorPartyId, customerPartyId:customerPartyId, carrierPartyId:carrierPartyId,
                                shipmentMethodEnumId:shipmentMethodEnumId]"/>
                    <set field="orderId" from="createOrderOut.orderId"/>
                    <set field="orderPartSeqId" from="createOrderOut.orderPartSeqId"/>
                </if>
            </if>

            <!-- calculate the price based on quantity, etc, -->
            <if condition="unitAmount == null"><then>
                <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                              in-map="[productId:productId, quantity:quantity, priceUomId:currencyUomId,
                         productStoreId:productStoreId, customerPartyId:customerPartyId, vendorPartyId:vendorPartyId]"/>

                <set field="unitAmount" from="priceMap.price"/>
                <set field="unitListPrice" from="priceMap.listPrice"/>
                <set field="isModifiedPrice" value="N"/>
            </then><else>
                <set field="isModifiedPrice" value="Y"/>
            </else></if>

            <!-- look up otherPartyProductId if not specified -->
            <if condition="!otherPartyProductId &amp;&amp; productId">
                <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" for-update="true"/>
                <entity-find-one entity-name="mantle.party.PartyRole" value-field="vendorOrgRole">
                    <field-map field-name="partyId" from="orderPart.vendorPartyId"/>
                    <field-map field-name="roleTypeId" value="OrgInternal"/>
                </entity-find-one>
                <if condition="vendorOrgRole != null &amp;&amp; orderPart.customerPartyId"><then>
                    <entity-find entity-name="mantle.product.ProductPrice" list="otherPartyItemIdList">
                        <date-filter/><econdition field-name="productId"/>
                        <econdition field-name="customerPartyId" from="orderPart.customerPartyId"/>
                        <econdition field-name="otherPartyItemId" operator="is-not-null"/>
                    </entity-find>
                    <if condition="otherPartyItemIdList">
                        <set field="otherPartyProductId" from="otherPartyItemIdList[0].otherPartyItemId"/></if>
                </then><else-if condition="vendorOrgRole != null &amp;&amp; orderPart.vendorPartyId">
                    <entity-find entity-name="mantle.product.ProductPrice" list="otherPartyItemIdList">
                        <date-filter/><econdition field-name="productId"/>
                        <econdition field-name="vendorPartyId" from="orderPart.vendorPartyId"/>
                        <econdition field-name="otherPartyItemId" operator="is-not-null"/>
                    </entity-find>
                    <if condition="otherPartyItemIdList">
                        <set field="otherPartyProductId" from="otherPartyItemIdList[0].otherPartyItemId"/></if>
                </else-if></if>
            </if>

            <!-- find an OrderItem for the productId and increment quantity if found, otherwise create OrderItem with quantity -->
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition-object field="[orderId:orderId, orderPartSeqId:orderPartSeqId, productId:productId,
                        productConfigSavedId:null, forAssetId:null, selectedAmount:null]"/>
            </entity-find>

            <if condition="orderItemList &amp;&amp; updateExisting"><then>
                <set field="orderItem" from="orderItemList.first"/>
                <set field="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                <set field="orderPartSeqId" from="orderItem.orderPartSeqId" set-if-empty="false"/>
                <set field="unitAmount" from="unitAmount != null ? unitAmount : orderItem.unitAmount"/>
                <set field="standardCost" from="standardCost != null ? standardCost : orderItem.standardCost"/>
                <set field="quantity" from="addToQuantity ? quantity + orderItem.quantity : quantity"/>
                <!-- if requiredByDate on orderItem is less than that passed in, make sure to use it instead of the new later one -->
                <if condition="orderItem.requiredByDate &amp;&amp; requiredByDate &amp;&amp; orderItem.requiredByDate &lt; requiredByDate">
                    <set field="requiredByDate" from="orderItem.requiredByDate"/></if>
                <service-call name="mantle.order.OrderServices.update#OrderItem" in-map="context"/>
            </then><else>
                <service-call name="mantle.order.OrderServices.create#OrderItem" in-map="context" out-map="createOrderItemOut"/>
                <set field="orderItemSeqId" from="createOrderItemOut.orderItemSeqId"/>
            </else></if>
        </actions>
    </service>
    <service verb="update" noun="OrderProductQuantity" authenticate="anonymous-all">
        <!-- TODO had transaction="cache" but causing issues with updating single Payment amount and sometimes part/header total when there are multiple promotions active (ie New Customer and BOGO) -->
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <if condition="quantity &lt;= 0">
                <service-call name="mantle.order.OrderServices.delete#OrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId]"/>
                <return/>
            </if>

            <service-call name="mantle.order.OrderServices.update#OrderItem"
                    in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId, quantity:quantity]"/>
        </actions>
    </service>
    <service verb="merge" noun="OrderItems">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="fromOrderId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" from="fromOrderId"/></entity-find>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <iterate list="orderItemList" entry="orderItem">
                <if condition="!orderItem.productId || !(orderItem.itemTypeEnumId in productItemTypes)"><continue/></if>
                <service-call name="mantle.order.OrderServices.add#OrderProductQuantity"
                        in-map="[orderId:orderId, productId:orderItem.productId, quantity:orderItem.quantity]"/>
            </iterate>
        </actions>
    </service>

    <!-- ===================================================== -->
    <!-- ========== Order Billing/Shipping Services ========== -->
    <!-- ===================================================== -->

    <service verb="set" noun="OrderBillingShippingInfo">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="paymentId"/>

            <parameter name="paymentInstrumentEnumId"/>
            <parameter name="paymentMethodId"/>
            <parameter name="finAccountId"/>
            <parameter name="shippingFacilityId"/>
            <parameter name="shippingPostalContactMechId"/>
            <parameter name="shippingTelecomContactMechId"/>

            <parameter name="carrierAndShipmentMethod"/>
            <parameter name="carrierPartyId"/>
            <parameter name="shipmentMethodEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <if condition="orderPartSeqId"><then>
                <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" for-update="true"/>
            </then><else>
                <!-- just get the first part -->
                <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                    <econdition field-name="orderId"/>
                    <order-by field-name="orderPartSeqId"/>
                </entity-find>
                <set field="orderPart" from="orderPartList.first"/>
                <set field="orderPartSeqId" from="orderPart.orderPartSeqId"/>
            </else></if>

            <if condition="shippingPostalContactMechId &amp;&amp; !shippingTelecomContactMechId">
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="postalAddress">
                    <field-map field-name="contactMechId" from="shippingPostalContactMechId"/>
                </entity-find-one>
                <set field="shippingTelecomContactMechId" from="postalAddress.telecomContactMechId"/>
            </if>

            <if condition="shippingFacilityId"><set field="orderPart.facilityId" from="shippingFacilityId"/></if>
            <if condition="shippingPostalContactMechId"><set field="orderPart.postalContactMechId" from="shippingPostalContactMechId"/></if>
            <if condition="shippingTelecomContactMechId"><set field="orderPart.telecomContactMechId" from="shippingTelecomContactMechId"/></if>
            <if condition="carrierAndShipmentMethod">
                <set field="carrierPartyId" from="carrierAndShipmentMethod.split(':')[0]"/>
                <set field="shipmentMethodEnumId" from="carrierAndShipmentMethod.split(':')[1]"/>
            </if>
            <if condition="carrierPartyId"><set field="orderPart.carrierPartyId" from="carrierPartyId"/></if>
            <if condition="shipmentMethodEnumId"><set field="orderPart.shipmentMethodEnumId" from="shipmentMethodEnumId"/></if>
            <entity-update value-field="orderPart"/>

            <!-- Find the shipment IDs for this order part -->
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                <econdition field-name="orderId"/></entity-find>
            <if condition="shipmentItemSourceList">
                <entity-find entity-name="mantle.order.OrderItem" list="partOrderItemList">
                    <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/></entity-find>
                <script>
                    List orderItemSeqIdList = partOrderItemList.orderItemSeqId
                    partShipmentIdSet = new TreeSet()
                    for (EntityValue sis in shipmentItemSourceList) if (sis.orderItemSeqId in orderItemSeqIdList) {
                        partShipmentIdSet.add(sis.shipmentId)
                    }
                </script>

                <!-- Update shipment method and shipping address on the last route segment(s) of this order part -->
                <iterate list="partShipmentIdSet" entry="shipmentId">
                    <entity-find entity-name="mantle.shipment.ShipmentRouteSegment" list="shipmentRouteSegments">
                        <econdition field-name="shipmentId"/><order-by field-name="-shipmentRouteSegmentSeqId"/></entity-find>
                    <if condition="shipmentRouteSegments">
                        <set field="shipmentRouteSegment" from="shipmentRouteSegments[0]"/>
                        <set field="shipmentRouteSegment.shipmentMethodEnumId" from="shipmentMethodEnumId"/>
                        <set field="shipmentRouteSegment.destPostalContactMechId" from="shippingPostalContactMechId"/>
                        <set field="shipmentRouteSegment.destTelecomContactMechId" from="shippingTelecomContactMechId"/>
                        <entity-update value-field="shipmentRouteSegment"/>
                    </if>
                </iterate>
            </if>

            <if condition="paymentId">
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
                <if condition="payment != null &amp;&amp; (payment.orderId != orderId || payment.orderPartSeqId != orderPartSeqId)">
                    <!-- don't allow updating/hijacking this payment, whatever it was for -->
                    <set field="payment" from="null"/>
                    <set field="paymentId" from="null"/>
                </if>
            </if>

            <if condition="payment == null">
                <!-- try the first payment for the part -->
                <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderPartSeqId"/>
                    <order-by field-name="paymentId"/>
                </entity-find>
                <set field="payment" from="paymentList.first"/>
            </if>

            <if condition="payment != null"><then>
                <!-- update existing payment -->
                <if condition="paymentMethodId"><set field="payment.paymentMethodId" from="paymentMethodId"/></if>
                <if condition="finAccountId"><set field="payment.finAccountId" from="finAccountId"/></if>
                <entity-update value-field="payment"/>
                <set field="paymentId" from="payment.paymentId"/>
            </then><else-if condition="paymentMethodId || paymentInstrumentEnumId || finAccountId">
                <!-- create a new Payment for the Order -->
                <service-call name="mantle.order.OrderServices.add#OrderPartPayment" out-map="context"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, paymentInstrumentEnumId:paymentInstrumentEnumId,
                            paymentMethodId:paymentMethodId, finAccountId:finAccountId]"/>
            </else-if></if>
        </actions>
    </service>
    <service verb="add" noun="OrderPartPayment">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.payment.Payment" include="nonpk"><exclude field-name="amountUomId"/>
                <exclude field-name="fromPartyId"/><exclude field-name="toPartyId"/><exclude field-name="acctgTransResultEnumId"/>
                <exclude field-name="reconcileStatusId"/><exclude field-name="paymentMethodFileId"/></auto-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="paymentTypeEnumId" default-value="PtInvoicePayment"/>
            <parameter name="statusId" default-value="PmntPromised"/>
            <parameter name="amount" type="BigDecimal"><description>Defaults to OrderPart.partTotal</description></parameter>
            <parameter name="visitId" default="ec.user.visitId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>
            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                    in-map="context + [amount:(amount ?: orderPart.partTotal), amountUomId:orderHeader.currencyUomId,
                        fromPartyId:orderPart.customerPartyId, toPartyId:orderPart.vendorPartyId]"/>
        </actions>
    </service>

    <!-- ================================================== -->
    <!-- ========== Order Status Change Services ========== -->
    <!-- ================================================== -->

    <service verb="change" noun="OrderStatusInterface" type="interface">
        <in-parameters><parameter name="orderId" required="true"/></in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
    </service>
    <service verb="update" noun="OrderStatus">
        <in-parameters>
            <parameter name="orderId" required="true"/><parameter name="statusId" required="true"/>
            <parameter name="placedDate" type="Timestamp"/>
        </in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList" for-update="true">
                <econdition field-name="orderId"/></entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <service-call name="update#mantle.order.OrderPart" out-map="context"
                        in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId, statusId:statusId]"/>
            </iterate>

            <set field="updateMap" from="[orderId:orderId, statusId:statusId]"/>
            <if condition="placedDate != null &amp;&amp; orderHeader.placedDate == null"><script>updateMap.put('placedDate', placedDate)</script></if>
            <service-call name="update#mantle.order.OrderHeader" out-map="context" in-map="updateMap"/>
        </actions>
    </service>
    <service verb="propose" noun="Order">
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface"/>
        <actions><service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="context + [statusId:'OrderProposed']"/></actions>
    </service>
    <service verb="place" noun="Order">
        <!-- this used to use transaction="cache" but with record locks (for asset reservation) it is unreliable, gets old data from the TX cache -->
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface"/>
        <in-parameters>
            <parameter name="placedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context"
                    in-map="context + [statusId:'OrderPlaced', placedDate:placedDate]"/>

            <!-- New Customer: see if this is the first order for a customer -->
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList" for-update="true">
                <econdition field-name="orderId"/></entity-find>
            <set field="customerPartyId" from="orderPartList ? orderPartList[0].customerPartyId : null"/>
            <if condition="!customerPartyId"><return/></if><!-- if no customer we don't know if they are new -->
            <set field="includeStatuses" from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderHold']"/>
            <entity-find-count entity-name="mantle.order.OrderHeaderAndPart" count-field="ordersCount">
                <econdition field-name="customerPartyId"/><econdition field-name="orderId" operator="not-equals"/>
                <econdition field-name="statusId" operator="in" from="includeStatuses"/>
                <!-- <econdition field-name="partStatusId" operator="in" from="includeStatuses" or-null="true"/> -->
            </entity-find-count>
            <if condition="ordersCount == 0">
                <iterate list="orderPartList" entry="orderPart">
                    <set field="orderPart.isNewCustomer" value="Y"/>
                    <entity-update value-field="orderPart"/>
                </iterate>
            </if>
        </actions>
    </service>
    <service verb="approve" noun="Order">
        <description>For manual order approval, requires ORDER_APPROVE permission.</description>
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface"/>
        <actions>
            <if condition="!ec.user.hasPermission('ORDER_APPROVE')">
                <return error="true" message="Order Approve permission required"/></if>
            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="context + [statusId:'OrderApproved']"/>
        </actions>
    </service>

    <service verb="autoApprove" noun="Order">
        <description>
            If order is in Placed status and has sufficient Authorized, Delivered, or Confirmed payments for the grandTotal
            and hasn't been in Approved status before, and there are no pre-approve warnings from OrderInfoServices.check#OrderPreApprove
            then change the order status to Approved.

            This is called by SECA rule on OrderHeader change to OrderPlaced status, and directly in PaymentServices.authorize#OrderPayments.
        </description>
        <in-parameters><parameter name="orderId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <if condition="orderHeader == null"><return error="true" message="Order ${orderId} not found"/></if>
            <if condition="orderHeader.statusId != 'OrderPlaced'"><return/></if>

            <set field="totalAuthorized" from="0.0"/>
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="orderId"/>
                <econdition field-name="statusId" operator="in" from="['PmntAuthorized', 'PmntDelivered', 'PmntConfirmed']"/>
            </entity-find>
            <set field="totalAuthorized" from="0.0"/>
            <iterate list="paymentList" entry="payment"><set field="totalAuthorized" from="totalAuthorized + (payment.amount ?: 0.0)"/></iterate>

            <!-- if we authorized all set order to approved; don't use mantle.order.OrderServices.approve#Order service,
                meant for manual approval and requires permission -->
            <if condition="totalAuthorized &gt;= orderHeader.grandTotal">
                <!-- run approval checks, don't approve if any warnings or if order has been previously approved -->
                <service-call name="mantle.order.OrderInfoServices.check#OrderPreApprove" in-map="[orderId:orderId]" out-map="checkOut"/>
                <!-- if has been Approved before don't auto-approve -->
                <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusHistoryList">
                    <econdition field-name="changedEntityName" value="mantle.order.OrderHeader"/>
                    <econdition field-name="changedFieldName" value="statusId"/>
                    <econdition field-name="pkPrimaryValue" from="orderId"/>
                    <econdition field-name="newValueText" value="OrderApproved"/>
                    <select-field field-name="auditHistorySeqId"/>
                </entity-find>

                <if condition="!checkOut.approveWarnings &amp;&amp; !statusHistoryList"><then>
                    <service-call name="mantle.order.OrderServices.update#OrderStatus" in-map="[orderId:orderId, statusId:'OrderApproved']"/>
                </then><else>
                    <log message="Not auto-approving Order ${orderId} status history: ${statusHistoryList*.auditHistorySeqId}, warnings: ${checkOut.approveWarnings}"/>
                </else></if>
            </if>
        </actions>
    </service>
    <service verb="checkComplete" noun="OrderPart">
        <description>Checks to see if all items in the order part have been shipped and/or digitally (including
            subscription) fulfilled, and if so complete the order part. Also checks for receipt of purchase order items.</description>
        <in-parameters><parameter name="orderId" required="true"/><parameter name="orderPartSeqId" required="true"/></in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>
            <if condition="!(orderPart?.statusId in ['OrderApproved', 'OrderSent'])"><return/></if>

            <entity-find entity-name="mantle.product.subscription.Subscription" list="existingSubscriptionList">
                <econdition field-name="orderId"/></entity-find>
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="existingAssetIssuanceList">
                <econdition field-name="orderId"/></entity-find>
            <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="existingAssetReceiptList">
                <econdition field-name="orderId"/></entity-find>

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                <order-by field-name="orderItemSeqId"/>
            </entity-find>

            <!-- set to true, if any found not fulfilled will set to false -->
            <set field="orderPartComplete" from="true"/>
            <iterate list="orderItemList" entry="orderItem"><if condition="orderItem.productId">
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true">
                    <field-map field-name="productId" from="orderItem.productId"/></entity-find-one>

                <if condition="product.productTypeEnumId in ['PtDigital', 'PtDigitalAsset']">
                    <entity-find entity-name="mantle.product.subscription.ProductSubscriptionResource"
                            list="productSubscriptionResourceList" cache="true">
                        <econdition field-name="productId" from="product.productId"/></entity-find>
                    <iterate list="productSubscriptionResourceList" entry="productSubscriptionResource">
                        <filter-map-list list="existingSubscriptionList" to-list="currentSubscriptionList">
                            <field-map field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                            <field-map field-name="subscriptionResourceId" from="productSubscriptionResource.subscriptionResourceId"/>
                        </filter-map-list>
                        <if condition="!currentSubscriptionList">
                            <set field="orderPartComplete" from="false"/>
                            <break/>
                        </if>
                    </iterate>
                </if>
                <if condition="product.productTypeEnumId in ['PtAsset', 'PtDigitalAsset']">
                    <filter-map-list list="existingAssetIssuanceList" to-list="currentAssetIssuanceList">
                        <field-map field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/></filter-map-list>
                    <filter-map-list list="existingAssetReceiptList" to-list="currentAssetReceiptList">
                        <field-map field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/></filter-map-list>
                    <!-- add up quantity in currentAssetIssuanceList, compare to orderItem.quantity -->
                    <set field="currentQuantityTotal" from="0" type="BigDecimal"/>
                    <iterate list="currentAssetIssuanceList" entry="currentAssetIssuance">
                        <set field="currentQuantityTotal" from="currentQuantityTotal + currentAssetIssuance.quantity"/>
                    </iterate>
                    <iterate list="currentAssetReceiptList" entry="currentAssetReceipt">
                        <set field="currentQuantityTotal" from="currentQuantityTotal + currentAssetReceipt.quantityAccepted"/>
                    </iterate>
                    <if condition="currentQuantityTotal &lt; orderItem.quantity">
                        <set field="orderPartComplete" from="false"/>
                        <break/>
                    </if>
                </if>
            </if></iterate>

            <if condition="orderPartComplete">
                <service-call name="mantle.order.OrderServices.complete#OrderPart" out-map="context" in-map="context"/>
            </if>
        </actions>
    </service>

    <service verb="complete" noun="OrderPart">
        <in-parameters><parameter name="orderId" required="true"/><parameter name="orderPartSeqId" required="true"/></in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
        <actions>
            <service-call name="update#mantle.order.OrderPart" out-map="context"
                    in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, statusId:'OrderCompleted']"/>
            <set field="allComplete" from="true"/>
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList"><econdition field-name="orderId"/></entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <if condition="orderPart.statusId != 'OrderCompleted'"><set field="allComplete" from="false"/></if>
            </iterate>
            <if condition="allComplete">
                <service-call name="update#mantle.order.OrderHeader" out-map="context"
                        in-map="[orderId:orderId, statusId:'OrderCompleted']"/>
            </if>
        </actions>
    </service>
    <service verb="complete" noun="Order">
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface"/>
        <actions><service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="context + [statusId:'OrderCompleted']"/></actions>
    </service>

    <service verb="cancel" noun="Order">
        <description>Call when customer cancels the order.</description>
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface"/>
        <actions>
            <!-- does partial cancel if already partially shipped, and then set what is left as completed; otherwise does a full cancel -->

            <!-- cancel item quantities not issued, update or remove ShipmentItemSource records, remove asset reservations if any -->
            <set field="hasIssuedQuantity" from="false"/>
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="fullAssetIssuanceList">
                <econdition field-name="orderId"/></entity-find>
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="fullShipmentItemSourceList">
                <econdition field-name="orderId"/></entity-find>

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList"><econdition field-name="orderId"/></entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <set field="itemQuantityIssued" from="0"/>
                <filter-map-list list="fullAssetIssuanceList" to-list="itemAssetIssuanceList">
                    <field-map field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/></filter-map-list>
                <iterate list="itemAssetIssuanceList" entry="itemAssetIssuance">
                    <set field="itemQuantityIssued" from="itemQuantityIssued + itemAssetIssuance.quantity"/></iterate>

                <if condition="itemQuantityIssued &gt; 0"><set field="hasIssuedQuantity" from="true"/></if>

                <!-- update the OrderItem -->
                <set field="quantityCancelled" from="orderItem.quantity - itemQuantityIssued"/>
                <service-call name="update#mantle.order.OrderItem" in-map="[orderId:orderId,
                        orderItemSeqId:orderItem.orderItemSeqId, quantityCancelled:quantityCancelled,
                        quantity:itemQuantityIssued]"/>

                <!-- update or remove ShipmentItemSource records -->
                <filter-map-list list="fullShipmentItemSourceList" to-list="itemShipmentItemSourceList">
                    <field-map field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/></filter-map-list>
                <set field="shipmentItemQuantityReducedMap" from="[:]"/>
                <iterate list="itemShipmentItemSourceList" entry="itemShipmentItemSource">
                    <script>addToBigDecimalInMap(itemShipmentItemSource.shipmentId, itemShipmentItemSource.quantityNotHandled, shipmentItemQuantityReducedMap)</script>
                    <!-- reduce quantity by quantityNotHandled -->
                    <service-call name="update#mantle.shipment.ShipmentItemSource"
                            in-map="[shipmentItemSourceId:itemShipmentItemSource.shipmentItemSourceId, quantityNotHandled:0,
                                quantity:(itemShipmentItemSource.quantity - itemShipmentItemSource.quantityNotHandled)]"/>
                </iterate>
                <iterate list="shipmentItemQuantityReducedMap" entry="shipmentItemQuantityReduced" key="shipmentId">
                    <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                        <field-map field-name="shipmentId"/><field-map field-name="productId" from="orderItem.productId"/></entity-find-one>
                    <if condition="shipmentItem">
                        <set field="newSiQuantity" from="shipmentItem.quantity &gt; shipmentItemQuantityReduced ?
                                shipmentItem.quantity - shipmentItemQuantityReduced : 0"/>
                        <service-call name="update#mantle.shipment.ShipmentItem"
                                in-map="[shipmentId:shipmentId, productId:orderItem.productId, quantity:newSiQuantity]"/>
                    </if>
                </iterate>

                <!-- remove OrderItem Reservations -->
                <service-call name="mantle.product.AssetServices.remove#OrderItemReservations"
                        in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId]"/>
            </iterate>

            <!-- cancel or complete order parts -->
            <set field="targetStatusId" from="hasIssuedQuantity ? 'OrderCompleted' : 'OrderCancelled'"/>
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList"><econdition field-name="orderId"/></entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <service-call name="update#mantle.order.OrderPart" out-map="context"
                        in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId, statusId:targetStatusId]"/>
            </iterate>

            <!-- cancel or complete order header -->
            <service-call name="update#mantle.order.OrderHeader" out-map="context"
                    in-map="[orderId:orderId, statusId:targetStatusId]"/>
        </actions>
    </service>

    <!-- ================================= -->
    <!-- ========== Clone Order ========== -->
    <!-- ================================= -->

    <service verb="clone" noun="Order">
        <description>Clone an order. Always copies the OrderHeader, OrderPart, and OrderItem records.</description>
        <in-parameters>
            <parameter name="baseOrderId" required="true" default="orderId"/>
            <parameter name="orderId"/>
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk"/>
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk"/>
            <parameter name="requiredByDate" type="Timestamp"/>
            <parameter name="statusId" default-value="OrderOpen"/>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="visitId" default="ec.user.visitId"/>
            <parameter name="orderRevision" type="Integer" default="1"/>

            <parameter name="clearDates" type="Boolean" default="true"/>
            <parameter name="productItemsOnly" type="Boolean" default="true"/>
            <parameter name="copyContactMech" type="Boolean" default="true"/>
            <parameter name="copyContent" type="Boolean" default="true"/>
            <parameter name="copyNote" type="Boolean" default="true"/>
            <parameter name="copyPartParty" type="Boolean" default="true"/>
            <parameter name="copyTerm" type="Boolean" default="true"/>
            <parameter name="copyItemWorkEffort" type="Boolean" default="true"/>
            <parameter name="copyPayment" type="Boolean" default="true"/>
            <parameter name="paymentStatusId" default-value="PmntPromised"/>
        </in-parameters>
        <out-parameters><parameter name="orderId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="order">
                <field-map field-name="orderId" from="baseOrderId"/></entity-find-one>

            <entity-set value-field="order" include="nonpk"/>
            <if condition="clearDates">
                <!-- set the fields even if null, don't do this for other fields -->
                <set field="order.entryDate" from="entryDate"/>
                <set field="order.placedDate" from="placedDate"/>
                <set field="order.lastOrderedDate" from="lastOrderedDate"/>
            </if>

            <set field="order.orderId" from="null"/>
            <entity-sequenced-id-primary value-field="order"/>
            <entity-create value-field="order"/>
            <set field="orderId" from="order.orderId"/>

            <entity-find entity-name="mantle.order.OrderPart" list="valueList">
                <econdition field-name="orderId" from="baseOrderId"/></entity-find>
            <iterate list="valueList" entry="value">
                <set field="value.orderId" from="orderId"/>
                <entity-set value-field="value" include="nonpk"/>
                <if condition="clearDates">
                    <!-- set the fields even if null, don't do this for other fields -->
                    <set field="value.shipAfterDate" from="shipAfterDate"/>
                    <set field="value.shipBeforeDate" from="shipBeforeDate"/>
                    <set field="value.estimatedShipDate" from="estimatedShipDate"/>
                    <set field="value.estimatedDeliveryDate" from="estimatedDeliveryDate"/>
                    <set field="value.validFromDate" from="validFromDate"/>
                    <set field="value.validThruDate" from="validThruDate"/>
                    <set field="value.autoCancelDate" from="autoCancelDate"/>
                    <set field="value.dontCancelSetDate" from="dontCancelSetDate"/>
                </if>
                <entity-create value-field="value"/>
            </iterate>

            <entity-find entity-name="mantle.order.OrderItem" list="valueList">
                <econdition field-name="orderId" from="baseOrderId"/></entity-find>
            <iterate list="valueList" entry="value">
                <if condition="productItemsOnly &amp;&amp; !value.productId"><continue/></if>
                <set field="value.orderId" from="orderId"/>
                <if condition="clearDates"><set field="value.requiredByDate" from="requiredByDate"/></if>
                <entity-create value-field="value"/>
            </iterate>

            <if condition="copyContactMech">
                <entity-find entity-name="mantle.order.OrderPartContactMech" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.orderId" from="orderId"/><entity-create value-field="value"/></iterate>
            </if>
            <if condition="copyContent">
                <entity-find entity-name="mantle.order.OrderContent" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId"/>
                    <set field="value.orderContentId" from="null"/>
                    <entity-sequenced-id-primary value-field="value"/>
                    <entity-create value-field="value"/>
                </iterate>
            </if>
            <if condition="copyNote">
                <entity-find entity-name="mantle.order.OrderNote" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.orderId" from="orderId"/><entity-create value-field="value"/></iterate>
            </if>
            <if condition="copyPartParty">
                <entity-find entity-name="mantle.order.OrderPartParty" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.orderId" from="orderId"/><entity-create value-field="value"/></iterate>
            </if>
            <if condition="copyTerm">
                <entity-find entity-name="mantle.order.OrderPartTerm" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.orderId" from="orderId"/><entity-create value-field="value"/></iterate>
            </if>
            <if condition="copyItemWorkEffort">
                <entity-find entity-name="mantle.order.OrderItemWorkEffort" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.orderId" from="orderId"/><entity-create value-field="value"/></iterate>
            </if>

            <if condition="copyPayment">
                <entity-find entity-name="mantle.account.payment.Payment" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId"/>
                    <set field="value.statusId" from="paymentStatusId"/>
                    <set field="value.paymentAuthCode" from="null"/><set field="value.paymentRefNum" from="null"/>
                    <set field="value.presentFlag" from="null"/><set field="value.swipedFlag" from="null"/>
                    <set field="value.processAttempt" from="null"/><set field="value.needsNsfRetry" from="null"/>
                    <set field="value.visitId" from="visitId"/>
                    <if condition="clearDates"><set field="value.effectiveDate" from="null"/></if>
                    <set field="value.paymentId" from="null"/>
                    <entity-sequenced-id-primary value-field="value"/>
                    <entity-create value-field="value"/>
                </iterate>
            </if>
        </actions>
    </service>

    <!-- ==================================================== -->
    <!-- ========== Order Change Response Services ========== -->
    <!-- ==================================================== -->

    <service verb="handle" noun="OrderItemChange">
        <description>Called by EECA rule on OrderItem create/update/delete</description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="itemTypeEnumId"/>
            <parameter name="quantity" type="BigDecimal"/>
            <parameter name="unitAmount" type="BigDecimal"/>
            <parameter name="selectedAmount" type="BigDecimal"/>
            <parameter name="isPromo"/>
            <parameter name="originalValue" type="Map"/>
            <parameter name="eecaOperation"/>
        </in-parameters>
        <actions>
            <if condition="eecaOperation == 'delete'">
                <service-call name="mantle.order.OrderServices.update#OrderPartTotal" in-map="context"/>
                <return/>
            </if>

            <if condition="!originalValue || quantity != originalValue.quantity || unitAmount != originalValue.unitAmount ||
                    selectedAmount != originalValue.selectedAmount || orderPartSeqId != originalValue.orderPartSeqId"><then>
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
                <service-call name="mantle.order.OrderServices.update#OrderPartTotal" in-map="context"/>
                <if condition="originalValue &amp;&amp; orderPartSeqId != originalValue.orderPartSeqId">
                    <service-call name="mantle.order.OrderServices.update#OrderPartTotal"
                            in-map="[orderId:orderId, orderPartSeqId:originalValue.orderPartSeqId]"/>
                </if>

                <if condition="orderHeader.productStoreId &amp;&amp; isPromo != 'Y' &amp;&amp; !(itemTypeEnumId in ['ItemShipping', 'ItemSalesTax', 'ItemVatTax'])">
                    <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]"/>
                    <if condition="originalValue &amp;&amp; orderPartSeqId != originalValue.orderPartSeqId">
                        <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                                in-map="[orderId:orderId, orderPartSeqId:originalValue.orderPartSeqId]"/>
                    </if>
                </if>
                <!-- NOTE: no need to increment#OrderRevision, will be done when part updated -->
            </then><else>
                <!-- increment order revision if anything else changes on an item -->
                <service-call name="mantle.order.OrderServices.increment#OrderRevision" in-map="context"/>
            </else></if>
        </actions>
    </service>
    <service verb="handle" noun="OrderPartChange">
        <description>Called by EECA rule on OrderPart update</description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="carrierPartyId"/>
            <parameter name="shipmentMethodEnumId"/>
            <parameter name="postalContactMechId"/>
            <parameter name="customerPartyId"/>
            <parameter name="disablePromotions"/>
            <parameter name="disableShippingCalc"/>
            <parameter name="disableTaxCalc"/>
            <parameter name="partTotal" type="BigDecimal"/>
            <parameter name="originalValue" type="Map"/>
        </in-parameters>
        <actions>
            <!-- generally if partTotal changes only that has changed, so don't consider it any sort of significant change -->
            <if condition="originalValue &amp;&amp; partTotal != originalValue.partTotal"><return/></if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <if condition="orderHeader.productStoreId &amp;&amp; (!originalValue || postalContactMechId != originalValue.postalContactMechId ||
                    carrierPartyId != originalValue.carrierPartyId || shipmentMethodEnumId != originalValue.shipmentMethodEnumId ||
                    customerPartyId != originalValue.customerPartyId || disablePromotions != originalValue.disablePromotions ||
                    disableShippingCalc != originalValue.disableShippingCalc || disableTaxCalc != originalValue.disableTaxCalc)"><then>
                <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]"/>
            </then><else>
                <service-call name="mantle.order.OrderServices.increment#OrderRevision" in-map="context"/>
            </else></if>
        </actions>
    </service>
    <service verb="handle" noun="OrderMajorChange">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="orderHeader" type="EntityValue"/>
        </in-parameters>
        <actions>
            <set field="sharedFlagKey" from="'OrderMajorChange' + orderId + orderPartSeqId"/>
            <if condition="ec.context.getSharedMap().get(sharedFlagKey)"><return/></if>

            <if condition="orderHeader == null"><entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/></if>
            <if condition="orderHeader.productStoreId">
                <!-- set flag in context root to avoid recursive triggers -->
                <script>ec.context.getSharedMap().put(sharedFlagKey, true)</script>

                <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" for-update="true"/>

                <!-- Apply Promotions -->
                <if condition="!'Y'.equals(orderPart.disablePromotions)">
                    <entity-find entity-name="mantle.order.OrderItem" list="promoItemList">
                        <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="isPromo" value="Y"/>
                    </entity-find>
                    <iterate list="promoItemList" entry="promoItem">
                        <service-call name="mantle.order.OrderServices.delete#OrderItem"
                                in-map="[orderId:promoItem.orderId, orderItemSeqId:promoItem.orderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.product.PromotionServices.apply#OrderPromotions"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, orderHeader:orderHeader]"/>
                </if>

                <!-- Calculate Shipping, after promotions so that order total/etc is adjusted for them -->
                <if condition="!'Y'.equals(orderPart.disableShippingCalc)">
                    <entity-find entity-name="mantle.order.OrderItem" list="shippingItemList">
                        <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="itemTypeEnumId" value="ItemShipping"/>
                    </entity-find>
                    <iterate list="shippingItemList" entry="shippingItem">
                        <service-call name="mantle.order.OrderServices.delete#OrderItem"
                                in-map="[orderId:shippingItem.orderId, orderItemSeqId:shippingItem.orderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.shipment.CarrierServices.calculate#OrderPartShipping"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, createOrderItem:true]"/>
                </if>

                <!-- Calculate Tax, after Shipping as it might be taxed -->
                <if condition="!'Y'.equals(orderPart.disableTaxCalc)">
                    <entity-find entity-name="mantle.order.OrderItem" list="taxItemList">
                        <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="itemTypeEnumId" operator="in" value="ItemSalesTax,ItemVatTax"/>
                    </entity-find>
                    <iterate list="taxItemList" entry="taxItem">
                        <service-call name="mantle.order.OrderServices.delete#OrderItem"
                                in-map="[orderId:taxItem.orderId, orderItemSeqId:taxItem.orderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.other.TaxServices.calculate#OrderSalesTax"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]"/>
                </if>

                <script>ec.context.getSharedMap().remove(sharedFlagKey)</script>

                <service-call name="mantle.order.OrderServices.increment#OrderRevision" in-map="context"/>
            </if>
        </actions>
    </service>

    <service verb="update" noun="OrderHeaderTotal">
        <description>Update OrderHeader.grandTotal based on OrderPart.partTotal values, called by update#OrderPartTotal
            which is called by EECA on OrderItem</description>
        <in-parameters>
            <parameter name="orderId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <set field="totalSum" from="0.0" type="BigDecimal"/>
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList"><econdition field-name="orderId"/></entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <set field="totalSum" from="totalSum + (orderPart.partTotal ?: 0)"/>
            </iterate>
            <set field="orderHeader.grandTotal" from="totalSum"/>
            <entity-update value-field="orderHeader"/>
        </actions>
    </service>
    <service verb="update" noun="OrderPartTotal">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="originalValue" type="Map"/>
        </in-parameters>
        <actions>
            <set field="totalSum" from="0.0" type="BigDecimal"/>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/></entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.order.OrderServices.get#OrderItemTotal" out-map="itemTotalOut" in-map="[orderItem:orderItem]"/>
                <set field="totalSum" from="totalSum + itemTotalOut.itemTotal"/>
            </iterate>

            <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
            <set field="totalSum" from="(totalSum as BigDecimal).setScale(2, BigDecimal.ROUND_HALF_UP)"/>

            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" for-update="true"/>
            <set field="orderPart.partTotal" from="totalSum"/>
            <entity-update value-field="orderPart"/>

            <!-- if there is one Payment associated with the OrderPart with statusId in PmntProposed,PmntPromised update it -->
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                <econdition field-name="statusId" operator="in" value="PmntProposed,PmntPromised"/>
                <select-field field-name="paymentId"/>
            </entity-find>
            <if condition="paymentList.size() == 1">
                <service-call name="update#mantle.account.payment.Payment"
                        in-map="[paymentId:paymentList.get(0).paymentId, amount:totalSum]"/>
                <!-- <log level="warn" message="Set order part ${orderId}:${orderPartSeqId} total to ${orderPart.partTotal} and payment ${paymentList.get(0).paymentId} amount to ${totalSum}"/> -->
            </if>

            <!-- now update the OrderHeader.grandTotal -->
            <service-call name="mantle.order.OrderServices.update#OrderHeaderTotal" in-map="[orderId:orderId]"/>
        </actions>
    </service>
    <service verb="increment" noun="OrderRevision">
        <in-parameters>
            <parameter name="orderId"/>
        </in-parameters>
        <actions>
            <if condition="!orderId"><return/></if>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true">
                <field-map field-name="orderId"/></entity-find-one>
            <!-- TODO: not using <select-field field-name="orderId,orderRevision"/> because of issue in EntityValue where a bunch of stuff gets set to null -->
            <if condition="orderHeader != null">
                <set field="orderHeader.orderRevision" from="(orderHeader.orderRevision ?: 1) + 1"/>
                <entity-update value-field="orderHeader"/>
            </if>
        </actions>
    </service>

    <!-- ========== OrderContent Services ========== -->

    <service verb="create" noun="OrderContent">
        <in-parameters>
            <auto-parameters entity-name="mantle.order.OrderContent" include="nonpk">
                <exclude field-name="contentLocation"/></auto-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
        </in-parameters>
        <out-parameters><parameter name="orderContentId"/></out-parameters>
        <actions>
            <service-call name="create#mantle.order.OrderContent" in-map="context" out-map="context"/>
            <if condition="contentFile != null &amp;&amp; contentFile.size &gt; 0">
                <service-call name="mantle.order.OrderServices.save#OrderContentFile" in-map="context"/></if>
        </actions>
    </service>
    <service verb="update" noun="OrderContent">
        <in-parameters>
            <parameter name="orderContentId" required="true"/>
            <auto-parameters entity-name="mantle.order.OrderContent" include="nonpk">
                <exclude field-name="contentLocation"/></auto-parameters>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
        </in-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; contentFile.size &gt; 0">
                <entity-find-one entity-name="mantle.order.OrderContent" value-field="orderContent"/>
                <service-call name="mantle.order.OrderServices.save#OrderContentFile" out-map="context"
                        in-map="context + [orderId:orderContent.orderId, saveContentLocation:false]"/>
            </if>
            <service-call name="update#mantle.order.OrderContent" in-map="context"/>
        </actions>
    </service>
    <service verb="save" noun="OrderContentFile">
        <in-parameters>
            <parameter name="orderContentId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem" required="true"/>
            <parameter name="saveContentLocation" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters><parameter name="contentLocation"/></out-parameters>
        <actions>
            <set field="filename" from="contentFile.getName()"/>
            <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            <set field="contentLocation" value="${contentRoot}/order/${orderId}/content_${orderContentId}/${filename}"/>

            <set field="docRr" from="ec.resource.getLocationReference(contentLocation)"/>
            <script>
                fileStream = contentFile.getInputStream()
                try { docRr.putStream(fileStream) } finally { fileStream.close() }
            </script>

            <if condition="saveContentLocation"><service-call name="update#mantle.order.OrderContent"
                    in-map="[orderContentId:orderContentId, contentLocation:contentLocation]"/></if>
        </actions>
    </service>

    <!-- ========== Order-Request Services ========== -->

    <service verb="create" noun="PurchaseRequestOrder">
        <in-parameters>
            <parameter name="requestId" required="true"/>
            <parameter name="customerPartyId" required="true">
                <description>The customer for the PO. Should be an Internal Org.</description></parameter>
            <parameter name="paymentInstrumentEnumId" default-value="PiCompanyCheck"/>
            <parameter name="paymentMethodId"/>
            <parameter name="shipmentMethodEnumId" default-value="ShMthPickUp"/>
            <parameter name="placeAndApproveOrders" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.request.Request" value-field="request"/>
            <if condition="!request.facilityId">
                <return error="true" message="Request ${requestId} has no Facility set."/>
            </if>

            <entity-find entity-name="mantle.facility.FacilityContactMech" list="postalList" cache="true">
                <date-filter/><econdition field-name="facilityId" from="request.facilityId"/>
                <econdition field-name="contactMechPurposeId" operator="in" value="PostalShippingDest,PostalGeneral"/>
                <order-by field-name="-contactMechPurposeId,-fromDate"/><!-- prefer PostalShippingDest over PostalGeneral, get most recent -->
            </entity-find>
            <set field="shippingPostalContactMechId" from="postalList?.first?.contactMechId"/>

            <entity-find entity-name="mantle.facility.FacilityContactMech" list="phoneList" cache="true">
                <date-filter/><econdition field-name="facilityId" from="request.facilityId"/>
                <econdition field-name="contactMechPurposeId" operator="in" value="PhoneShippingDest,PhonePrimary"/>
                <order-by field-name="-contactMechPurposeId,-fromDate"/><!-- prefer PhoneShippingDest over PhonePrimary, get most recent -->
            </entity-find>
            <set field="shippingTelecomContactMechId" from="phoneList?.first?.contactMechId"/>

            <entity-find entity-name="mantle.request.RequestItem" list="allRequestItemList">
                <econdition field-name="requestId"/></entity-find>

            <!-- split request by supplierPartyId, create one PO for each -->
            <set field="requestItemListBySupplier" from="[:]"/>
            <iterate list="allRequestItemList" entry="requestItem">
                <if condition="!requestItem.supplierPartyId">
                    <return error="true" message="No Supplier set on item ${requestItem.requestItemSeqId} for Request ${requestId}"/></if>
                <script>addToListInMap(requestItem.supplierPartyId, requestItem, requestItemListBySupplier)</script>
            </iterate>

            <iterate list="requestItemListBySupplier" entry="requestItemList" key="supplierPartyId">
                <service-call name="mantle.order.OrderServices.create#Order" out-map="orderOut"
                        in-map="[vendorPartyId:supplierPartyId, customerPartyId:customerPartyId,
                            currencyUomId:(request.currencyUomId ?: 'USD'), facilityId:request.facilityId]"/>
                <set field="earliestRequiredByDate" from="null"/>
                <iterate list="requestItemList" entry="requestItem">
                    <service-call name="mantle.order.OrderServices.add#OrderProductQuantity"
                            in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId,
                                productId:requestItem.productId, quantity:requestItem.quantity,
                                itemTypeEnumId:'ItemProduct', requiredByDate:requestItem.requiredByDate]" out-map="addOut"/>
                    <service-call name="create#mantle.request.RequestItemOrder"
                            in-map="[requestId:requestItem.requestId, requestItemSeqId:requestItem.requestItemSeqId,
                                orderId:orderOut.orderId, orderItemSeqId:addOut.orderItemSeqId, quantity:requestItem.quantity]"/>
                    <if condition="!earliestRequiredByDate || (requestItem.requiredByDate &amp;&amp; requestItem.requiredByDate &lt; earliestRequiredByDate)">
                        <set field="earliestRequiredByDate" from="requestItem.requiredByDate"/></if>
                </iterate>
                <if condition="earliestRequiredByDate">
                    <service-call name="update#mantle.order.OrderPart" in-map="[orderId:orderOut.orderId,
                            orderPartSeqId:orderOut.orderPartSeqId, shipBeforeDate:earliestRequiredByDate]"/>
                </if>
                <service-call name="mantle.order.OrderServices.set#OrderBillingShippingInfo"
                        in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId,
                            paymentInstrumentEnumId:paymentInstrumentEnumId, paymentMethodId:paymentMethodId,
                            shippingPostalContactMechId:shippingPostalContactMechId,
                            shippingTelecomContactMechId:shippingTelecomContactMechId,
                            shipmentMethodEnumId:shipmentMethodEnumId]"/>
                <if condition="placeAndApproveOrders">
                    <service-call name="mantle.order.OrderServices.place#Order"
                            in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId]"/>
                    <service-call name="mantle.order.OrderServices.approve#Order"
                            in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId]"/>
                </if>
            </iterate>

            <!-- Order created for Purchase Request, set Request status to In Progress -->
            <service-call name="update#mantle.request.Request" in-map="[requestId:requestId, statusId:'ReqInProgress']"/>
        </actions>
    </service>
</services>
