<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">
    <service verb="get" noun="SalesOrderSummary">
        <in-parameters>
            <parameter name="interval" default-value="M"/><!-- day = d, week = w, month = M, quarter = q, year = y -->
            <parameter name="intervalCount" type="Integer" default="13"/>
            <parameter name="thruDate" type="Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
            <parameter name="offset"/>
            <parameter name="maPeriods" type="Integer" default="0"/>
            <parameter name="vendorPartyIds" type="List"><parameter name="vendorPartyId"/></parameter>
            <parameter name="productStoreIds" type="List"><parameter name="productStoreId"/></parameter>
            <parameter name="customerClassificationIds" type="List"><parameter name="customerClassificationId"/></parameter>
            <parameter name="productIds" type="List"><parameter name="productId"/></parameter>
            <parameter name="dateFormat" default-value="dd MMM yyyy"/>
            <parameter name="indexName" default-value="mantle_sales"/>
            <parameter name="documentType" default-value="MantleSalesOrderItem"/>
            <parameter name="dateField" default-value="placedDate"/>
        </in-parameters>
        <out-parameters>
            <parameter name="salesOrderSummaryList" type="List"><parameter name="result" type="Map"/></parameter>
            <parameter name="ordersThis" type="Map"/>
            <parameter name="ordersLast" type="Map"/>
            <parameter name="ordersPrior" type="Map"/>
            <parameter name="ordersAverage" type="Map"/>
            <parameter name="ordersTotal" type="Map"/>
        </out-parameters>
        <actions><script><![CDATA[
            import org.elasticsearch.action.search.SearchResponse
            import org.elasticsearch.index.query.QueryBuilders
            import org.elasticsearch.search.aggregations.AggregationBuilder
            import org.elasticsearch.search.aggregations.AggregationBuilders
            import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval
            import org.elasticsearch.search.aggregations.BucketOrder
            import org.joda.time.DateTimeZone
            import org.moqui.elasticsearch.ElasticSearchUtil
            import groovy.json.JsonOutput
            import java.time.temporal.ChronoUnit
            import java.time.temporal.TemporalUnit

            int maInt = maPeriods
            if (maInt < 0) maInt = 0
            int displayIntervalCount = interval == 'q' ? (intervalCount * 3) : intervalCount
            int searchIntervalCount = displayIntervalCount + maInt

            Map<String, TemporalUnit> tempUnits = [d:ChronoUnit.DAYS, w:ChronoUnit.WEEKS, M:ChronoUnit.MONTHS, q:ChronoUnit.MONTHS, y:ChronoUnit.YEARS]
            Map<String, String> perMap = [d:'day', w:'week', M:'month', q:'quarter', y:'year']
            ArrayList<Timestamp> curPer = ec.user.getPeriodRange(perMap.get(interval), 0, thruDate)
            Timestamp thruTimestamp = curPer[1]
            def fromDateDt = java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(curPer[0].time), TimeZone.getDefault().toZoneId())
            fromDateDt = fromDateDt.minus(searchIntervalCount, tempUnits.get(interval))
            // ec.logger.warn("from ${fromDateDt} thru ${thruTimestamp}")

            List filterList = [
                    [range: [(dateField): [gte:(fromDateDt.toInstant().toEpochMilli() as String), lt:(thruTimestamp.time as String), format: 'epoch_millis']]],
                    [terms: [partStatusId: ['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderHold']]],
                    [terms: [statusId: ['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderHold']]]
            ]
            if (vendorPartyIds) filterList.add([terms: [vendorPartyId: vendorPartyIds]])
            if (productStoreIds) filterList.add([terms: [productStoreId: productStoreIds]])
            if (customerClassificationIds) filterList.add([terms: [customerClassId: customerClassificationIds]])
            if (productIds) filterList.add([terms: [productId: productIds]])
            Map queryMap = [bool: [filter: filterList]]

            AggregationBuilder aggBuilder = AggregationBuilders.dateHistogram("DateOuter").field((String) dateField)
                    .order(BucketOrder.key(false)).timeZone(DateTimeZone.forTimeZone(TimeZone.getDefault()))
                    .dateHistogramInterval(new DateHistogramInterval("1" + (String) interval)).format((String) dateFormat)

            if (!offset && interval == 'w') {
                // default to offset based on user's firstDayOfWeek relative to the ElasticSearch default of Monday for weekly date histogram
                int userFirstDay = ec.user.getCalendarSafe().getFirstDayOfWeek()
                int userMondayOffset = userFirstDay - Calendar.MONDAY
                offset = (userMondayOffset < 0 ? '-' : '+') + Math.abs(userMondayOffset) + 'd'
            }
            if (offset) aggBuilder.offset((String) offset)

            // order count
            aggBuilder.subAggregation(AggregationBuilders.cardinality("orderCount").field("orderId"))

            // total sales (itemSaleTotal, no item type restriction)
            aggBuilder.subAggregation(AggregationBuilders.sum("totalSales").field("itemSaleTotal"))

            // product only sums
            AggregationBuilder itemProductFilter = AggregationBuilders.filter("ItemProduct",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([term:[itemTypeEnumId:"ItemProduct"]])))

            // total product sales (itemSaleTotal; itemTypeEnumId = ItemProduct)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productSaleTotal").field("itemSaleTotal"))
            // total product shipped (issuedSaleTotal; itemTypeEnumId = ItemProduct)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productIssuedTotal").field("issuances.issuedSaleTotal"))
            // product cost total (issuedCostTotal)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productCostTotal").field("issuances.issuedCostTotal"))
            // product quantity total
            itemProductFilter.subAggregation(AggregationBuilders.sum("productQuantityTotal").field("orderQuantity"))

            aggBuilder.subAggregation(itemProductFilter)

            // total discounts (itemSaleTotal for discount itemTypeEnumId)
            List discountTypes = ['ItemDiscount', 'ItemPromptDiscount', 'ItemCouponCredit', 'ItemPromoDiscount', 'ItemFreeFills', 'ItemSlottingFees', 'ItemAdjAdvertising', 'ItemAdjJointAdv']
            AggregationBuilder itemDiscountFilter = AggregationBuilders.filter("ItemDiscount",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([terms:[itemTypeEnumId:discountTypes]])))
            itemDiscountFilter.subAggregation(AggregationBuilders.sum("discountTotal").field("itemSaleTotal"))
            aggBuilder.subAggregation(itemDiscountFilter)

            // new customer order count
            AggregationBuilder newCustFilter = AggregationBuilders.filter("NewCustomer",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([term:[isNewCustomer:'Y']])))
            newCustFilter.subAggregation(AggregationBuilders.cardinality("newCustomerOrderCount").field("orderId"))
            aggBuilder.subAggregation(newCustFilter)

            // do the search
            SearchResponse sr = ElasticSearchUtil.aggregationSearch(indexName, [documentType], null, queryMap, aggBuilder, ec)

            salesOrderSummaryList = []
            ordersTotal = [dateKey:"Prior Total"]
            for (def dateBucket in sr.getAggregations().get("DateOuter").getBuckets()) {
                def prodAgg = dateBucket.getAggregations().get("ItemProduct")
                def discAgg = dateBucket.getAggregations().get("ItemDiscount")
                def newCustAgg = dateBucket.getAggregations().get("NewCustomer")
                BigDecimal orderCount = new BigDecimal(dateBucket.getAggregations().get("orderCount").getValue())
                BigDecimal newCustomerOrderCount = new BigDecimal(newCustAgg.getAggregations().get("newCustomerOrderCount").getValue())
                BigDecimal productSaleTotal = new BigDecimal(prodAgg.getAggregations().get("productSaleTotal").getValue())
                BigDecimal productIssuedTotal = new BigDecimal(prodAgg.getAggregations().get("productIssuedTotal").getValue())
                BigDecimal productCostTotal = new BigDecimal(prodAgg.getAggregations().get("productCostTotal").getValue())
                BigDecimal discountTotal = new BigDecimal(discAgg.getAggregations().get("discountTotal").getValue())
                Map curLine = [dateKey:dateBucket.getKeyAsString(),
                        orderCount:orderCount, newCustomerOrderCount:newCustomerOrderCount,
                        newCustomerPercent:(orderCount ? (newCustomerOrderCount/orderCount) : 0.0),
                        totalSales:new BigDecimal(dateBucket.getAggregations().get("totalSales").getValue()),
                        productSaleTotal:productSaleTotal, productIssuedTotal:productIssuedTotal, productCostTotal:productCostTotal,
                        productQuantityTotal:new BigDecimal(prodAgg.getAggregations().get("productQuantityTotal").getValue()),
                        discountTotal:discountTotal, netSales:(productSaleTotal + discountTotal),
                        discountPercent:(productSaleTotal ? (-discountTotal/productSaleTotal) : 0.0),
                        costPercent:(productIssuedTotal ? (productCostTotal/productIssuedTotal) : 0.0),
                        orderCountMa:0.0, newCustomerOrderCountMa:0.0, newCustomerPercentMa:0.0, productQuantityTotalMa:0.0,
                        productSaleTotalMa:0.0, discountPercentMa:0.0, netSalesMa:0.0]
                salesOrderSummaryList.add(curLine)
                // don't include the first (most recent) period in the total and average
                if (salesOrderSummaryList.size() > 1) addBigDecimalsInMap(ordersTotal, curLine)
            }

            // get the this, last, prior periods before reversing list
            ordersThis = salesOrderSummaryList.size() > 0 ? salesOrderSummaryList[0] : null
            ordersLast = salesOrderSummaryList.size() > 1 ? salesOrderSummaryList[1] : null
            ordersPrior = salesOrderSummaryList.size() > 2 ? salesOrderSummaryList[2] : null

            // reverse the list (comes back from ES newest first)
            salesOrderSummaryList.reverse(true)

            // calculate moving averages
            if (maInt > 0 && salesOrderSummaryList.size() > maInt) {
                BigDecimal maBd = new BigDecimal(maInt)
                // NOTE: buckets originally come back newest to oldest so for MA reverse, then reverse after
                List originalList = new ArrayList(salesOrderSummaryList)
                // trim list for maInt so it has only display periods
                salesOrderSummaryList = new ArrayList(originalList.subList(maInt, originalList.size()))
                for (int idx = 0; idx < salesOrderSummaryList.size(); idx++) {
                    Map curLine = (Map) salesOrderSummaryList.get(idx)
                    List lookbackList = originalList.subList(idx, idx + maInt)
                    curLine.orderCountMa = lookbackList*.orderCount.sum() / maBd
                    curLine.newCustomerOrderCountMa = lookbackList*.newCustomerOrderCount.sum() / maBd
                    curLine.newCustomerPercentMa = lookbackList*.newCustomerPercent.sum() / maBd
                    curLine.productQuantityTotalMa = lookbackList*.productQuantityTotal.sum() / maBd
                    curLine.productSaleTotalMa = lookbackList*.productSaleTotal.sum() / maBd
                    curLine.discountPercentMa = lookbackList*.discountPercent.sum() / maBd
                    curLine.netSalesMa = lookbackList*.netSales.sum() / maBd
                }
            }

            ordersTotal.newCustomerPercent = null
            ordersTotal.discountPercent = null
            ordersTotal.costPercent = null

            BigDecimal avgCount = new BigDecimal(salesOrderSummaryList.size())
            ordersAverage = new LinkedHashMap(ordersTotal)
            divideBigDecimalsInMap(ordersAverage, avgCount)
            ordersAverage.dateKey = "Prior Average"
            ordersAverage.newCustomerPercent = (ordersAverage.orderCount ? (ordersAverage.newCustomerOrderCount/ordersAverage.orderCount) : 0.0)
            ordersAverage.discountPercent = (ordersAverage.productSaleTotal ? (-ordersAverage.discountTotal/ordersAverage.productSaleTotal) : 0.0)
            ordersAverage.costPercent = (ordersAverage.productIssuedTotal ? (ordersAverage.productCostTotal/ordersAverage.productIssuedTotal) : 0.0)

            salesOrderSummaryList.add(ordersAverage)
            salesOrderSummaryList.add(ordersTotal)
        ]]></script></actions>
    </service>

    <service verb="get" noun="SalesInvoiceSummary">
        <in-parameters>
            <parameter name="interval" default-value="M"/><!-- day = d, week = w, month = M, quarter = q, year = y -->
            <parameter name="intervalCount" type="Integer" default="13"/>
            <parameter name="thruDate" type="Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
            <parameter name="offset"/>
            <parameter name="maPeriods" type="Integer" default="0"/>
            <parameter name="fromPartyIds" type="List"><parameter name="fromPartyId"/></parameter>
            <parameter name="productStoreIds" type="List"><parameter name="productStoreId"/></parameter>
            <parameter name="customerClassificationIds" type="List"><parameter name="customerClassificationId"/></parameter>
            <parameter name="productIds" type="List"><parameter name="productId"/></parameter>
            <parameter name="dateFormat" default-value="dd MMM yyyy"/>
            <parameter name="indexName" default-value="mantle_sales"/>
            <parameter name="invoiceDocumentType" default-value="MantleSalesInvoice"/>
            <parameter name="itemDocumentType" default-value="MantleSalesInvoiceItem"/>
            <parameter name="dateField" default-value="invoiceDate"/>
        </in-parameters>
        <out-parameters>
            <parameter name="salesInvoiceSummaryList" type="List"><parameter name="result" type="Map"/></parameter>
            <parameter name="invoicesThis" type="Map"/>
            <parameter name="invoicesLast" type="Map"/>
            <parameter name="invoicesPrior" type="Map"/>
            <parameter name="invoicesAverage" type="Map"/>
            <parameter name="invoicesTotal" type="Map"/>
        </out-parameters>
        <actions><script><![CDATA[
            import org.elasticsearch.action.search.SearchResponse
            import org.elasticsearch.index.query.QueryBuilders
            import org.elasticsearch.search.aggregations.AggregationBuilder
            import org.elasticsearch.search.aggregations.AggregationBuilders
            import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval
            import org.elasticsearch.search.aggregations.BucketOrder
            import org.joda.time.DateTimeZone
            import org.moqui.elasticsearch.ElasticSearchUtil
            import groovy.json.JsonOutput
            import java.time.temporal.ChronoUnit
            import java.time.temporal.TemporalUnit

            int maInt = maPeriods
            if (maInt < 0) maInt = 0
            int displayIntervalCount = interval == 'q' ? (intervalCount * 3) : intervalCount
            int searchIntervalCount = displayIntervalCount + maInt

            Map<String, TemporalUnit> tempUnits = [d:ChronoUnit.DAYS, w:ChronoUnit.WEEKS, M:ChronoUnit.MONTHS, q:ChronoUnit.MONTHS, y:ChronoUnit.YEARS]
            Map<String, String> perMap = [d:'day', w:'week', M:'month', q:'quarter', y:'year']
            ArrayList<Timestamp> curPer = ec.user.getPeriodRange(perMap.get(interval), 0, thruDate)
            Timestamp thruTimestamp = curPer[1]
            def fromDateDt = java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(curPer[0].time), TimeZone.getDefault().toZoneId())
            fromDateDt = fromDateDt.minus(searchIntervalCount, tempUnits.get(interval))
            // ec.logger.warn("from ${fromDateDt} thru ${thruTimestamp}")

            List filterList = [
                    [range: [(dateField): [gte:(fromDateDt.toInstant().toEpochMilli() as String), lt:(thruTimestamp.time as String), format: 'epoch_millis']]],
                    [terms: [statusId: ['InvoiceFinalized', 'InvoiceSent', 'InvoiceAcked', 'InvoicePmtRecvd']]]
            ]
            if (fromPartyIds) filterList.add([terms: [fromPartyId: fromPartyIds]])
            if (productStoreIds) filterList.add([terms: [productStoreId: productStoreIds]])
            if (customerClassificationIds) filterList.add([terms: [customerClassId: customerClassificationIds]])
            if (productIds) filterList.add([terms: [productId: productIds]])
            Map queryMap = [bool: [filter: filterList]]

            // prep the invoice level search
            AggregationBuilder invAggBuilder = AggregationBuilders.dateHistogram("DateOuter").field(dateField)
                    .order(BucketOrder.key(false)).minDocCount(1).timeZone(DateTimeZone.forTimeZone(TimeZone.getDefault()))
                    .dateHistogramInterval(new DateHistogramInterval("1" + (String) interval)).format((String) dateFormat)

            if (!offset && interval == 'w') {
                // default to offset based on user's firstDayOfWeek relative to the ElasticSearch default of Monday for weekly date histogram
                int userFirstDay = ec.user.getCalendarSafe().getFirstDayOfWeek()
                int userMondayOffset = userFirstDay - Calendar.MONDAY
                offset = (userMondayOffset < 0 ? '-' : '+') + Math.abs(userMondayOffset) + 'd'
            }
            if (offset) invAggBuilder.offset((String) offset)

            // total sales
            invAggBuilder.subAggregation(AggregationBuilders.sum("invoiceTotal").field("invoiceTotal"))
            // total paid
            // NOTE: may want this to behave differently, somehow do a nested aggregation for only applications with appliedDate less than the end date of the current date range
            invAggBuilder.subAggregation(AggregationBuilders.sum("invoicePaymentsApplied").field("appliedPaymentsTotal"))
            // total pre-paid
            invAggBuilder.subAggregation(AggregationBuilders.sum("prePaymentsTotal").field("prePaymentsTotal"))

            // do the invoice search
            SearchResponse invSr = ElasticSearchUtil.aggregationSearch(indexName, [invoiceDocumentType], null, queryMap, invAggBuilder, ec)

            // prep the invoice item search
            AggregationBuilder itemAggBuilder = AggregationBuilders.dateHistogram("DateOuter").field(dateField)
                    .order(BucketOrder.key(false)).timeZone(DateTimeZone.forTimeZone(TimeZone.getDefault()))
                    .dateHistogramInterval(new DateHistogramInterval("1" + (String) interval)).format((String) dateFormat)
            if (offset) itemAggBuilder.offset((String) offset)

            // invoice count
            itemAggBuilder.subAggregation(AggregationBuilders.cardinality("invoiceIdCount").field("invoiceId"))
            // total sales (itemSaleTotal, no item type restriction)
            itemAggBuilder.subAggregation(AggregationBuilders.sum("totalSales").field("itemSaleTotal"))

            // product only counts
            AggregationBuilder itemProductFilter = AggregationBuilders.filter("ItemProduct",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([term:[itemTypeEnumId:"ItemProduct"]])))
            // total product sales (itemSaleTotal; itemTypeEnumId = ItemProduct)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productSaleTotal").field("itemSaleTotal"))
            // total product shipped (issuedSaleTotal; itemTypeEnumId = ItemProduct)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productIssuedTotal").field("issuances.issuedSaleTotal"))
            // product cost total (issuedCostTotal)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productCostTotal").field("issuances.issuedCostTotal"))
            // product quantity total
            itemProductFilter.subAggregation(AggregationBuilders.sum("productQuantityTotal").field("quantity"))
            itemAggBuilder.subAggregation(itemProductFilter)

            // total discounts (itemSaleTotal for discount itemTypeEnumId)
            List discountTypes = ['ItemDiscount', 'ItemPromptDiscount', 'ItemCouponCredit', 'ItemPromoDiscount', 'ItemFreeFills', 'ItemSlottingFees', 'ItemAdjAdvertising', 'ItemAdjJointAdv']
            AggregationBuilder itemDiscountFilter = AggregationBuilders.filter("ItemDiscount",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([terms:[itemTypeEnumId:discountTypes]])))
            itemDiscountFilter.subAggregation(AggregationBuilders.sum("discountTotal").field("itemSaleTotal"))
            itemAggBuilder.subAggregation(itemDiscountFilter)

            // do the invoice item search
            SearchResponse itemSr = ElasticSearchUtil.aggregationSearch(indexName, [itemDocumentType], null, queryMap, itemAggBuilder, ec)

            // make list for invoice details
            Map<String, Map> invoiceTempMap = [:]
            for (def dateBucket in invSr.getAggregations().get("DateOuter").getBuckets()) {
                BigDecimal invoiceTotal = new BigDecimal(dateBucket.getAggregations().get("invoiceTotal").getValue())
                BigDecimal invoicePaymentsApplied = new BigDecimal(dateBucket.getAggregations().get("invoicePaymentsApplied").getValue())
                BigDecimal prePaymentsTotal = new BigDecimal(dateBucket.getAggregations().get("prePaymentsTotal").getValue())
                invoiceTempMap.put(dateBucket.getKeyAsString(), [dateKey:dateBucket.getKeyAsString(), invoiceCount:new BigDecimal(dateBucket.getDocCount()),
                        invoiceTotal:invoiceTotal, invoicePaymentsApplied:invoicePaymentsApplied, prePaymentsTotal:prePaymentsTotal,
                        paidPercent:(invoiceTotal ? (invoicePaymentsApplied/invoiceTotal) : 0.0),
                        prePaidPercent:(invoiceTotal ? (prePaymentsTotal/invoiceTotal) : 0.0)])
            }

            // prep the list from items first
            salesInvoiceSummaryList = []
            invoicesTotal = [dateKey:"Prior Total"]
            for (def dateBucket in itemSr.getAggregations().get("DateOuter").getBuckets()) {
                String keyAsString = dateBucket.getKeyAsString()
                Map invoiceTemp = invoiceTempMap.remove(keyAsString)
                if (!invoiceTemp) ec.logger.warn("In SalesInvoiceSummary no invoice summary for ${keyAsString}")
                def prodAgg = dateBucket.getAggregations().get("ItemProduct")
                def discAgg = dateBucket.getAggregations().get("ItemDiscount")
                BigDecimal invoiceIdCount = new BigDecimal(dateBucket.getAggregations().get("invoiceIdCount").getValue())
                BigDecimal invoiceCount = invoiceTemp?.invoiceCount ?: invoiceIdCount
                BigDecimal productSaleTotal = new BigDecimal(prodAgg.getAggregations().get("productSaleTotal").getValue())
                BigDecimal productIssuedTotal = new BigDecimal(prodAgg.getAggregations().get("productIssuedTotal").getValue())
                BigDecimal productCostTotal = new BigDecimal(prodAgg.getAggregations().get("productCostTotal").getValue())
                BigDecimal discountTotal = new BigDecimal(discAgg.getAggregations().get("discountTotal").getValue())
                Map curLine = [invoiceCount:invoiceCount, invoiceIdCount:invoiceIdCount,
                        totalSales:new BigDecimal(dateBucket.getAggregations().get("totalSales").getValue()),
                        productSaleTotal:productSaleTotal, productIssuedTotal:productIssuedTotal, productCostTotal:productCostTotal,
                        productQuantityTotal:new BigDecimal(prodAgg.getAggregations().get("productQuantityTotal").getValue()),
                        discountTotal:discountTotal, netSales:(productSaleTotal + discountTotal),
                        discountPercent:(productSaleTotal ? (-discountTotal/productSaleTotal) : 0.0),
                        costPercent:(productIssuedTotal ? (productCostTotal/productIssuedTotal) : 0.0),
                        invoiceCountMa:0.0, productQuantityTotalMa:0.0, invoiceTotalMa:0.0, paidPercentMa:0.0,
                        prePaidPercentMa:0.0, costPercentMa:0.0, discountPercentMa:0.0]
                if (invoiceTemp) {
                    curLine.putAll(invoiceTemp)
                } else {
                    curLine.putAll([dateKey:dateBucket.getKeyAsString(), invoiceTotal:0.0,
                            invoicePaymentsApplied:0.0, prePaymentsTotal:0.0, paidPercent:0.0, prePaidPercent:0.0])
                }
                salesInvoiceSummaryList.add(curLine)
                // don't include the first (most recent) period in the total and average
                if (salesInvoiceSummaryList.size() > 1) addBigDecimalsInMap(invoicesTotal, curLine)
            }
            ec.logger.info("In SalesInvoiceSummary invoiceTempMap remaining: ${invoiceTempMap}")

            // get the this, last, prior periods before reversing list
            invoicesThis = salesInvoiceSummaryList.size() > 0 ? salesInvoiceSummaryList[0] : null
            invoicesLast = salesInvoiceSummaryList.size() > 1 ? salesInvoiceSummaryList[1] : null
            invoicesPrior = salesInvoiceSummaryList.size() > 2 ? salesInvoiceSummaryList[2] : null

            // reverse the list (comes back from ES newest first)
            salesInvoiceSummaryList.reverse(true)

            // calculate moving averages
            if (maInt > 0 && salesInvoiceSummaryList.size() > maInt) {
                BigDecimal maBd = new BigDecimal(maInt)
                // NOTE: buckets originally come back newest to oldest so for MA reverse, then reverse after
                List originalList = new ArrayList(salesInvoiceSummaryList)
                // trim list for maInt so it has only display periods
                salesInvoiceSummaryList = new ArrayList(originalList.subList(maInt, originalList.size()))
                for (int idx = 0; idx < salesInvoiceSummaryList.size(); idx++) {
                    Map curLine = (Map) salesInvoiceSummaryList.get(idx)
                    List lookbackList = originalList.subList(idx, idx + maInt)
                    curLine.invoiceCountMa = lookbackList*.invoiceCount.sum() / maBd
                    curLine.productQuantityTotalMa = lookbackList*.productQuantityTotal.sum() / maBd
                    curLine.invoiceTotalMa = lookbackList*.invoiceTotal.sum() / maBd
                    curLine.paidPercentMa = lookbackList*.paidPercent.sum() / maBd
                    curLine.prePaidPercentMa = lookbackList*.prePaidPercent.sum() / maBd
                    curLine.costPercentMa = lookbackList*.costPercent.sum() / maBd
                    curLine.discountPercentMa = lookbackList*.discountPercent.sum() / maBd
                }
            }

            invoicesTotal.paidPercent = null
            invoicesTotal.prePaidPercent = null
            invoicesTotal.discountPercent = null
            invoicesTotal.costPercent = null

            BigDecimal avgCount = new BigDecimal(salesInvoiceSummaryList.size())
            invoicesAverage = new LinkedHashMap(invoicesTotal)
            divideBigDecimalsInMap(invoicesAverage, avgCount)
            invoicesAverage.dateKey = "Prior Average"
            invoicesAverage.paidPercent = (invoicesAverage.invoiceTotal ? (invoicesAverage.invoicePaymentsApplied/invoicesAverage.invoiceTotal) : 0.0)
            invoicesAverage.prePaidPercent = (invoicesAverage.invoiceTotal ? (invoicesAverage.prePaymentsTotal/invoicesAverage.invoiceTotal) : 0.0)
            invoicesAverage.discountPercent = (invoicesAverage.productSaleTotal ? (-invoicesAverage.discountTotal/invoicesAverage.productSaleTotal) : 0.0)
            invoicesAverage.costPercent = (invoicesAverage.productIssuedTotal ? (invoicesAverage.productCostTotal/invoicesAverage.productIssuedTotal) : 0.0)

            salesInvoiceSummaryList.add(invoicesAverage)
            salesInvoiceSummaryList.add(invoicesTotal)
        ]]></script></actions>
    </service>

    <service verb="get" noun="SalesTopProduct">
        <in-parameters>
            <parameter name="interval" default-value="M"/><!-- day = d, week = w, month = M, quarter = q, year = y -->
            <parameter name="thruDate" type="Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
            <parameter name="indexName" default-value="mantle_sales"/>
            <parameter name="documentType" default-value="MantleSalesOrderItem"/>
            <parameter name="topLimit" type="Integer" default="10"/>
            <parameter name="poffset" type="Integer" default="-1"/>
            <parameter name="dateField" default-value="placedDate"/>
            <parameter name="orderByField" default-value="totalSales"/>
        </in-parameters>
        <out-parameters>
            <parameter name="topProductList" type="List"><parameter name="result" type="Map"/></parameter>
            <parameter name="topProductStart" type="Timestamp"/>
            <parameter name="topProductEnd" type="Timestamp"/>
        </out-parameters>
        <actions><script><![CDATA[
            import org.elasticsearch.action.search.SearchResponse
            import org.elasticsearch.index.query.QueryBuilders
            import org.elasticsearch.search.aggregations.AggregationBuilder
            import org.elasticsearch.search.aggregations.AggregationBuilders
            import org.elasticsearch.search.aggregations.BucketOrder
            import org.elasticsearch.search.aggregations.bucket.terms.Terms
            import org.joda.time.DateTimeZone
            import org.moqui.elasticsearch.ElasticSearchUtil
            import groovy.json.JsonOutput

            Map<String, String> perMap = [d:'day', w:'week', M:'month', q:'quarter', y:'year']
            ArrayList<Timestamp> curPer = ec.user.getPeriodRange(perMap.get(interval), poffset, thruDate)
            /* no longer do this, other aggregations now use an offset to match the Java week definition for user's Locale:
            // for weeks shift by one to start on Monday (like ES does for aggregations) instead of Sunday
            if (interval == 'w') { curPer[0] = curPer[0] + 1; curPer[1] = curPer[1] + 1 }
            */
            topProductStart = curPer[0]
            topProductEnd = curPer[1]

            Map queryMap = [bool: [filter: [
                    [range: [(dateField): [gte:(curPer[0].time as String), lt:(curPer[1].time as String), format: 'epoch_millis']]],
                    [terms: [partStatusId: ['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderHold']]]
            ]]]

            // By Product Term
            AggregationBuilder prodAggBuilder = AggregationBuilders.terms("TopTerms").field("productId").size(topLimit)
                    .order(BucketOrder.aggregation(orderByField, false))
            prodAggBuilder.subAggregation(AggregationBuilders.sum("totalQuantity").field("orderQuantity"))
            prodAggBuilder.subAggregation(AggregationBuilders.sum("totalSales").field("itemSaleTotal"))
            // total product shipped (issuedSaleTotal; itemTypeEnumId = ItemProduct)
            prodAggBuilder.subAggregation(AggregationBuilders.sum("productIssuedTotal").field("issuances.issuedSaleTotal"))
            // product cost total (issuedCostTotal)
            prodAggBuilder.subAggregation(AggregationBuilders.sum("productCostTotal").field("issuances.issuedCostTotal"))

            SearchResponse prodSr = ElasticSearchUtil.aggregationSearch(indexName, [documentType], null, queryMap, prodAggBuilder, ec)

            topProductList = new ArrayList(topLimit)
            for (Terms.Bucket bucket in prodSr.getAggregations().get("TopTerms").getBuckets()) {
                BigDecimal productIssuedTotal = new BigDecimal(bucket.getAggregations().get("productIssuedTotal").getValue())
                BigDecimal productCostTotal = new BigDecimal(bucket.getAggregations().get("productCostTotal").getValue())
                Map curLine = [productId:bucket.keyAsString,
                        totalQuantity:new BigDecimal(bucket.getAggregations().get("totalQuantity").getValue()),
                        totalSales:new BigDecimal(bucket.getAggregations().get("totalSales").getValue()),
                        productIssuedTotal:productIssuedTotal, productCostTotal:productCostTotal,
                        costPercent:(productIssuedTotal ? (productCostTotal/productIssuedTotal) : 0.0)]
                topProductList.add(curLine)
            }
        ]]></script></actions>
    </service>
    <service verb="get" noun="InvoicesByCustomerClass">
        <in-parameters>
            <parameter name="interval" default-value="M"/><!-- day = d, week = w, month = M, quarter = q, year = y -->
            <parameter name="thruDate" type="Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
            <parameter name="indexName" default-value="mantle_sales"/>
            <parameter name="invoiceDocumentType" default-value="MantleSalesInvoice"/>
            <parameter name="itemDocumentType" default-value="MantleSalesInvoiceItem"/>
            <parameter name="topLimit" type="Integer" default="100"/><!-- high limit to show all customer classes -->
            <parameter name="poffset" type="Integer" default="-1"/>
            <parameter name="dateField" default-value="invoiceDate"/>
            <parameter name="orderByField" default-value="-invoiceTotal"/>
        </in-parameters>
        <out-parameters>
            <parameter name="topCustomerClassList" type="List"><parameter name="result" type="Map"/></parameter>
            <parameter name="topCustomerClassStart" type="Timestamp"/>
            <parameter name="topCustomerClassEnd" type="Timestamp"/>
        </out-parameters>
        <actions><script><![CDATA[
            import org.elasticsearch.action.search.SearchResponse
            import org.elasticsearch.index.query.QueryBuilders
            import org.elasticsearch.search.aggregations.AggregationBuilder
            import org.elasticsearch.search.aggregations.AggregationBuilders
            import org.elasticsearch.search.aggregations.bucket.terms.Terms
            import org.joda.time.DateTimeZone
            import org.moqui.elasticsearch.ElasticSearchUtil
            import groovy.json.JsonOutput

            Map<String, String> perMap = [d:'day', w:'week', M:'month', q:'quarter', y:'year']
            ArrayList<Timestamp> curPer = ec.user.getPeriodRange(perMap.get(interval), poffset, thruDate)
            /* no longer do this, other aggregations now use an offset to match the Java week definition for user's Locale:
            // for weeks shift by one to start on Monday (like ES does for aggregations) instead of Sunday
            if (interval == 'w') { curPer[0] = curPer[0] + 1; curPer[1] = curPer[1] + 1 }
            */
            topCustomerClassStart = curPer[0]
            topCustomerClassEnd = curPer[1]

            Map queryMap = [bool: [filter: [
                    [range: [(dateField): [gte:(curPer[0].time as String), lt:(curPer[1].time as String), format: 'epoch_millis']]],
                    [terms: [statusId: ['InvoiceFinalized', 'InvoiceSent', 'InvoiceAcked', 'InvoicePmtRecvd']]]
            ]]]

            // prep the invoice level search
            AggregationBuilder invAggBuilder = AggregationBuilders.terms("TopTerms").field("customerClassId").size(topLimit)

            // total sales
            invAggBuilder.subAggregation(AggregationBuilders.sum("invoiceTotal").field("invoiceTotal"))
            // total paid
            // NOTE: may want this to behave differently, somehow do a nested aggregation for only applications with appliedDate less than the end date of the current date range
            invAggBuilder.subAggregation(AggregationBuilders.sum("invoicePaymentsApplied").field("appliedPaymentsTotal"))
            // do the invoice search
            SearchResponse invSr = ElasticSearchUtil.aggregationSearch(indexName, [invoiceDocumentType], null, queryMap, invAggBuilder, ec)

            // prep the invoice item search
            AggregationBuilder itemAggBuilder = AggregationBuilders.terms("TopTerms").field("customerClassId").size(topLimit)

            // invoice count
            itemAggBuilder.subAggregation(AggregationBuilders.cardinality("invoiceIdCount").field("invoiceId"))
            // total sales (itemSaleTotal, no item type restriction)
            itemAggBuilder.subAggregation(AggregationBuilders.sum("totalSales").field("itemSaleTotal"))

            // product only counts
            AggregationBuilder itemProductFilter = AggregationBuilders.filter("ItemProduct",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([term:[itemTypeEnumId:"ItemProduct"]])))
            // total product sales (itemSaleTotal; itemTypeEnumId = ItemProduct)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productSaleTotal").field("itemSaleTotal"))
            // total product shipped (issuedSaleTotal; itemTypeEnumId = ItemProduct)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productIssuedTotal").field("issuances.issuedSaleTotal"))
            // product cost total (issuedCostTotal)
            itemProductFilter.subAggregation(AggregationBuilders.sum("productCostTotal").field("issuances.issuedCostTotal"))
            // product quantity total
            itemProductFilter.subAggregation(AggregationBuilders.sum("productQuantityTotal").field("quantity"))
            itemAggBuilder.subAggregation(itemProductFilter)

            // total discounts (itemSaleTotal for discount itemTypeEnumId)
            List discountTypes = ['ItemDiscount', 'ItemPromptDiscount', 'ItemCouponCredit', 'ItemPromoDiscount', 'ItemFreeFills', 'ItemSlottingFees', 'ItemAdjAdvertising', 'ItemAdjJointAdv']
            AggregationBuilder itemDiscountFilter = AggregationBuilders.filter("ItemDiscount",
                    QueryBuilders.wrapperQuery(JsonOutput.toJson([terms:[itemTypeEnumId:discountTypes]])))
            itemDiscountFilter.subAggregation(AggregationBuilders.sum("discountTotal").field("itemSaleTotal"))
            itemAggBuilder.subAggregation(itemDiscountFilter)

            // do the invoice item search
            SearchResponse itemSr = ElasticSearchUtil.aggregationSearch(indexName, [itemDocumentType], null, queryMap, itemAggBuilder, ec)

            // make list for invoice details
            Map<String, Map> invoiceTempMap = [:]
            for (Terms.Bucket bucket in invSr.getAggregations().get("TopTerms").getBuckets()) {
                BigDecimal invoiceTotal = new BigDecimal(bucket.getAggregations().get("invoiceTotal").getValue())
                BigDecimal invoicePaymentsApplied = new BigDecimal(bucket.getAggregations().get("invoicePaymentsApplied").getValue())
                invoiceTempMap.put(bucket.keyAsString, [customerClassId:bucket.keyAsString, invoiceCount:new BigDecimal(bucket.getDocCount()),
                        invoiceTotal:invoiceTotal, invoicePaymentsApplied:invoicePaymentsApplied,
                        paidPercent:(invoiceTotal ? (invoicePaymentsApplied/invoiceTotal) : 0.0)])
            }

            // prep the list from items first
            invoicesTotal = [classDescription:"Total"]
            for (Terms.Bucket bucket in itemSr.getAggregations().get("TopTerms").getBuckets()) {
                String customerClassId = bucket.getKeyAsString()
                Map invoiceTemp = invoiceTempMap.get(customerClassId)
                if (!invoiceTemp) { invoiceTemp = [customerClassId:customerClassId]; invoiceTempMap.put(customerClassId, invoiceTemp) }
                def prodAgg = bucket.getAggregations().get("ItemProduct")
                def discAgg = bucket.getAggregations().get("ItemDiscount")
                BigDecimal invoiceIdCount = new BigDecimal(bucket.getAggregations().get("invoiceIdCount").getValue())
                BigDecimal invoiceCount = invoiceTemp?.invoiceCount ?: invoiceIdCount
                BigDecimal productSaleTotal = new BigDecimal(prodAgg.getAggregations().get("productSaleTotal").getValue())
                BigDecimal productIssuedTotal = new BigDecimal(prodAgg.getAggregations().get("productIssuedTotal").getValue())
                BigDecimal productCostTotal = new BigDecimal(prodAgg.getAggregations().get("productCostTotal").getValue())
                BigDecimal discountTotal = new BigDecimal(discAgg.getAggregations().get("discountTotal").getValue())
                Map curLine = [invoiceCount:invoiceCount, invoiceIdCount:invoiceIdCount,
                        totalSales:new BigDecimal(bucket.getAggregations().get("totalSales").getValue()),
                        productSaleTotal:productSaleTotal, productIssuedTotal:productIssuedTotal, productCostTotal:productCostTotal,
                        productQuantityTotal:new BigDecimal(prodAgg.getAggregations().get("productQuantityTotal").getValue()),
                        discountTotal:discountTotal, netSales:(productSaleTotal + discountTotal),
                        discountPercent:(productSaleTotal ? (-discountTotal/productSaleTotal) : 0.0),
                        costPercent:(productIssuedTotal ? (productCostTotal/productIssuedTotal) : 0.0)]
                invoiceTemp.putAll(curLine)
                addBigDecimalsInMap(invoicesTotal, invoiceTemp)
            }

            topCustomerClassList = new ArrayList(invoiceTempMap.values())
            orderMapList(topCustomerClassList, [orderByField])
            for (Map classLine in topCustomerClassList) {
                String customerClassId = classLine.customerClassId
                classLine.classDescription = ec.entity.find("mantle.party.PartyClassification").condition("partyClassificationId", customerClassId)
                        .one()?.get("description")
            }

            invoicesTotal.paidPercent = null
            invoicesTotal.discountPercent = null
            invoicesTotal.costPercent = null

            topCustomerClassList.add(invoicesTotal)
        ]]></script></actions>
    </service>
</services>
